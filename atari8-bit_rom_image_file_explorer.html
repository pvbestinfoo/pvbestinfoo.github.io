<!DOCTYPE html>
<html lang="en">
<title>Atari 8-bit rom image file explorer</title>
<style>
    @font-face {
        font-family: 'Atari';
        src: url(data:application/font-woff;charset=utf-8;base64,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) format('woff');
        font-weight: normal;
        font-style: normal;
    }

    body {
        background-color: #F8F8F8;
        font-family: "Open Sans", "Helvetica Neue", Helvetica;
        padding: 20px;
        display: flex;
        flex-direction: column;
    }

    canvas {
        border: none;
        padding: 0px;
        margin: 0px;
        transform-origin: 0px 2px;
    }

    nav {
        border: solid 1px #CCC;
        background: #CCF;
    }

    ul {
        list-style-type: none;
        border: none;
        margin: 0px;
        padding: 0px;
    }

    li {
        font-size: x-small;
    }

    li:hover {
        background-color: yellow;
        filter: brightness(200%);
    }

    li .recovered {
        filter: brightness(75%);
    }

    li .isdir {
        filter: brightness(125%);
    }

    h1, h2, h3, h4, h5, h6 {
        font-weight: 300;
    }

    h2 {
        font-size: 30px;
    }

    #gl {
        border: solid 1px #C00;
    }

    canvas {
        image-rendering: -moz-crisp-edges;          /* FF 6.0+                       */
        image-rendering: -webkit-optimize-contrast; /* Safari                        */
        image-rendering: -o-crisp-edges;            /* OS X & Windows Opera (12.02+) */
        image-rendering: pixelated;                 /* Awesome future-browsers       */
        image-rendering: crisp-edges;
        -ms-interpolation-mode: nearest-neighbor;   /* IE                            */
    }

    td {
        border: solid 8px #F8F8F8;
        padding: 16px;
        margin: 16px;
        background: #23A;
        color: #FFF;
        font-weight: 500;
    }

    .sw {
        background: #A32;
    }

    .hw {
        background: #3A2;
    }

    .over {
        border: 2px dashed #F00;
    }

    .info {
        min-height: 32px;
        padding: 8px;
        border-bottom: 1px solid #CCC;
        font-size: small;
    }
    
    /*(PVB ADD) NEW ADDED STYLES FOR ROM MANAGEMENT MENU********************************/
    .rommap {
        padding: 8px;
        border-bottom: 1px solid #CCC;
    }
    .rominfoid {
        padding: 5px 5px 5px 5px;
        border: 1px solid green;
        color: green;
        font-size: 11px;
        line-height: 1.1em;
        margin-bottom: 12px;
    }
    .extract {
        overflow: auto;
        font-size: 11px;
        padding: 10px;
        border-bottom: 1px solid #CCC;
    }
    /**************** (PVB ADD) STYLE FOR THE DISASSEMBLY EXTRACT BUTTON***************/
    .buttonstyled {
        height: auto;
        border-color: #FFF;
        padding: 5px;
        text-align: center;
        color: #000;
        border-radius: 0px;
    }
    .buttonstyled:hover {
        background-color: rgba(180, 180, 180, 0.6);
    }
    .buttonstyled:active {
        box-shadow: inset -1px -1px 2px rgba(255, 255, 255, 0.6), inset 1px 1px 2px rgba(0, 0, 0, 0.6);
    }
    .buttonstyled:disabled {
        color: #888;
        background-color: rgba(180, 180, 180, 0.6);
    }
    /**************** (PVB ADD) STYLE FOR THE ID=FILE DISASSEMBLY OR DUMP OPTIONS***************/
    pre#disoption {
        display: flex;
        flex-direction: column;
        border-bottom: solid 1px #CCC;
        margin-top: 0px;
    }
    #disoptionform {
        margin-top: 0em;
        margin-bottom: 0em;
    }
    .doblock {
        display: flex;
        align-items: flex-end;
        justify-content: space-between;
    } 
    .docbgrp {
	    display: flex;
	    align-items: center;
    }
    input[type="checkbox"] {
	    width: 10px;
	    height: 10px;
	    margin-right: 0.5rem;
        cursor: pointer;
    }
    label {
        line-height: 1em;
    } 
    fieldset {
        margin-top: 0px;
        line-height: 0em;
        font-size: 10px;
        padding-block-start: 10px;
        padding-inline-start: 10px;
        border: solid 1px #CCC;
    }
    .dobgrp {
        display: flex;
        flex-direction: column;
        align-items: flex-end;
    }
    input {
        margin-top: 2px;
        font-size: 12px;
    }
    /*(PVB end of ADD) *************************************************************************************/
    
    .infof {
        min-height: 32px;
        padding: 8px;
        border-bottom: 1px solid #CCC;
        font-size: small;
        overflow: hidden;
    }

    .close-icon {
        display: block;
        box-sizing: border-box;
        width: 12px;
        height: 12px;
        border-width: 2px;
        border-style: solid;
        border-color: gray;
        border-radius: 100%;
        background: -webkit-linear-gradient(-45deg, transparent 0%, transparent 46%, white 46%, white 56%, transparent 56%, transparent 100%), -webkit-linear-gradient(45deg, transparent 0%, transparent 46%, white 46%, white 56%, transparent 56%, transparent 100%);
        background-color: gray;
        transition: all 0.3s ease;
        margin: 4px;
        float: right;
    }

    .close-icon:hover {
        border-color: red;
        background-color: red;
    }

    .radio {
        user-select: none;
        cursor: pointer;
        font-size: small;
        height: 16px;
        margin-left: 12px;
        margin-right: 12px;
        margin-top: 4px;
    }

    .radio:last-child {
        margin-right: 0px;
    }

    .radio span {
        border: 1px solid #CCC;
        padding-left: 12px;
        padding-right: 12px;
        vertical-align: top;
    }

    .hilite {
        background: #CCF;
    }

    .exts {
        font-weight: 300;
        padding: 4px;
        margin: 4px;
        font-size: small;
        width: 600px;
    }

    .exts b {
        display: inline-block;
        margin-right: 16px;
        width: 140px;
        text-align: right;
    }

    .open {
        display: inline-block;
        font-size: large;
        cursor: pointer;
        width: 200px;
        border: solid 1px #CCC;
        font-weight: 300;
        margin: 20px;
        color: #AAA;
    }

    .open:hover {
        color: #888;
        border: solid 1px #888;
    }

    .open:active {
        color: #FFF;
        border: solid 1px #FFF;
    }

    .showcode {
        cursor: pointer;
        font-size: x-small;
        height: 16px;
        padding: 2px 4px;
        margin-left: 12px;
        margin-right: 12px;
        margin-top: 4px;
        border: solid 1px #CCC;
    }

    .showcode:hover {
        color: #F00;
        border: solid 1px #F00;
    }

    /*(PVB ADD) NEW ADDED STYLES FOR BANK DUMP/DISASSEMBLY BUTTON********************************************/
    .bankcode {
        cursor: pointer;
        font-size: x-small;
        height: 12px;
        padding: 1px 2px;
        margin-left: 4px;
        margin-right: 4px;
        margin-top: 2px;
        border: solid 1px #888;
        background-color: #EEE;
    }
    .bankcode:hover {
        color: #F00;
        border: solid 1px #F00;
    }
    /*(PVB end of ADD) *************************************************************************************/

    .palette {
        margin-left: 8px;
        display: inline-block;
    }

    .dropdown {
        position: relative;
        display: inline-block;
    }

    .dropdown-content {
        display: none;
        position: absolute;
        top: 16px;
        background: #CCC;
        min-width: 288px;
        box-shadow: 0px 8px 16px 0px rgba(0, 0, 0, 0.5);
        z-index: 100;
        margin: 0px;
        padding: 0px;
    }

    .dropdown:hover .dropdown-content {
        display: block;
    }

    .acolor {
        display: inline-block;
        min-width: 16px;
        min-height: 16px;
        border: solid 1px #CCC;
        vertical-align: bottom;
    }

    .acolor:hover {
        border: solid 1px #FFF;
    }

    .atari {
        font-family: 'Atari';
        font-size: 16px;
        line-height: 16px;
        background: #153382;
        color: #B5D3FF;
    }

    #atari_text {
        padding: 4px;
    }

    pre {
        padding: 8px;
        font-size: 10px;
        line-height: 10px;
    }

    pre data {
        font-family: 'Atari';
        font-size: 8px;
        font-weight: normal;
        background: #153382;
        color: #B5D3FF;
    }

    .floater {
        position: fixed;
        z-index: 10;
        cursor: pointer;
        user-select: none;
        line-height: 16px;
        letter-spacing: 0px;
        box-shadow: 0px 8px 16px 0px rgba(0, 0, 0, 0.5);
    }

    .floater span:hover {
        filter: brightness(200%);
    }

    .floater span:active {
        background: #B5D3FF;
        color: #153382;
    }

    .disassembly {
        left: 24px;
        top: 384px;
        width: 492px;
        max-height: 384px;
        overflow: scroll;
        background: #EEE;
    }

    .draggable {
        width: 100%;
        padding: 4px 8px;
        background: #CCF;
        border: solid 1px #CCC;
        font-size: small;
        font-weight: bold;
    }
    /*PVB MOD : height to 116px instead of 84 (2x16 added) for the E & S option*/
    .tools {
        width: 20px;
        height: 116px;
        left: 0px;
        top: 320px;
        text-align: center;
    }

    .dimmed {
        filter: brightness(75%);
    }

    .keyboard {
        display: none;
        left: 24px;
        top: 320px;
        height: 256px;
        width: 256px;
        z-index: 11;
    }

    .keyboard_invert {
        font-family: "Open Sans", "Helvetica Neue", Helvetica;
        text-align: center;
        vertical-align: center;
        color: #000;
        font-size: x-small;
        background: #F8F8F8;
    }

    .keyboard_invert:hover {
        background: #CCF;
    }
</style>
<script>
    var _ajax = function (m, u, c, d) {
        var x = new XMLHttpRequest;
        x.onreadystatechange = function () { x.readyState ^ 4 || c(this) };
        x.open(m, u);
        if (d) {
            x.setRequestHeader('Content-Type', 'application/json');
            d = JSON.stringify(d);
        }
        x.send(d);
    };

    var _q = function (q) { //(PVB COM) q is an id selector like "#toc", ou or class selector like ".disassembly"
        return document.querySelector(q) //(PVB COM) returns the HTML selector, ex "div.floater.disassembly"
    };

    var _h = function (q, html) {
        var e = _q(q);
        if (!e) {
            console.log("_h can't find " + q);
            return null;
        }
        return e.innerHTML = html; //(PVB COM) display the "html" code on the dsiplay in the <div id= 'e' >
    };

    var _txt = function (q) {
        return _q(q).innerText;
    };

    function stop() {
        event.preventDefault();
        event.stopPropagation();
    }

    function get(url, cb, d) {
        _ajax(d ? "post" : "get", url, function (r) {
            var o = JSON.parse(r.responseText);
            cb(JSON.parse(r.responseText));
        }, d);
    }

    function save_bytes(name, data) {
        var blob = new Blob([data], { type: "application/data" });
        var link = document.createElement('a');
        link.href = window.URL.createObjectURL(blob);
        link.download = name;
        link.click();
    }

    var _hex = "0123456789ABCDEF";
    function hex(i, len) {
        var s = '';
        if (!len) //(PVB COM) taille par defaut = 2 caracteres
            len = 2;
        while (len--)
            s += _hex[(i >> (len * 4)) & 0xF];
        return s;
    }

    function escapestr(c) { //(PVB COM) escaping the HTML <> in the string
        switch (c) {
            case "<": return "&lt;"
            case ">": return "&gt;"
        }
        return c;
    }

    function esc(s) { //(PVB COM) esc function is not used ??!! //(PVB TODO) = check why
        var n = ''; 
        for (var i = 0; i < s.length; i++)
            n += escapestr(s.charAt(i));
        return n;
    }
    
    //(PVB MOD) improvement of hex_line() function: display of sector/offset
    //previously //function hex_line(addr, data, i, len, awidth) {
    //added : sector and sector offset display instead of memory pointer
    //modified the variable name 'i' to 'idx' for index
    //when 'awidth' is the sector_size value (128) or (256), thus greater than 15
    function hex_line(addr, data, idx, len, awidth, dsector, doffset) {
        //addr = address of the beginning of the line; data = byte database;
        //idx = index in the byte database; awidth = number of char to display if <15; or if not, a sector and an offset (dsector, doffset) to display
        var s = []; //(PVB MOD)
        if (awidth > 15) //(PVB MOD) awitdth is greater than 15 => this is a sector size
            s = ["[" + hex(dsector, 4) + ":" + hex(doffset, 2) + "] "];
        else //(PVB MOD) default display
            s = [hex(addr, awidth || 6) + "   "]; //if awidth is zero then it is replaced by 6 digits, which should be enought for a disk dump pointer up to 0xFFFFFF bytes
        var p = '';
        var left = addr & 15;
        var right = (16 - ((addr + len) & 15)) & 15;
        if (left) {
            p += `<span style='background:#CCC'>${' '.repeat(left - 1)} </span>`;
            s.push('   '.repeat(left));
        }
        while (len--) {
            var j = data[idx];
            p += String.fromCharCode(j + 0xE000);
            s.push(hex(data[idx++], 2) + " ");
        }
        if (right) {
            p += `<span style='background:#CCC'>${' '.repeat(right - 1)} </span>`;
            s.push('   '.repeat(right));
        }
        return s.join('') + "   <data>" + p + "</data>";
    }

    //(PVB MOD) improvement of hex_dump() function: display of sector/offset
    //previously //function hex_dump(a, i, len, awidth) {
    //modified : the variable name 'hexOption' instead of 'awidth'
    //if 'awidth' has a sector_size value (128) or (256), then sector and sector offset are displayed instead of memory pointer
    //if 'awidth' is greater or equal to 0x1000, then the 'awidth' is an address used for real memory pointer display
    function hex_dump(a, i, len, hexOption) {
        //(PVB) a = byte database; i = index from 0 to xxxx = address; len = number of data to compute
        //if hexOption = x then there is x char for the memory pointer, but if hexOption = 0 then there is 6 char (thanks to hex_line() function)
        //if hexOption = 128 or 256 then we display the sectors and not the memory pointer
        //if hexOption >= 0x1000 then we display the memory address of the ROM bank (there is no lower address than 0x1000 for ROM)
        // then hexOption is formated like 0x10BK where BK is the rom bank number 0..$FF
        var hexdump = []; //(PVB) changed name !! from 'hex' to 'hexdump' - because not to confuse with the hex() function 
        var st; //(PVB ADD)
        //(PVB ADD)
        if (hexOption == 128 || hexOption == 256 ) { //sector_size : compute the sector & offset, then display both of them
            var dsector = 0, doffset = 0;
            for (var j = 0; j < len; j += 16) { // one line = 16 bytes
                st = Math.min(16, len - j);
                k = dsector;
                if ((i+j) < 384) {
                    dsector = Math.floor((i+j) / 128);
                    doffset = (i+j) - ((dsector) * 128);
                }
                else {
                    dsector = Math.floor(((i+j) - 384)/ hexOption) + 3;
                    doffset = ((i+j)- 384) - ((dsector - 3) * hexOption);
                }
                if (k != dsector)
                    hexdump.push(""); //(PVB COM) add an empty line between sectors
                //hexOption = a Sector Size, then display the sectors 
                hexdump.push(hex_line(j, a, i + j, st, hexOption, dsector + 1, doffset)); 
            }
        }
        //(PVB ADD)
        else if (hexOption >= 0x1000) { //the ROM Disassembly
            var bk = hexOption & 0xFF;//extract the bank number 0xff max
            hexOption &= 0xFF00; // clear the lowest byte of the bank number
            for (var j = 0; j < len; j += 16) { // one line = 16 bytes
                //hexOption = a Start Address, then display the real address
                hexdump.push((_bShowROMBank ? ("B" + hex(bk,2) + ":") : "") + hex_line(hexOption + j, a, i + j, Math.min(16, len - j), 4));
            }
        }   
        else {
            //(PVB end of ADD)
            for (var j = 0; j < len; j += 16) { // one line = 16 bytes
                //hexOption = a number of char, then display an index from Zero
                hexdump.push(hex_line(j, a, i + j, Math.min(16, len - j), hexOption)); //hexOption = number of char, 6 is considered if hexOption = 0
            }
        }
        return hexdump.join("\n");
    }

    //===================================================================================================

    var _fcanvas;
    function draw(ctx, s, x, y, fcanvas) {
        fcanvas = fcanvas || _fcanvas;
        for (var i = 0; i < s.length; i++) {
            var n = s.charCodeAt(i);
            ctx.drawImage(fcanvas, n * 8, 0, 8, 8, x * 8, y * 8, 8, 8);
            x++;
        }
    }

    // generate a canvas containing atari font
    function get_font(src, palette, one_bit) {
        // map atascii to a line of font bits
        // https://www.atariarchives.org/mapping/appendix10.php
        function font_bits(c, y) {
            var invert = c & 0x80 ? 0xFF : 0x00;
            c = c & 0x7F;
            if (c >= 32 && c < 96)
                c -= 32;
            else if (c < 32)
                c += 64;
            return src[c * 8 + y] ^ invert;
        }

        var canvas = document.createElement('canvas');
        canvas.width = 256 * 8;
        canvas.height = 8;
        var ctx = canvas.getContext('2d');

        var pix = ctx.getImageData(0, 0, 256 * 8, 8);
        var d = pix.data;
        var f = 0;
        var i = 0;
        var ap = (p) => {
            p = atari_palette_rgb[palette[p]];
            d[i + 0] = (p >> 16) & 0xFF;
            d[i + 1] = (p >> 8) & 0xFF;
            d[i + 2] = p & 0xFF;
            d[i + 3] = 0xFF;
            i += 4;
        }
        if (!palette) {
            palette = [128 + 20, 128 + 30];
            one_bit = true;
        }
        var bg = atari_palette_rgb[128 + 20];
        for (var y = 0; y < 8; y++) {
            for (var c = 0; c < 256; c++) {
                var b = font_bits(c, y);
                if (palette) {
                    if (one_bit) {
                        for (var x = 0; x < 8; x++) {
                            ap((b >> 7) & 1);
                            b <<= 1;
                        }
                    } else {
                        for (var x = 0; x < 4; x++) {
                            ap((b >> 6) & 3);
                            ap((b >> 6) & 3);
                            b <<= 2;
                        }
                    }
                } else {
                    /*
                    for (var x = 0; x < 8; x++) {
                        if (b & 0x80) {
                                d[i+0] = 128;
                                d[i+1] = 162;
                                d[i+2] = 255;
                            } else {
                                d[i+0] = (bg >> 16) & 0xFF;
                                d[i+1] = (bg >> 8) & 0xFF;
                                d[i+2] = (bg >> 0) & 0xFF;
                            }
                            d[i+3] = 0xFF;
                            i += 4;
                            b <<= 1;
                    }
                    */
                }
            }
        }
        ctx.putImageData(pix, 0, 0);
        return canvas;
    }

    //===================================================================================================

    class Octree {
        constructor(bits) {
            this.leaves = 0;
            this.count = 0;
            this.leaf_level = bits || 4;
        }

        insert(node, color, level) {
            var level;
            if (!node) {
                node = {
                    level: level,
                    n: 0,
                    red: 0,
                    green: 0,
                    blue: 0,
                }
                if (level < this.leaf_level)
                    node.child = [];
                else
                    this.leaves++;
            }
            node.n++;
            node.red += (color >> 16) & 0xFF;
            node.green += (color >> 8) & 0xFF;
            node.blue += color & 0xFF;
            if (node.child) {
                var k = this.key(color, level);
                node.child[k] = this.insert(node.child[k], color, level + 1);
            }
            return node;
        }

        key(color, level) {
            var k = 0;
            var m = 0x80 >> level;
            if ((color >> 16) & m) k |= 0x04;
            if ((color >> 8) & m) k |= 0x02;
            if (color & m) k |= 0x01;
            return k
        }

        color(node) {
            var r = node.red / node.n | 0;
            var g = node.green / node.n | 0;
            var b = node.blue / node.n | 0;
            return { n: node.n, color: ((r << 16) | (g << 8) | b) };
        }

        add(color) {
            this.root = this.insert(this.root, color, 0);
            this.count++;
        }

        scan(node, level, list) {
            if (node.level == level) {
                list.push(node);
                return;
            }
            if (node.child)
                node.child.forEach(c => this.scan(c, level, list));
        }

        finalize(count) {
            var pal;
            var level = 0;
            do {
                pal = [];
                this.scan(this.root, level++, pal);   // scan into levels until we get enough colors
            } while (pal.length < count);
            console.log(pal);
            pal.sort((a, b) => b.n - a.n);
            if (pal.length >= count)
                pal.length = count;
            return pal.map(node => this.color(node));
        }
    }

    function octree(pix, count, gray) {
        var d = pix.data;
        var q = new Octree();
        for (var i = 0; i < pix.width * pix.height * 4; i += 4) {
            var r = d[i];
            var g = d[i + 1];
            var b = d[i + 2];
            if (gray)
                r = g = b = (r * 0.29 + g * 0.59 + b * 0.12) | 0;
            q.add((r << 16) | (g << 8) | b, 0);
        }

        var pal = q.finalize(count);
        return pal.map(c => rgb2atari((c.color >> 16) & 0xFF, (c.color >> 8) & 0xFF, c.color & 0xFF));
    }

    //===================================================================================================
    //  Kmeans for palettes

    function median_cut(pix, centroid_count) {
        var sample_count = pix.width * pix.height;
        var d = pix.data;
        var index = new Uint32Array(sample_count);
        for (var i = 0; i < sample_count; i++)
            index[i] = i * 4;
        var slices = [index];

        function cut(s) {
            var rgb = [];
            for (var c = 0; c < 3; c++)
                rgb.push({ c: c, min: 255, max: 0, d: new Uint32Array(256) });
            for (var i = 0; i < s.length; i++) {
                for (var c = 0; c < 3; c++) {
                    var v = d[s[i] + c];
                    rgb[c].d[v]++;
                    rgb[c].min = Math.min(v, rgb[c].min);
                    rgb[c].max = Math.max(v, rgb[c].max);
                }
            }
            rgb.sort((a, b) => (b.max - b.min) - (a.max - a.min));
            var split = rgb[0];
            var c = split.c;
            var cut = (split.max + split.min) >> 1;
            console.log("Splitting " + ["red", "green", "blue"][c] + " at " + cut);
            console.log(rgb);

            var left = [];
            var right = [];
            for (var i = 0; i < s.length; i++) {
                if (d[s[i] + c] < cut)
                    left.push(s[i]);
                else
                    right.push(s[i]);
            }
            return [left, right];
        }

        while (slices.length < centroid_count) {
            slices.sort((a, b) => b.length - a.length);
            var split = cut(slices.shift());
            slices = slices.concat(split);
        }
        console.log(slices);
        var pal = [];
        slices.forEach(s => {
            var r = 0;
            var g = 0;
            var b = 0;
            s.forEach(i => {
                r += d[i];
                g += d[i + 1];
                b += d[i + 2];
            });
            pal.push(rgb2atari(r / s.length, g / s.length, b / s.length));
        });
        return pal;
    }

    //===================================================================================================
    //  Kmeans for palettes

    function kmeans(pix, centroid_count, gray) {
        console.log("kmeans " + centroid_count + (gray ? "(grayscale)" : ""));
        var sample_count = pix.width * pix.height;
        var samples = [];
        for (var i = 0; i < sample_count; i++)
            samples.push(rgb2yiq(pix.data[i * 4 + 0], pix.data[i * 4 + 1], pix.data[i * 4 + 2]));

        // kmeans++ centroid init
        _lfsr = 0xACE1;
        var rands = () => samples[lfsr() % sample_count];
        var centroids = [{ color: rands(), avg: { y: 0, i: 0, q: 0 }, err: 0, count: 0 }];
        while (centroids.length < centroid_count) {
            var maxe = 0;
            var new_centroid;
            for (var i = 0; i < 100; i++) {
                var s = rands();
                centroids.forEach(c => {
                    var e = yiq_distance(s, c.color);
                    if (e > maxe) {
                        maxe = e;
                        new_centroid = s;
                    }
                });
            }
            centroids.push({ color: new_centroid, avg: { y: 0, i: 0, q: 0 }, err: 0, count: 0 });
        }

        // match samples to centroids
        var last = 0;
        for (var pass = 0; pass < 16; pass++) {

            // match all the samples
            var total_err = 0;
            for (var i = 0; i < sample_count; i++) {
                var mine = 0x7FFFFFF;
                var index = -1;
                var color = samples[i];
                for (var j = 0; j < centroid_count; j++) {
                    var e = yiq_distance(color, centroids[j].color);
                    if (e < mine) {
                        mine = e;
                        index = j;
                    }
                }
                var c = centroids[index];
                c.avg.y += color.y;
                c.avg.i += color.i;
                c.avg.q += color.q;
                c.count++;
                c.err += mine;     // accumulate error
                total_err += mine;
            }

            // recalculate centroid color
            var errs = [];
            for (var i = 0; i < centroid_count; i++) {
                var c = centroids[i];
                if (gray)
                    c.avg.i = c.avg.q = 0;
                if (c.count)
                    c.color = { y: c.avg.y / c.count, i: c.avg.i / c.count, q: c.avg.q / c.count };
                errs.push({ index: i, err: c.err });
            }

            errs.sort((a, b) => b.err - a.err);
            console.log(errs);
            console.log(centroids);

            // split centroids if required
            for (var i = 0; i < centroid_count; i++) {
                if (centroids[i].count == 0) {                              // centroid is not being used
                    var c0 = centroids[errs[0].index].color;
                    var c1 = centroids[errs[1].index].color;                // make new centroid at average of two biggest errors
                    centroids[i].color = { y: (c0.y + c1.y) / 2, i: (c0.i + c1.i) / 2, q: (c0.q + c1.q) / 2 };
                }
                // reset centroids
                centroids[i].count = centroids[i].err = 0;
                centroids[i].avg = { y: 0, i: 0, q: 0 };
            }

            console.log("pass: " + pass + ":" + total_err);
            if (last && total_err >= last)
                break;
            last = total_err;
        }

        var pal = [];
        for (var i = 0; i < centroid_count; i++) {
            var c = centroids[i].color;
            pal.push(yiq2atari(c.y, c.i, c.q));
        }
        console.log(pal);
        return pal;
    }

    // 888 rgb to atari
    function to_atari(rgb) {
        var mine = 0x7FFFFFF;
        var mini = -1;
        for (var i = 0; i < 256; i++) {
            var a = atari_palette_rgb[i];
            var r = ((rgb >> 16) & 0xFF) - ((a >> 16) & 0xFF);
            var g = ((rgb >> 8) & 0xFF) - ((a >> 8) & 0xFF);
            var b = (rgb & 0xFF) - (a & 0xFF);
            var e = r * r + g * g + b * b;
            if (e < mine) {
                mine = e;
                mini = i;
            }
        }
        return mini;
    }

    //===================================================================================================
    // Images

    var atari_palette_rgb = [
        0x00000000, 0x000F0F0F, 0x001B1B1B, 0x00272727, 0x00333333, 0x00414141, 0x004F4F4F, 0x005E5E5E,
        0x00686868, 0x00787878, 0x00898989, 0x009A9A9A, 0x00ABABAB, 0x00BFBFBF, 0x00D3D3D3, 0x00EAEAEA,
        0x00001600, 0x000F2100, 0x001A2D00, 0x00273900, 0x00334500, 0x00405300, 0x004F6100, 0x005D7000,
        0x00687A00, 0x00778A17, 0x00899B29, 0x009AAC3B, 0x00ABBD4C, 0x00BED160, 0x00D2E574, 0x00E9FC8B,
        0x001C0000, 0x00271300, 0x00331F00, 0x003F2B00, 0x004B3700, 0x00594500, 0x00675300, 0x00756100,
        0x00806C12, 0x008F7C22, 0x00A18D34, 0x00B29E45, 0x00C3AF56, 0x00D6C36A, 0x00EAD77E, 0x00FFEE96,
        0x002F0000, 0x003A0000, 0x00460F00, 0x00521C00, 0x005E2800, 0x006C3600, 0x007A4416, 0x00885224,
        0x00925D2F, 0x00A26D3F, 0x00B37E50, 0x00C48F62, 0x00D6A073, 0x00E9B487, 0x00FDC89B, 0x00FFDFB2,
        0x00390000, 0x00440000, 0x0050000A, 0x005C0F17, 0x00681B23, 0x00752931, 0x0084373F, 0x0092464E,
        0x009C5058, 0x00AC6068, 0x00BD7179, 0x00CE838A, 0x00DF949C, 0x00F2A7AF, 0x00FFBBC3, 0x00FFD2DA,
        0x00370020, 0x0043002C, 0x004E0037, 0x005A0044, 0x00661350, 0x0074215D, 0x0082306C, 0x00903E7A,
        0x009B4984, 0x00AA5994, 0x00BC6AA5, 0x00CD7BB6, 0x00DE8CC7, 0x00F1A0DB, 0x00FFB4EF, 0x00FFCBFF,
        0x002B0047, 0x00360052, 0x0042005E, 0x004E006A, 0x005A1276, 0x00672083, 0x00762F92, 0x00843DA0,
        0x008E48AA, 0x009E58BA, 0x00AF69CB, 0x00C07ADC, 0x00D18CED, 0x00E59FFF, 0x00F9B3FF, 0x00FFCAFF,
        0x0016005F, 0x0021006A, 0x002D0076, 0x00390C82, 0x0045198D, 0x0053279B, 0x006135A9, 0x006F44B7,
        0x007A4EC2, 0x008A5ED1, 0x009B6FE2, 0x00AC81F3, 0x00BD92FF, 0x00D0A5FF, 0x00E4B9FF, 0x00FBD0FF,
        0x00000063, 0x0000006F, 0x00140C7A, 0x00201886, 0x002C2592, 0x003A329F, 0x004841AE, 0x00574FBC,
        0x00615AC6, 0x00716AD6, 0x00827BE7, 0x00948CF8, 0x00A59DFF, 0x00B8B1FF, 0x00CCC5FF, 0x00E3DCFF,
        0x00000054, 0x00000F5F, 0x00001B6A, 0x00002776, 0x00153382, 0x00234190, 0x0031509E, 0x00405EAC,
        0x004A68B6, 0x005A78C6, 0x006B89D7, 0x007D9BE8, 0x008EACF9, 0x00A1BFFF, 0x00B5D3FF, 0x00CCEAFF,
        0x00001332, 0x00001E3E, 0x00002A49, 0x00003655, 0x00004261, 0x0012506F, 0x00205E7D, 0x002F6D8B,
        0x00397796, 0x004987A6, 0x005B98B7, 0x006CA9C8, 0x007DBAD9, 0x0091CEEC, 0x00A5E2FF, 0x00BCF9FF,
        0x00001F00, 0x00002A12, 0x0000351E, 0x0000422A, 0x00004E36, 0x000B5B44, 0x00196A53, 0x00287861,
        0x0033826B, 0x0043927B, 0x0054A38C, 0x0065B49E, 0x0077C6AF, 0x008AD9C2, 0x009EEDD6, 0x00B5FFED,
        0x00002400, 0x00003000, 0x00003B00, 0x00004700, 0x0000530A, 0x00106118, 0x001E6F27, 0x002D7E35,
        0x00378840, 0x00479850, 0x0059A961, 0x006ABA72, 0x007BCB84, 0x008FDE97, 0x00A3F2AB, 0x00BAFFC2,
        0x00002300, 0x00002F00, 0x00003A00, 0x00004600, 0x00115200, 0x001F6000, 0x002E6E00, 0x003C7C12,
        0x0047871C, 0x0057972D, 0x0068A83E, 0x0079B94F, 0x008ACA61, 0x009EDD74, 0x00B2F189, 0x00C9FFA0,
        0x00001B00, 0x00002700, 0x000F3200, 0x001C3E00, 0x00284A00, 0x00365800, 0x00446600, 0x00527500,
        0x005D7F00, 0x006D8F19, 0x007EA02B, 0x008FB13D, 0x00A0C24E, 0x00B4D662, 0x00C8EA76, 0x00DFFF8D,
        0x00110E00, 0x001D1A00, 0x00292500, 0x00353100, 0x00413D00, 0x004F4B00, 0x005D5A00, 0x006B6800,
        0x0076720B, 0x0085821B, 0x0097932D, 0x00A8A43E, 0x00B9B650, 0x00CCC963, 0x00E0DD77, 0x00F7F48F,
    ];

    function rgb2yiq(r, g, b) {
        return {
            y: r * 0.299 + g * 0.587 + b * 0.114,
            i: r * 0.596 - g * 0.275 - b * 0.321,
            q: r * 0.212 - g * 0.523 + b * 0.311
        }
    }

    function rgb2atari(r, g, b) {
        var yiq = rgb2yiq(r, g, b);
        var angle = Math.atan2(yiq.i, yiq.q);
        var saturation = yiq.i * yiq.i + yiq.q * yiq.q;
        var offset = (180 - 26.8) * Math.PI / 180.0;
        var scale = 360 / 26.8;
        var cr = (offset - angle) * scale / (2 * Math.PI) | 0;
        cr %= 15;
        if (saturation < 1)
            cr = 0;
        else
            cr++;
        return (cr << 4) | (yiq.y / 16 | 0);
    }

    function atari2yiq(a) {
        var cr = a >> 4;
        var i = 0;
        var q = 0;
        if (cr) {
            var color_diff = 2 * Math.PI * 26.8 / 360;
            var angle = Math.PI * 303 / 180 + (cr - 1) * color_diff;
            i = Math.cos(angle) * 63;
            q = Math.sin(angle) * 63;
        }
        return { y: (a & 0xF) * 16, i: i, q: q };
    }

    function yiq2atari(y, i, q) {
        var angle = Math.atan2(i, q);
        var saturation = i * i + q * q;
        var offset = (180 - 26.8) * Math.PI / 180.0 - angle;
        if (offset < 0)
            offset += 2 * Math.PI;
        var scale = 360 / 26.8;
        var cr = offset * scale / (2 * Math.PI);
        cr = (cr + 0.5) | 0;
        if (saturation < 256)
            cr = 0;
        else
            cr = (cr + 1) & 0xF;
        cr = (cr << 4) | ((y / 16) | 0);
        console.log("y:" + y + " i:" + i + " q:" + q + " -> " + hex(cr) + " sat:" + saturation);
        return cr;
    }

    function yiq_distance(a, b) {
        var dy = a.y - b.y;
        var di = a.i - b.i;
        var dq = a.q - b.q;
        return dy * dy + di * di + dq * dq;
    }

    // 
    var _lfsr = 0xACE1;
    function lfsr() {
        _lfsr ^= _lfsr >> 7;
        _lfsr ^= _lfsr << 9;
        _lfsr ^= _lfsr >> 13;
        return _lfsr;
    }

    // mode 0 = Atkinson Dither
    // mode 1 = Floyd Steinberg
    // mode 2 = noise
    // mode 3 = ordered
    // mode 4 = No diffusion

    var _ordered8x8 = new Uint8Array([
        0, 32, 8, 40, 2, 34, 10, 42,
        48, 16, 56, 24, 50, 18, 58, 26,
        12, 44, 4, 36, 14, 46, 6, 38,
        60, 28, 52, 20, 62, 30, 54, 22,
        3, 35, 11, 43, 1, 33, 9, 41,
        51, 19, 59, 27, 49, 17, 57, 25,
        15, 47, 7, 39, 13, 45, 5, 37,
        63, 31, 55, 23, 61, 29, 53, 21
    ]);

    var _ordered16x16 = new Uint8Array([
        0, 192, 48, 240, 12, 204, 60, 252, 3, 195, 51, 243, 15, 207, 63, 255,
        128, 64, 176, 112, 140, 76, 188, 124, 131, 67, 179, 115, 143, 79, 191, 127,
        32, 224, 16, 208, 44, 236, 28, 220, 35, 227, 19, 211, 47, 239, 31, 223,
        160, 96, 144, 80, 172, 108, 156, 92, 163, 99, 147, 83, 175, 111, 159, 95,
        8, 200, 56, 248, 4, 196, 52, 244, 11, 203, 59, 251, 7, 199, 55, 247,
        136, 72, 184, 120, 132, 68, 180, 116, 139, 75, 187, 123, 135, 71, 183, 119,
        40, 232, 24, 216, 36, 228, 20, 212, 43, 235, 27, 219, 39, 231, 23, 215,
        168, 104, 152, 88, 164, 100, 148, 84, 171, 107, 155, 91, 167, 103, 151, 87,
        2, 194, 50, 242, 14, 206, 62, 254, 1, 193, 49, 241, 13, 205, 61, 253,
        130, 66, 178, 114, 142, 78, 190, 126, 129, 65, 177, 113, 141, 77, 189, 125,
        34, 226, 18, 210, 46, 238, 30, 222, 33, 225, 17, 209, 45, 237, 29, 221,
        162, 98, 146, 82, 174, 110, 158, 94, 161, 97, 145, 81, 173, 109, 157, 93,
        10, 202, 58, 250, 6, 198, 54, 246, 9, 201, 57, 249, 5, 197, 53, 245,
        138, 74, 186, 122, 134, 70, 182, 118, 137, 73, 185, 121, 133, 69, 181, 117,
        42, 234, 26, 218, 38, 230, 22, 214, 41, 233, 25, 217, 37, 229, 21, 213,
        170, 106, 154, 90, 166, 102, 150, 86, 169, 105, 153, 89, 165, 101, 149, 85
    ]);

    function dither_image(pix, pal, mode) {
        mode = mode || 0;
        var d = pix.data;
        var buf = new Uint8Array(3);
        var errs = new Int16Array(3);
        var dst = new Uint8Array(pix.width * pix.height);
        var distance = _radios["distance"].value;
        var dscale = pal.length == 2 ? 0.75 : 0.25;

        function get_index(src, p) {
            var mind = -1;
            var merr = 0xFFFFFF;

            if (distance == 0)  // RGB distnance measure
            {
                var r = src[p + 0];
                var g = src[p + 1];
                var b = src[p + 2];
                var e;
                for (var i = 0; i < pal.length; i++) {
                    var err = 0;
                    var c = atari_palette_rgb[pal[i]];
                    e = r - ((c >> 16) & 0xFF);
                    err += e * e;
                    e = g - ((c >> 8) & 0xFF);
                    err += e * e;
                    e = b - (c & 0xFF);
                    err += e * e;
                    if (err < merr) {
                        merr = err;
                        mind = i;
                    }
                }
            } else {
                var pyiq = rgb2yiq(src[p + 0], src[p + 1], src[p + 2]);  // yiq + y only
                var e;
                for (var i = 0; i < pal.length; i++) {
                    var err = 0;
                    var yiq = atari2yiq(pal[i]);
                    e = yiq.y - pyiq.y;
                    err += e * e * 2;
                    if (distance == 1) {        // include chroma
                        e = yiq.i - pyiq.i;
                        err += e * e;
                        e = yiq.q - pyiq.q;
                        err += e * e;
                    }
                    if (err < merr) {
                        merr = err;
                        mind = i;
                    }
                }
            }

            var c = atari_palette_rgb[pal[mind]];
            errs[0] = (src[p + 0] - ((c >> 16) & 0xFF));   // save error in RGB
            errs[1] = (src[p + 1] - ((c >> 8) & 0xFF));
            errs[2] = (src[p + 2] - ((c >> 0) & 0xFF));
            return pal[mind];    // closest index
        }

        function pin(n) {
            if (n < 0) return 0;
            if (n > 255) return 255;
            return n;
        }

        function rnd() {
            return ((lfsr() & 0xFF) - 128) * dscale;
        }

        function noisy(i) {
            buf[0] = pin(d[i + 0] + rnd());
            buf[1] = pin(d[i + 1] + rnd());
            buf[2] = pin(d[i + 2] + rnd());
        }

        function ordered(i, x, y) {
            var n = ((x & 0xF) << 4) | (y & 0xF);
            n = (_ordered16x16[n] - 128) * dscale;
            buf[0] = pin(d[i + 0] + n);
            buf[1] = pin(d[i + 1] + n);
            buf[2] = pin(d[i + 2] + n);
        }

        function add_err(x, y, scale) {
            scale = scale || 1 / 6;   // Atkinson
            if (x < 0 || x >= pix.width || y < 0 || y >= pix.height)
                return;
            var i = (x + y * pix.width) * 4;
            d[i + 0] = pin(d[i + 0] + errs[0] * scale);
            d[i + 1] = pin(d[i + 1] + errs[1] * scale);
            d[i + 2] = pin(d[i + 2] + errs[2] * scale);
        }

        var i = 0;
        var row = 0;
        for (var y = 0; y < pix.height; y++) {
            for (var x = 0; x < pix.width; x++) {
                switch (mode) {
                    case 0:
                        dst[i++] = get_index(d, row + x * 4);    // Atkinson
                        add_err(x + 1, y + 0);
                        add_err(x + 2, y + 0);
                        add_err(x - 1, y + 1);
                        add_err(x + 0, y + 1);
                        add_err(x + 1, y + 1);
                        add_err(x + 0, y + 2);
                        break;

                    case 1:
                        dst[i++] = get_index(d, row + x * 4);    // Floyd Steinberg
                        add_err(x + 1, y + 0, 7 / 16);
                        add_err(x - 1, y + 1, 3 / 16);
                        add_err(x + 0, y + 1, 5 / 16);
                        add_err(x + 1, y + 1, 1 / 16);
                        break;

                    case 2:
                        noisy(row + x * 4);
                        dst[i++] = get_index(buf, 0);
                        break;

                    case 3: // ordered
                        ordered(row + x * 4, x, y);
                        dst[i++] = get_index(buf, 0);
                        break;

                    case 4: // none
                        dst[i++] = get_index(d, row + x * 4);
                        break;
                }
            }
            row += pix.width * 4;
        }
        return dst;
    }

    function pack_img(indexes, pal, ext) {
        var dst = 0;
        var bpp = 2;
        switch (ext) {
            case 'gr8':
                bpp = 1;
                break;
            case 'gr9':
            case 'g10':
                bpp = 4;
                break;
        }
        var ppb = 8 / bpp;
        var pal_len = pal ? pal.length : 0;
        var d = new Uint8Array(indexes.length / ppb + pal_len);

        for (var i = 0; i < indexes.length;) {
            var b = 0;
            for (var j = 0; j < ppb; j++) {
                b <<= bpp;
                if (pal_len)
                    b |= pal.indexOf(indexes[i++]);
                else
                    b |= indexes[i++];
            }
            d[dst++] = b;
        }
        for (var i = 0; i < pal_len; i++)
            d[dst++] = pal[i];
        return d;
    }

    function raw_rgb(pix) {
        var n = pix.width * pix.height;
        var d = new Uint8Array(n * 3);
        if (1) {
            var pal = [];
            for (var i = 0; i < 256; i++)
                pal.push(i);
            var indexed = dither_image(pix, pal, 1);
            for (var i = 0; i < n; i++) {
                var c = atari_palette_rgb[indexed[i]];  // 
                d[i * 3 + 0] = (c >> 16) & 0xFF;
                d[i * 3 + 1] = (c >> 8) & 0xFF;
                d[i * 3 + 2] = c & 0xFF;
            }
        } else {
            for (var i = 0; i < n; i++) {
                d[i * 3 + 0] = pix.data[i * 4 + 0];
                d[i * 3 + 1] = pix.data[i * 4 + 1];
                d[i * 3 + 2] = pix.data[i * 4 + 2];
            }
        }
        return d;
    }

    // raw rgb
    function show_rgb(canvas, f) {
        canvas.width = f.data.length == (320 * 192 * 3) ? 320 : 160;
        canvas.height = 192;
        var ctx = canvas.getContext('2d');
        var pix = ctx.getImageData(0, 0, canvas.width, canvas.height);
        var d = pix.data;
        var s = f.data;
        var n = canvas.width * canvas.height;
        var p = {};
        for (var i = 0; i < n; i++) {
            var r = d[i * 4 + 0] = s[i * 3 + 0];
            var g = d[i * 4 + 1] = s[i * 3 + 1];
            var b = d[i * 4 + 2] = s[i * 3 + 2];
            d[i * 4 + 3] = 0xFF;
            p[(r << 16) | (g << 8) | b] = 1;
        }
        var pal = [];
        Object.keys(p).forEach(c => pal.push(rgb2atari((c >> 16) | 0xFF, (c >> 8) & 0xFF, c & 0xFF)));
        ctx.putImageData(pix, 0, 0);
        return { pal: pal, aspect: [320 / canvas.width * 2, 192 / canvas.height * 2] };
    }

    var _mono_cr = 0;
    function convert_image(canvas, f, pal, reload) {
        //if (f.name.indexOf(".rgb") != -1)
        //    return show_rgb(canvas,f);

        var dither = _radios["dither"].value;
        var scheme = _radios["scheme"].value;

        var width = 320;
        var height = 192;

        var img = f.img;
        var src_width = img.width;
        var src_height = img.height;
        var dst_width, dst_height;
        var ratio = img.width / img.height;
        if (ratio > width / height) {
            dst_width = width;
            dst_height = width / ratio;    // wide
        } else {
            dst_height = height;
            dst_width = height * ratio;    // tall
        }

        // 80,160 or 320 wide
        var pal_size = 0;
        switch (f.ext) {
            case "gr7":
                width /= 2;
                if (src_width == 160 && src_height == 192) {
                    // already native size
                } else {
                    dst_width /= 2;
                }
                pal_size = 4;
                break;
            case "gr8":
                pal_size = 2;
                break;
            case "gr9":
                pal = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];
            case "g10":
                width /= 4;
                if (src_width == 80 && src_height == 192) {
                    // already native size
                } else {
                    dst_width /= 4;
                }
                pal_size = f.ext == "g10" ? 9 : 0;
                break;
        }

        canvas.width = width;
        canvas.height = height;
        var ctx = canvas.getContext('2d');
        ctx.fillRect(0, 0, width, height);
        ctx.drawImage(f.img, 0, 0, img.width, src_height, (width - dst_width) / 2, (height - dst_height) / 2, dst_width, dst_height);

        var pix = ctx.getImageData(0, 0, width, height);
        //f.rgb = raw_rgb(pix);

        var mono = -1;
        if (reload && pal_size) {
            function monochrome(c) {
                for (var i = 0; i < pal_size; i++)  // make a grey palette, will apply chroma later
                    pal[i] = (i * 15 / (pal_size - 1)) | (_mono_cr << 4);
                mono = c;
            }
            switch (scheme) {
                case 0:
                    monochrome(0x00);   // grey
                    break;
                case 1:     // red-green
                    switch (pal_size) {
                        case 2: pal = [0x45, 0xE9]; break;
                        case 4: pal = [0x71, 0x45, 0xE9, 0x0D]; break; // Technicolor 100
                        case 9: pal = [0x71, 0x45, 0xE9, 0x47, 0xE7, 0x07, 0x49, 0xE5, 0x0D]; break; // Technicolor 100
                            break;
                    }
                    break;
                case 2:      // random
                    for (var i = 0; i < pal.length; i++)
                        pal[i] = lfsr() & 0xFF;
                    break;

                case 3: // kmeans
                    pal = kmeans(pix, pal_size);
                    break;

                case 4: // octree
                    pal = octree(pix, pal_size);
                    break;

                case 5:
                    pal = median_cut(pix, pal_size);
                    break;
            }
        }

        // dither to atari palette
        var indexed = dither_image(pix, pal, dither);

        // apply mono color if any
        if (mono != -1) {
            for (var i = 0; i < pal.length; i++)
                pal[i] |= mono;
            for (var i = 0; i < indexed.length; i++)
                indexed[i] |= mono;
        }

        // pack into the appropriate format
        f.packed_img = pack_img(indexed, pal_size ? pal : null, f.ext);

        // turn it back into RGB to display
        var rgb = Uint32Array.from(indexed).map(i => atari_palette_rgb[i]);
        rgb2canvas(canvas, rgb, width, height, 1);
        return { pal: pal, aspect: [320 / canvas.width * 2, 192 / canvas.height * 2] };
    }

    // atari index color to canvas
    // may stretch horizontally to maintain aspect ratio
    function rgb2canvas(canvas, atari, width, height, aspect, brightness) {
        brightness = brightness || 1;
        canvas.width = width * aspect;
        canvas.height = height;
        var ctx = canvas.getContext('2d');
        var pix = ctx.getImageData(0, 0, width * aspect, height);
        var d = pix.data;
        var src = 0;
        var i = 0;
        var pin = (p) => Math.min(0xFF, (p & 0xFF) * brightness);
        for (var y = 0; y < height; y++) {
            for (var x = 0; x < width; x++) {
                var c = atari[src++];
                for (var j = 0; j < aspect; j++) {
                    d[i + 0] = pin(c >> 16);
                    d[i + 1] = pin(c >> 8);
                    d[i + 2] = pin(c);
                    d[i + 3] = 0xFF;
                    i += 4;
                }
            }
        }
        ctx.putImageData(pix, 0, 0);
    }

    // convert a koala into a mic
    function koala(src) {
        var dst = new Uint8Array(7684);
        var dst_len = 7680;
        var i = src[4] + 1;
        var j = 0;
        var end = src.length;
        var type = src[7];

        if (type == 0) {
            while (i < end)
                dst[j++] = src[i++];  // no compression
        } else {
            while (i < end) {
                var b = src[i++];
                var len = b & 0x7F;
                if (len == 0) {
                    len = src[i++] << 8;
                    len |= src[i++];
                }
                b = (b & 0x80) ? -1 : src[i++];

                do {
                    dst[j] = b < 0 ? src[i++] : b;
                    if (j == (dst_len - 1))
                        break;
                    if (type == 2)
                        j++;
                    else {
                        j += 80;
                        if (j >= dst_len)
                            j -= (j < dst_len + 40) ? dst_len - 40 : dst_len + 39;
                    }
                } while (--len > 0);
            }
        }

        dst[7680] = src[17];
        dst[7681] = src[13];
        dst[7682] = src[14];
        dst[7683] = src[15];
        return dst;
    }

    // unpack from Piotr Fusik and Adrian Matoga

    function unpack_rip(data, data_len, unpacked_data, unpacked_len) {
        function create_fano_tree(src, offset, n, tree) {
            var i;
            var pos = 0;
            var positions = new Int32Array(16);
            for (i = 0; i < 16; i++)
                tree.count[i] = 0;
            for (i = 0; i < n; i++) {
                var bits = src[(i >> 1) + offset];
                bits = (i & 1) == 0 ? bits >> 4 : bits & 0xf;
                tree.count[bits]++;
            }
            for (i = 0; i < 16; i++) {
                positions[i] = pos;
                pos += tree.count[i];
            }
            for (i = 0; i < n; i++) {
                var bits = src[(i >> 1) + offset];
                bits = (i & 1) == 0 ? bits >> 4 : bits & 0xf;
                tree.values[positions[bits]++] = i & 0xFF;
            }
        }

        function get_bit(s) {
            var bits = s.bits;
            if (bits == 0x80) {
                if (s.offset >= s.length)
                    return -1;
                bits = s.bytes[s.offset++] * 2 + 1;
            }
            else
                bits <<= 1;
            s.bits = bits & 0xFF;
            return bits >> 8;
        }

        function get_code(s, tree) {
            var p = tree.count[0];
            var i = 0;
            var bits;
            for (bits = 1; bits < 16; bits++) {
                var n = tree.count[bits];
                var bit = get_bit(s);
                if (bit == -1)
                    return -1;
                i = i * 2 + bit;
                if (i < n)
                    return tree.values[p + i];
                p += n;
                i -= n;
            }
            return -1;
        }

        var length_tree = { count: new Int32Array(16), values: new Uint8Array(256) };
        var distance_tree = { count: new Int32Array(16), values: new Uint8Array(256) };
        var literal_tree = { count: new Int32Array(16), values: new Uint8Array(256) };
        var stream = { bits: 0x80, bytes: data, length: data_len, offset: 16 + 288 };
        var unpacked_offset;

        /* "PCK" header (16 bytes) */
        if (data_len < 304 || data[0] != 80 || data[1] != 67 || data[2] != 75)  // PCK
            return 0;

        /* 288 bytes Shannon-Fano bit lengths */
        create_fano_tree(data, 16, 64, length_tree);
        create_fano_tree(data, 16 + 32, 256, distance_tree);
        create_fano_tree(data, 16 + 32 + 128, 256, literal_tree);

        /* LZ77 */
        for (unpacked_offset = 0; unpacked_offset < unpacked_len;) {
            switch (get_bit(stream)) {
                case -1:
                    console.log(`rip truncation: got ${unpacked_offset} of ${unpacked_len}`);
                    return 0;
                case 0:
                    unpacked_data[unpacked_offset++] = get_code(stream, literal_tree);
                    break;
                case 1:
                    {
                        var distance = get_code(stream, distance_tree) + 2;
                        var len;
                        if (distance > unpacked_offset)
                            return 0;
                        len = get_code(stream, length_tree) + 2;
                        do {
                            unpacked_data[unpacked_offset] = unpacked_data[unpacked_offset - distance];
                            unpacked_offset++;
                        } while (--len > 0);
                        break;
                    }
            }
        }
        return 1;
    }

    function rip(d) {
        var mode = d[7];
        var hdr_len = d[11] + (d[12] << 8);
        var height = d[15];
        var txt_len = d[17];
        var pal_len = d[20 + txt_len];
        var dst;
        var txt = '';

        for (var i = 0; i < txt_len; i++)
            txt += String.fromCharCode(d[24 + i]);
        console.log(`rip mode:${mode}, rowbytes:${d[13]}, height:${d[15]} txt:${txt}`);

        if (d[9] == 0) {
            dst = d.slice(hdr_len, d.length);
        } else if (d[9] == 1) {
            var n = d[13];
            if (mode == 0x30)
                n += 4;  // 8 byte palette every 2nd line at end of image(s)
            n *= height;
            dst = new Uint8Array(n);
            var src = d.slice(hdr_len, d.length);
            if (!unpack_rip(src, src.length, dst, n))
                console.log("bad unpack_rip?");
        } else
            return null;

        // Copy palette
        var pal = new Uint8Array(pal_len);
        for (var i = 0; i < pal_len; i++)
            pal[i] = d[24 + txt_len + i];

        // separate mutlirip palette
        var multihip_pal = null;
        if (mode == 0x30) {
            var n = d[13] * height;
            multihip_pal = dst.slice(n, dst.length);
            dst = dst.slice(0, n);
        }
        // have the unpacked frame
        return {
            pal: pal,
            multihip_pal: multihip_pal,
            data: dst,
            ext: "rip_hip",
            mode: mode
        }
    }

    var _palette = [0, 5, 10, 15];
    var _reload_palette = 1;
    var _palettable = ["gr7", "gr8", "g10", "mic", "mcp", "inp", "cin", "pic", "scr"];
    function is_palettable(ext) {
        return _palettable.indexOf(ext) != -1;
    }

    function render_image(canvas, f) {
        var def_palette = [0, 5, 10, 15];
        switch (f.ext) {
            case "gr8": def_palette = [0, 15]; break;
            case "g10": def_palette = [0, 2, 4, 6, 8, 10, 12, 14, 15]; break;
        }
        var pal0 = _reload_palette ? def_palette.slice() : _palette.slice();
        var pal1 = _reload_palette ? def_palette.slice() : _palette.slice();
        var hip = [0, 0, 2, 4, 6, 8, 10, 12, 14, 0x20, 0x40, 0x60, 0x80, 0xA0, 0xC0, 0xE0];
        var multihip_pal = null;

        // We are rendering an image
        //  if (f.img || (f.name.indexOf(".rgb") != -1)) {
        if (f.img) {
            var r = convert_image(canvas, f, pal0, _reload_palette);
            if (_reload_palette) {
                _palette = r.pal.slice();
                redraw_palette();
            }
            return r.aspect;
        }

        var data = f.data;
        var ext = f.ext;
        var height = 192;
        var width = 160;
        var offset = 40;
        var offset2 = 40;
        var gr = 7;
        var src = 0;

        // Turn PIC into MIC
        if (ext == "pic") {
            data = koala(data);
            ext = "mic";
        }

        // Turn RIP into something
        if (ext == "rip") {
            var r = rip(data);
            data = r.data;
            ext = r.ext;
            hip = r.pal;

            switch (r.mode) {
                case 14: ext = "rip_mode_14"; break;
                case 16: ext = "rip_mode_16"; break;
                case 30:
                    ext = "inp";
                    for (var i = 0; i < 4; i++)
                        pal0[i] = pal1[i] = hip[4 + ((i - 1) & 3)];
                    break;
                case 48:
                    ext = "rip_multirip";
                    multihip_pal = r.multihip_pal;
                    break;
            }
        }

        function set_pal(p, offset, len) {
            if (_reload_palette) {
                pal0.length = len;
                pal1.length = len;
                for (var i = 0; i < len; i++)
                    pal0[i] = pal1[i] = p[offset++];
                _palette = pal0.slice();
                redraw_palette();
            }
        }

        function avg(p0, p1) {
            return ((atari_palette_rgb[p0] & 0x00FEFEFE) + (atari_palette_rgb[p1] & 0x00FEFEFE)) >> 1;
        }

        // Atari Graphics Works?
        if (ext == "scr" && data.length == 16000) {
            data = data.slice(0, 7684);
            ext = "gr7";
        }

        switch (data.length) {
            case 3844:
            case 7684:
            case 9604:
            case 16004: // Interpainter
                set_pal(data, data.length - 4, 4);
                break;

            case 7682:
                set_pal(data, data.length - 2, 2);
                break;

            case 7689:
                set_pal(data, data.length - 9, 9);
                break;
        }

        switch (ext) {
            case "mic":
            case "gr7":
                height = 96;
                if (data.length >= 7680)
                    height = 192;
                break;

            case "gr8":
                width = 320;
                gr = 8;
                if (data.length == 7680)
                    set_pal([0, 0xF], 0, 2);
                break;

            case "gr9":
                width = 80;
                gr = 9;
                break;

            case "g10":
                width = 80;
                gr = 10;
                break;

            case "ilc":
            case "pzm":
                width = 80;
                offset = 40 * 192;
                gr = 33;
                break;

            case "plm":
            case "apc":
                width = 80;
                height = 96;
                gr = 32;
                break;

            case "mcp":
                height = data.length == 16008 ? 200 : 100;
                for (var i = 0; i < 4; i++) {
                    pal0[i] = data[height * 80 + ((i - 1) & 3)];
                    pal1[i] = data[height * 80 + 4 + ((i - 1) & 3)];
                }
                offset = height * 40;
                gr = 39;
                break;

            case "inp":
                height = 200;
                offset = height * 40;
                gr = 37;
                break;

            // switch between Graphics 11 and Graphics 15
            // https://en.wikipedia-on-ipfs.org/wiki/Atari_8-bit_family_software-driven_graphics_modes.html
            case "cin":
                offset = 80 * height / 2;
                gr = 34;
                break;

            case "raw":
                src += 4;       // skip header 'XLPB'
                for (var i = 0; i < 4; i++) {
                    pal0[i] = data[0x3C04 + ((i - 1) & 3)];
                    pal1[i] = data[0x3C08 + ((i - 1) & 3)];
                }
                height = 192;
                gr = 37;
                break;

            case "ist":
                height = 200;
                src = 16;
                offset = 0x2000;
                gr = 35;
                break;

            case "hip":
                // 10 and 9 greyscale
                gr = 36;
                var hdr = le16(data, 0); // FFFF
                if (hdr == 0xFFFF && data.length != 16009) {    // Has header: Frames have explicit length
                    var len0 = le16(data, 4) - le16(data, 2) + 1;
                    var len1 = le16(data, 4 + len0 + 6) - le16(data, 2 + len0 + 6) + 1;
                    src += 6;
                    offset = len0 + 6;
                    height = len0 / 40;
                } else {
                    height = data.length / 80 | 0;
                    src = height * 40;
                    offset = -height * 40;
                    var p = height * 80;
                    if ((p + 9) == data.length) {   // has a palette?
                        for (var i = 0; i < 9; i++)
                            hip[i] = data[p++];
                    }
                }
                break;

            case "tip":
                width = data[5];
                height = data[6];
                var frame_len = data[7] | (data[8] << 8);
                // 3 frames: gr9 luma, gr10 luma, gr11 chroma
                src += 9;                   // gr9 luma
                offset = frame_len;         // gr10 luma
                offset2 = frame_len * 2;      // chroma
                gr = 38;
                break;

            case "rip_hip":
            case "rip_multirip":
                height = data.length / 80;
                offset = height * 40;
                gr = 36;
                break;

            case "rip_mode_14":
                height = 192;
                for (var i = 0; i < 4; i++) {
                    pal0[i] = pal1[i] = hip[4 + (i == 0 ? 4 : i - 1)] & 0xFE;
                    set_pal(pal0, 0, 4);
                }
                gr = 7;
                break;

            case "rip_mode_16":
                for (var i = 0; i < 4; i++) {
                    pal0[i] = hip[4 + i]; // TODO: why are they all dark?
                    pal1[i] = hip[0 + i] & 0xFE;
                }
                height = data.length / 80;
                offset = data.length / 2;
                gr = 37;    //
                break;
        }

        var buf = new Uint32Array(width * height);
        var dst = 0;
        var lastp = 0;
        var ap = atari_palette_rgb;
        for (var y = 0; y < height; y++) {
            var pal = (y & 1) ? pal1 : pal0;

            if (gr == 35) { // ist palette
                pal0[0] = pal1[0] = data[0x4000 + y];
                pal0[1] = pal1[1] = data[0x40C8 + y];
                pal0[2] = pal1[2] = data[0x4190 + y];
                pal0[3] = pal1[3] = data[0x4258 + y];
            }

            if (multihip_pal) {
                for (var i = 0; i < 16; i++) {
                    var gr10_to_reg = [0, 1, 2, 3, 4, 5, 6, 7, 8, 8, 8, 8, 4, 5, 6, 7];
                    hip[i] = i == 0 ? 0 : multihip_pal[gr10_to_reg[i] + ((y >> 1) << 3) - 1] & 0xFE;
                }
            }

            for (var x = 0; x < width;) {
                var b = data[src];
                switch (gr) {
                    case 7:
                        for (var j = 0; j < 4; j++) {
                            var bb = (b >> 6) & 3;
                            buf[dst++] = ap[pal[bb]];
                            b <<= 2;
                        }
                        x += 4;
                        break;

                    case 8:
                        for (var j = 0; j < 8; j++) {
                            var bb = (b >> 7) & 1;
                            buf[dst++] = ap[pal[bb]];
                            b <<= 1;
                        }
                        x += 8;
                        break;

                    case 9:
                        buf[dst++] = ap[b >> 4];        // 9=16 greys,10=index,11=chroma
                        buf[dst++] = ap[b & 0x0F];
                        x += 2;
                        break;

                    case 10:
                        buf[dst++] = ap[pal[b >> 4]];
                        buf[dst++] = ap[pal[b & 0x0F]];
                        x += 2;
                        break;

                    case 32:
                        var luma = data[src + offset];
                        buf[dst++] = ap[((luma >> 4) & 0x0F) | (b & 0xF0)];
                        buf[dst++] = ap[(luma & 0xF) | ((b & 0xF) << 4)];
                        x += 2;
                        break;

                    case 33:
                        var hue = data[src + offset];
                        buf[dst++] = ap[((b >> 4) & 0x0F) | (hue & 0xF0)];
                        buf[dst++] = ap[(b & 0xF) | ((hue & 0xF) << 4)];
                        x += 2;
                        break;

                    case 34: // Champions
                        var hue = data[src + offset];
                        buf[dst++] = ap[pal[b >> 6] | (hue & 0xF0)];
                        buf[dst++] = ap[pal[(b >> 4) & 3] | (hue & 0xF0)];
                        buf[dst++] = ap[pal[(b >> 2) & 3] | ((hue & 0xF) << 4)];
                        buf[dst++] = ap[pal[b & 3] | ((hue & 0xF) << 4)];
                        x += 4;
                        break;

                    case 36:  // hip
                        //  00001111
                        //  LL222233
                        var p2 = hip[b >> 4];         // gr10
                        var p3 = hip[b & 0xF];
                        b = data[src + offset];
                        var p0 = b >> 4;                // gr9
                        var p1 = b & 0xF;

                        buf[dst++] = avg(p0, lastp);
                        buf[dst++] = avg(p0, p2);
                        buf[dst++] = avg(p1, p2);
                        buf[dst++] = avg(p1, p3);
                        lastp = p3;
                        x += 4;
                        break;// hip

                    case 35: // ist
                    case 37: // rip_mode_16/inp
                        var b2 = data[src + offset];
                        var pal_0 = (y & 1) ? pal1 : pal0;
                        var pal_1 = (y & 1) ? pal0 : pal1;
                        for (var j = 0; j < 4; j++) {
                            var p0 = pal_1[(b2 >> 6) & 3];
                            var p1 = pal_0[(b >> 6) & 3];
                            buf[dst++] = avg(p0, p1);
                            b <<= 2;
                            b2 <<= 2;
                        }
                        x += 4;
                        break;

                    case 39: // mcp
                        var b2 = data[src + offset];
                        for (var j = 0; j < 4; j++) {
                            var p0 = pal0[(b >> 6) & 3];
                            var p1 = pal1[(b2 >> 6) & 3];
                            buf[dst++] = avg(p0, p1);
                            b <<= 2;
                            b2 <<= 2;
                        }
                        x += 4;
                        break;

                    case 38: // tip!
                        var luma = data[src];
                        var luma10 = data[src + offset];
                        var chroma = data[src + offset2];          // chroma

                        var l0 = ((luma >> 4) + lastp) >> 1;
                        var l1 = ((luma >> 4) + hip[luma10 >> 4]) >> 1;
                        var l2 = ((luma & 0xF) + hip[luma10 >> 4]) >> 1;
                        lastp = hip[luma10 & 0xF];
                        var l3 = ((luma & 0xF) + lastp) >> 1;

                        var c0 = chroma & 0xF0;
                        var c1 = (chroma << 4) & 0xF0;

                        buf[dst++] = ap[c0 | l0];
                        buf[dst++] = ap[c0 | l1];
                        buf[dst++] = ap[c1 | l2];        // 9=16 greys,10=index,11=chroma
                        buf[dst++] = ap[c1 | l3];
                        x += 4;
                        break;
                }
                src++;
            }
            if (gr == 32 && offset == 40)
                src += 40;
        }

        var brightness = 1;
        switch (ext) {
            case "rip_mode_16": brightness = 3; break;    // rip_mode_16,raw is dark, boost it please
            case "raw":
            case "mcp":
                brightness = 2;
                break;
        }
        rgb2canvas(canvas, buf, width, height, 320 / width, brightness);
        return [320 / canvas.width * 2, 192 / canvas.height * 2];
    }

    //===================================================================================================
    // UI
    //===================================================================================================

    // make an atari line of text to look like dir

    function set_class(el, cname, on) { //(PVB COM) el= nav#toc; cname= 'over'; on= 1
        if (on)
            el.classList.add(cname); //ajoute 'over' à la class nav#toc
        else
            el.classList.remove(cname);
    }

    function draw_line(id, txt, recovered, is_dir) {
        var c = _q(id);
        c.width = txt.length * 8;
        c.height = 8;
        var ctx = c.getContext('2d');
        draw(ctx, txt, 0, 0);
        resize_parent(c, 2);
        set_class(c, "recovered", recovered);
        set_class(c, "isdir", is_dir);
    }

    // Simple radio and check buttons
    var _radios = {};
    var _checks = {};
    function radio_init(name, values, value) {
        var cur = _radios[name] ? _radios[name].value : 0;
        value = value || cur;
        var s = '';
        for (var i = 0; i < values.length; i++)
            s += `<span onclick="radio_click('${name}',${i})" ${i == value ? "class='hilite'" : ""}>${values[i]}</span>`;
        _radios[name] = { values: values, value: value };
        return s;
    }

    function radio_click(name, n) {
        var v = _radios[name];
        if (n != -1 && n != v.value) {
            v.value = n;
            radio_changed(name, n);
        }
    }

    function radio_changed(name, v) {
        switch (name) {
            case "layout":
            case "dither":
            case "scheme":
            case "distance":
                refresh();
                break;
        }
    }

    function check_init(name, dname) {
        _checks[name] = _checks[name] || 0;
        var cur = _checks[name] ? _checks[name] : 0;
        return `<span onclick="check_click('${name}')" ${cur ? "class='hilite'" : ""}>${dname}</span>`;
    }

    function check_click(name, n) {
        _checks[name] ^= 1;
        check_changed(name, _checks[name]);
    }

    function check_changed(name, v) {
        switch (name) {
            case "indent":
            case "multicolor":
                refresh();
                break;
        }
    }

    function resize_parent(e, sx, sy) {
        sy = sy || sx;
        e.style.transform = `scale(${sx},${sy})`;
        e.parentNode.style.width = e.width * sx + "px";
        e.parentNode.style.height = e.height * sy + "px";
    }

    // U+200B ZERO-WIDTH SPACE after ':',',''
    function atari2ascii(lst, insert_breaks) {
        var r = [];
        var wbr = insert_breaks ? String.fromCharCode(0x200B) : null;   // ZERO-WIDTH SPACE
        lst.forEach(src => {
            var dst = '';
            for (var i = 0; i < src.length; i++) {
                var c = src.charCodeAt(i);
                switch (c) {
                    case 0x7B: // { in ascii, spade in atari
                    case 0x7D: // } in ascii, upleft in atari
                    case 0x7E: // ~ in ascii, left triangle in atari
                    case 0x7F: // right triangle in atari
                        c += 0xE000;
                        break;
                    default:
                        if (c < 0x20 || c > 0x7E)   // keep printing chars whole
                            c += 0xE000;
                }
                c = String.fromCharCode(c);
                dst += c;
                if (wbr && (c == ':' || c == ','))
                    dst += wbr;
            }
            r.push(dst);
        })
        return r;
    }

    function ascii2atari(lst) {
        var d = [];
        lst.forEach(src => {
            for (var i = 0; i < src.length; i++) {
                c = src.charCodeAt(i);
                if (c != 0x200B)
                    d.push(c & 0xFF);
            }
            d.push(0x9B);
        });
        return new Uint8Array(d);
    }

    function editor() {
        return _q("#atari_text");
    }

    function get_ataritext() {
        return ascii2atari(editor().innerText.split("\n"));
    }

    var _gs = window.getSelection || document.getSelection;
    function get_selection() {
        return _gs().toString();
    }

    function invert_selection() {
        keyboard(get_selection(), true);
    }
    //(PVB COM) disassemble_selection() is used only to disassemble the Atari text selection in the displayed Atari text area
    //(PVB TODO) improve this feature with several line selection ??
    function disassemble_selection() { 
        var txt = get_selection();
        if (!txt || !txt.length) //(PVB COM) No text is selected so exit
            return;

        var asm = [];
        for (var i = 0; i < txt.length; i++)
            asm.push(txt.charCodeAt(i) & 0xFF); //(PVB COM) Convert Atari selected text to byte numbers
        var dis = _q(".disassembly"); //creation of a new window with "disassembly" class
        draggable(dis, _shown.name + " disassembly"); //_shown.name = file name (DOS or disk) displayed
        _h("#disassembly", xex_dump("asm", asm, 0, asm.length, "SEL"));

        var r = _gs().getRangeAt(0).getBoundingClientRect(); //(PVB COM) "r" is a DOMRect
        var dx = (dis.width - r.width) / 2;
        dis.style.left = ((dx | 0) + r.left) + "px";
        dis.style.top = r.bottom + 4 + "px";
        dis.hidden = false;
        editor().focus();
    }

    function selection_change() { //(PVB COM) Function used to monitor where is the mouse pointer and if text is selected
        var el = document.activeElement;
        if (el.id == "atari_text") {
            var txt = get_selection();
            var sel = txt && txt.length;
            set_tool("I", sel);  // we have a selection
            set_tool("D", sel);
        }
    }

    function keyboard(txt, invert) {
        var e = editor();
        if (!e)
            return;

        if (!txt) {
            e.focus();
            return;
        }

        // same in ATASCII as ASCII
        // will cause unescaping of <>& etc
        function common_chars(s) {
            var dst = '';
            for (var i = 0; i < s.length; i++) {
                var c = s.charCodeAt(i);
                if ((c & 0xFF) >= 0x20 && ((c & 0xFF) < 0x7B))
                    c &= 0xFF;
                dst += String.fromCharCode(c);
            }
            return dst;
        }

        if (invert) {
            txt = get_selection();
            var s = '';
            for (var i = 0; i < txt.length; i++) {
                var c = txt.charCodeAt(i);
                c = ((c < 0x20) || (c == 0x200B)) ? c : (c ^ 0x80) | 0xE000;
                s += String.fromCharCode(c);
            }
            txt = s;
        }
        txt = common_chars(txt);

        var range = _gs().getRangeAt(0);
        if (invert)
            range.deleteContents();
        else
            range.collapse();

        // insert
        if (txt.indexOf('\n') != -1) {  // need to deal with newlines and insert the as breaks
            var lst = txt.split('\n');
            var n = [];
            for (var i = 0; i < lst.length; i++) {
                n.push(document.createTextNode(lst[i]));
                if (i != lst.length - 1)
                    n.push(document.createElement("br"));
            }
            var i = n.length;
            while (i--)
                range.insertNode(n[i]);
            range.setEndAfter(n[n.length - 1]);
        } else
            range.insertNode(document.createTextNode(txt));
        e.focus();
    }

    function show_ataritext(f, lst) {
        render_file(f);
        var layout = _radios["layout"].value;
        var cols = layout < 2 ? 40 : 80;
        if (layout == 3)
            lst.forEach(s => cols = Math.max(cols, s.length));
        lst = atari2ascii(lst, f.ext == "bas");

        var ta = editor();
        if (layout == 0) {
            ta.style.paddingLeft = '32px';
            cols -= 2;
        }
        else
            ta.style.paddingLeft = '0px';
        if (layout == 3)
            ta.style.fontSize = ta.style.lineHeight = '8px';
        else {
            ta.style.fontSize = ta.style.lineHeight = '16px';
            ta.style.minWidth = ta.style.maxWidth = (cols * 16) + "px";
        }
        ta.innerText = lst.join('\n');
    }

    // old fashioned font
    function show_font(f, lst, font, palette) {
        render_file(f);

        var fcanvas;
        if (font)
            fcanvas = get_font(font, palette);

        var layout = _radios["layout"].value;
        var cols = layout < 2 ? 40 : 80;
        var margin = layout == 0 ? 2 : 0;
        var wrap = [];

        if (layout == 3) {  // Don't wrap at all
            lst.forEach(line => cols = Math.max(line.length, cols));
            cols += 2 * margin;
            wrap = lst;
        } else {
            var wrap = [];
            lst.forEach(s => {
                while (s.length > (cols - margin)) {
                    wrap.push(s.substr(0, (cols - margin)));
                    s = s.substr((cols - margin));
                }
                wrap.push(s);
            });
        }

        var c = _q("#show");
        c.width = cols * 8;
        c.height = wrap.length * 8 + 16;
        var ctx = c.getContext('2d');
        ctx.webkitImageSmoothingEnabled = false;
        var bg = atari_palette_rgb[palette ? palette[0] : 128 + 20];
        ctx.fillStyle = '#' + hex(bg, 6); // "rgba(17,59,128,1)";
        ctx.fillRect(0, 0, c.width, c.height);
        for (var y = 0; y < wrap.length; y++)
            draw(ctx, wrap[y], margin, y + 1, fcanvas);
        resize_parent(c, layout == 3 ? 1 : 2);
    }

    var _font = [ //as stored in ROM memory of 800/XL/XE ROM like in $E000-E3FF 
        // atari 128 rom font 
        // 32..95
        // 0..31
        // 96..128
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x00,
        0x00, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x66, 0xff, 0x66, 0x66, 0xff, 0x66, 0x00,
        0x18, 0x3e, 0x60, 0x3c, 0x06, 0x7c, 0x18, 0x00,
        0x00, 0x66, 0x6c, 0x18, 0x30, 0x66, 0x46, 0x00,
        0x1c, 0x36, 0x1c, 0x38, 0x6f, 0x66, 0x3b, 0x00,
        0x00, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x0e, 0x1c, 0x18, 0x18, 0x1c, 0x0e, 0x00,
        0x00, 0x70, 0x38, 0x18, 0x18, 0x38, 0x70, 0x00,
        0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00,
        0x00, 0x18, 0x18, 0x7e, 0x18, 0x18, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30,
        0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00,
        0x00, 0x06, 0x0c, 0x18, 0x30, 0x60, 0x40, 0x00,
        0x00, 0x3c, 0x66, 0x6e, 0x76, 0x66, 0x3c, 0x00,
        0x00, 0x18, 0x38, 0x18, 0x18, 0x18, 0x7e, 0x00,
        0x00, 0x3c, 0x66, 0x0c, 0x18, 0x30, 0x7e, 0x00,
        0x00, 0x7e, 0x0c, 0x18, 0x0c, 0x66, 0x3c, 0x00,
        0x00, 0x0c, 0x1c, 0x3c, 0x6c, 0x7e, 0x0c, 0x00,
        0x00, 0x7e, 0x60, 0x7c, 0x06, 0x66, 0x3c, 0x00,
        0x00, 0x3c, 0x60, 0x7c, 0x66, 0x66, 0x3c, 0x00,
        0x00, 0x7e, 0x06, 0x0c, 0x18, 0x30, 0x30, 0x00,
        0x00, 0x3c, 0x66, 0x3c, 0x66, 0x66, 0x3c, 0x00,
        0x00, 0x3c, 0x66, 0x3e, 0x06, 0x0c, 0x38, 0x00,
        0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00,
        0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x30,
        0x06, 0x0c, 0x18, 0x30, 0x18, 0x0c, 0x06, 0x00,
        0x00, 0x00, 0x7e, 0x00, 0x00, 0x7e, 0x00, 0x00,
        0x60, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x60, 0x00,
        0x00, 0x3c, 0x66, 0x0c, 0x18, 0x00, 0x18, 0x00,
        0x00, 0x3c, 0x66, 0x6e, 0x6e, 0x60, 0x3e, 0x00,
        0x00, 0x18, 0x3c, 0x66, 0x66, 0x7e, 0x66, 0x00,
        0x00, 0x7c, 0x66, 0x7c, 0x66, 0x66, 0x7c, 0x00,
        0x00, 0x3c, 0x66, 0x60, 0x60, 0x66, 0x3c, 0x00,
        0x00, 0x78, 0x6c, 0x66, 0x66, 0x6c, 0x78, 0x00,
        0x00, 0x7e, 0x60, 0x7c, 0x60, 0x60, 0x7e, 0x00,
        0x00, 0x7e, 0x60, 0x7c, 0x60, 0x60, 0x60, 0x00,
        0x00, 0x3e, 0x60, 0x60, 0x6e, 0x66, 0x3e, 0x00,
        0x00, 0x66, 0x66, 0x7e, 0x66, 0x66, 0x66, 0x00,
        0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x7e, 0x00,
        0x00, 0x06, 0x06, 0x06, 0x06, 0x66, 0x3c, 0x00,
        0x00, 0x66, 0x6c, 0x78, 0x78, 0x6c, 0x66, 0x00,
        0x00, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7e, 0x00,
        0x00, 0x63, 0x77, 0x7f, 0x6b, 0x63, 0x63, 0x00,
        0x00, 0x66, 0x76, 0x7e, 0x7e, 0x6e, 0x66, 0x00,
        0x00, 0x3c, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x00,
        0x00, 0x7c, 0x66, 0x66, 0x7c, 0x60, 0x60, 0x00,
        0x00, 0x3c, 0x66, 0x66, 0x66, 0x6c, 0x36, 0x00,
        0x00, 0x7c, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0x00,
        0x00, 0x3c, 0x60, 0x3c, 0x06, 0x06, 0x3c, 0x00,
        0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00,
        0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7e, 0x00,
        0x00, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x00,
        0x00, 0x63, 0x63, 0x6b, 0x7f, 0x77, 0x63, 0x00,
        0x00, 0x66, 0x66, 0x3c, 0x3c, 0x66, 0x66, 0x00,
        0x00, 0x66, 0x66, 0x3c, 0x18, 0x18, 0x18, 0x00,
        0x00, 0x7e, 0x0c, 0x18, 0x30, 0x60, 0x7e, 0x00,
        0x00, 0x1e, 0x18, 0x18, 0x18, 0x18, 0x1e, 0x00,
        0x00, 0x40, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x00,
        0x00, 0x78, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00,
        0x00, 0x08, 0x1c, 0x36, 0x63, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00,
        0x00, 0x36, 0x7f, 0x7f, 0x3e, 0x1c, 0x08, 0x00,
        0x18, 0x18, 0x18, 0x1f, 0x1f, 0x18, 0x18, 0x18,
        0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
        0x18, 0x18, 0x18, 0xf8, 0xf8, 0x00, 0x00, 0x00,
        0x18, 0x18, 0x18, 0xf8, 0xf8, 0x18, 0x18, 0x18,
        0x00, 0x00, 0x00, 0xf8, 0xf8, 0x18, 0x18, 0x18,
        0x03, 0x07, 0x0e, 0x1c, 0x38, 0x70, 0xe0, 0xc0,
        0xc0, 0xe0, 0x70, 0x38, 0x1c, 0x0e, 0x07, 0x03,
        0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x0f, 0x0f, 0x0f, 0x0f,
        0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xff,
        0x0f, 0x0f, 0x0f, 0x0f, 0x00, 0x00, 0x00, 0x00,
        0xf0, 0xf0, 0xf0, 0xf0, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0xf0, 0xf0, 0xf0, 0xf0,
        0x00, 0x1c, 0x1c, 0x77, 0x77, 0x08, 0x1c, 0x00,
        0x00, 0x00, 0x00, 0x1f, 0x1f, 0x18, 0x18, 0x18,
        0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00,
        0x18, 0x18, 0x18, 0xff, 0xff, 0x18, 0x18, 0x18,
        0x00, 0x00, 0x3c, 0x7e, 0x7e, 0x7e, 0x3c, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0,
        0x00, 0x00, 0x00, 0xff, 0xff, 0x18, 0x18, 0x18,
        0x18, 0x18, 0x18, 0xff, 0xff, 0x00, 0x00, 0x00,
        0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
        0x18, 0x18, 0x18, 0x1f, 0x1f, 0x00, 0x00, 0x00,
        0x78, 0x60, 0x78, 0x60, 0x7e, 0x18, 0x1e, 0x00,
        0x00, 0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x00,
        0x00, 0x18, 0x18, 0x18, 0x7e, 0x3c, 0x18, 0x00,
        0x00, 0x18, 0x30, 0x7e, 0x30, 0x18, 0x00, 0x00,
        0x00, 0x18, 0x0c, 0x7e, 0x0c, 0x18, 0x00, 0x00,
        0x00, 0x18, 0x3c, 0x7e, 0x7e, 0x3c, 0x18, 0x00,
        0x00, 0x00, 0x3c, 0x06, 0x3e, 0x66, 0x3e, 0x00,
        0x00, 0x60, 0x60, 0x7c, 0x66, 0x66, 0x7c, 0x00,
        0x00, 0x00, 0x3c, 0x60, 0x60, 0x60, 0x3c, 0x00,
        0x00, 0x06, 0x06, 0x3e, 0x66, 0x66, 0x3e, 0x00,
        0x00, 0x00, 0x3c, 0x66, 0x7e, 0x60, 0x3c, 0x00,
        0x00, 0x0e, 0x18, 0x3e, 0x18, 0x18, 0x18, 0x00,
        0x00, 0x00, 0x3e, 0x66, 0x66, 0x3e, 0x06, 0x7c,
        0x00, 0x60, 0x60, 0x7c, 0x66, 0x66, 0x66, 0x00,
        0x00, 0x18, 0x00, 0x38, 0x18, 0x18, 0x3c, 0x00,
        0x00, 0x06, 0x00, 0x06, 0x06, 0x06, 0x06, 0x3c,
        0x00, 0x60, 0x60, 0x6c, 0x78, 0x6c, 0x66, 0x00,
        0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00,
        0x00, 0x00, 0x66, 0x7f, 0x7f, 0x6b, 0x63, 0x00,
        0x00, 0x00, 0x7c, 0x66, 0x66, 0x66, 0x66, 0x00,
        0x00, 0x00, 0x3c, 0x66, 0x66, 0x66, 0x3c, 0x00,
        0x00, 0x00, 0x7c, 0x66, 0x66, 0x7c, 0x60, 0x60,
        0x00, 0x00, 0x3e, 0x66, 0x66, 0x3e, 0x06, 0x06,
        0x00, 0x00, 0x7c, 0x66, 0x60, 0x60, 0x60, 0x00,
        0x00, 0x00, 0x3e, 0x60, 0x3c, 0x06, 0x7c, 0x00,
        0x00, 0x18, 0x7e, 0x18, 0x18, 0x18, 0x0e, 0x00,
        0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3e, 0x00,
        0x00, 0x00, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x00,
        0x00, 0x00, 0x63, 0x6b, 0x7f, 0x3e, 0x36, 0x00,
        0x00, 0x00, 0x66, 0x3c, 0x18, 0x3c, 0x66, 0x00,
        0x00, 0x00, 0x66, 0x66, 0x66, 0x3e, 0x0c, 0x78,
        0x00, 0x00, 0x7e, 0x0c, 0x18, 0x30, 0x7e, 0x00,
        0x00, 0x18, 0x3c, 0x7e, 0x7e, 0x18, 0x3c, 0x00,
        0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
        0x00, 0x7e, 0x78, 0x7c, 0x6e, 0x66, 0x06, 0x00,
        0x08, 0x18, 0x38, 0x78, 0x38, 0x18, 0x08, 0x00,
        0x10, 0x18, 0x1c, 0x1e, 0x1c, 0x18, 0x10, 0x00,
    ];

    function makefont() {  //(PVB COM) (PVB TODO) function empty and not used... should be a futur to do stuff

    }


    //===================================================================================================
    //  Drag and drop

    function drop_init(el, onfile, all_done) {
        
        function over(b) {
            set_class(_q("#toc"), "over", b); //(PVB COM) used to add "over" to the "nav#toc" class
        }

        function handleFiles(files) {

            function readAsArrayBuffer(file) {
                return new Promise((resolve, reject) => {
                    const fr = new FileReader();
                    fr.onerror = reject;
                    fr.onload = function (evt) {
                        onfile(file, evt.target.result);
                        resolve(fr.result);
                    }
                    fr.readAsArrayBuffer(file);
                });
            }

            // Load all the files, callback when done
            Promise.all(Array.prototype.map.call(files, readAsArrayBuffer))
                .then(urls => {
                    all_done();
                })
                .catch(error => {
                    console.log(error);
                });
        }

        function handleFileSelect(evt) {
            evt.stopPropagation();
            evt.preventDefault();
            over(0);
            handleFiles(evt.dataTransfer.files);

            // check for dragged urls of images
            var items = evt.dataTransfer.items;
            for (var i = 0; i < items.length; i++) {
                if (items[i].kind == 'string' && items[i].type == 'text/uri-list') {
                    items[i].getAsString(s => console.log(s));  // cross origin will make this useless
                }
            }
        }

        function handleDragOver(evt) {
            evt.stopPropagation();
            evt.preventDefault();
            evt.dataTransfer.dropEffect = 'copy'; // Explicitly show this is a copy.
        }
        //(PVB COM) drop_ini starts here
        el.addEventListener('dragover', handleDragOver, false);
        el.addEventListener('drop', handleFileSelect, false);
        el.addEventListener('dragenter', e => over(1), false); //(PVB) 'e' is a DragEvent
        el.addEventListener('dragleave', e => over(0), false); //(PVB) 'e' is a DragEvent

        _q("#fe").addEventListener("change", e => handleFiles(_q("#fe").files), false);

    }

    //===================================================================================================
    // http://www.atarimax.com/jindroush.atari.org/afmtbas.html
    // Disassemble m65

    var _mac65_table1 = [
        "ERROR -", ".IF", ".ELSE", ".ENDIF", ".MACRO", ".ENDM", ".TITLE", "",
        ".PAGE", ".WORD", ".ERROR", ".BYTE", ".SBYTE", ".DBYTE", ".END", ".OPT",
        ".TAB", ".INCLUDE", ".DS", ".ORG", ".EQU", "BRA", "TRB", "TSB",
        ".FLOAT", ".CBYTE", ";", ".LOCAL", ".SET", "*=", "=", ".=",
        "JSR", "JMP", "DEC", "INC", "LDX", "LDY", "STX", "STY",
        "CPX", "CPY", "BIT", "BRK", "CLC", "CLD", "CLI", "CLV",
        "DEX", "DEY", "INX", "INY", "NOP", "PHA", "PHP", "PLA",
        "PLP", "RTI", "RTS", "SEC", "SED", "SEI", "TAX", "TAY",
        "TSX", "TXA", "TXS", "TYA", "BCC", "BCS", "BEQ", "BMI",
        "BNE", "BPL", "BVC", "BVS", "ORA", "AND", "EOR", "ADC",
        "STA", "LDA", "CMP", "SBC", "ASL", "ROL", "LSR", "ROR",
        "", "STZ", "DEA", "INA", "PHX", "PHY", "PLX", "PLY",
    ];

    var _mac65_table2 = [
        null, null, null, null, null, "", "", "",
        "", null, "", "%$", "%", "*", null, null,
        null, null, "+", "-", "*", "/", "&", null,
        "=", "<=", ">=", "<>", ">", "<", "-", "[",
        "]", null, null, null, "!", "^", null, "\\",
        null, null, null, null, null, null, null, ".REF",
        ".DEF", ".NOT", ".AND", ".OR", "<", ">", ",X)", "),Y",
        ",Y", ",X", ")", "", null, ",", "#", "A",
        "(", '"', null, null, null, "NO", "OBJ", "ERR",
        "EJECT", "LIST", "XREF", "MLIST", "CLIST", "NUM", null, null,
    ];

    function mac65(a, i, len) {
        if (le16(a, i) != 0xFEFE)
            return null;
        if (le16(a, i + 2) != (len - 4))
            return null;
        var end = i + len;
        i += 4;

        var indent = 5;
        var asm = [];
        while (i < len) {
            var line_number = le16(a, i);
            var line_end = i + a[i + 2];
            i += 3;

            var s = line_number + ' ';
            var pad = ('' + line_number).length + indent;
            var c = a[i++];
            if (c & 0x80) {
                c -= 0x80;  // label
                while (c--)
                    s += String.fromCharCode(a[i++]);
                if (i == line_end) {
                    asm.push(s);
                    continue;
                }
                c = a[i++];
            } else if (c == 0 || c == 88) {
                while (i < line_end)
                    s += String.fromCharCode(a[i++]);   // raw
                asm.push(s);
                continue;
            } else if (c == 1) {
                indent++;           // IF
            } else if (c == 3) {
                indent--;           // ENDIF
            }

            if (c >= 96)
                return null;
            while (s.length < pad)
                s += ' ';
            if (s[s.length - 1] != ' ')
                s += ' ';
            s += _mac65_table1[c] + ' ';   // token

            while (i < line_end) {
                c = a[i++];
                switch (c) {
                    case 5: s += '$' + hex(le16(a, i), 4); i += 2; break;
                    case 6: s += '$' + hex(a[i++]); break;
                    case 7: s += le16(a, i); i += 2; break;
                    case 8: s += a[i++]; break;
                    case 10: s += "'" + String.fromCharCode(a[i++]); break;
                    case 59:
                        s += ' ';
                        while (i < line_end)
                            s += String.fromCharCode(a[i++]);   // comment
                        break;
                    default:
                        if (c & 0x80) {
                            c -= 0x80;
                            while (c--)
                                s += String.fromCharCode(a[i++]);
                        } else {
                            var t = _mac65_table2[c];
                            if (!t)
                                return null;
                            s += t;
                            if (c > 64)
                                s += ' ';   // not sure all of all the padding rules
                        }
                        break;
                }
            }
            asm.push(s);
        }
        return asm;
    }

    //===================================================================================================
    // http://www.atarimax.com/jindroush.atari.org/afmtbas.html
    // Disassemble atari basic

    var _basic_commands = [
        // 56 in classic Basic
        "REM", "DATA", "INPUT", "COLOR", "LIST", "ENTER", "LET", "IF", "FOR", "NEXT", "GOTO",
        "GO TO", "GOSUB", "TRAP", "BYE", "CONT", "COM", "CLOSE", "CLR", "DEG", "DIM", "END",
        "NEW", "OPEN", "LOAD", "SAVE", "STATUS", "NOTE", "POINT", "XIO", "ON", "POKE", "PRINT",
        "RAD", "READ", "RESTORE", "RETURN", "RUN", "STOP", "POP", "?", "GET", "PUT", "GRAPHICS",
        "PLOT", "POSITION", "DOS", "DRAWTO", "SETCOLOR", "LOCATE", "SOUND", "LPRINT", "CSAVE",
        "CLOAD", "LET_", "ERROR",

        // Turbo Basic
        "DPOKE ", "MOVE ", "-MOVE ", "*F", "REPEAT ", "UNTIL ", "WHILE ", "WEND ",
        "ELSE ", "ENDIF ", "BPUT ", "BGET ", "FILLTO ", "DO ", "LOOP ", "EXIT ",
        "DIR ", "LOCK ", "UNLOCK ", "RENAME ", "DELETE ", "PAUSE ", "TIME$= ", "PROC ",
        "EXEC ", "ENDPROC ", "FCOLOR ", "*L ",
        "------------------------------",
        "RENUM ", "DEL ", "DUMP ",
        "TRACE ", "TEXT ", "BLOAD ", "BRUN ", "GO# ", "# ", "*B ", "PAINT ",
        "CLS ", "DSOUND ", "CIRCLE ", "%PUT ", "%GET "
    ];

    var _basic_operators = [
        "_0", "_1", "_2", "_3", "_4", "_5", "_6", "_7", "_8", "_9", "_A", "_B", "_C", "_D",
        "NCONST", "SCONST", "NOUSE", "NOUSE", ",", "$", ":", ";", "EOL", " GOTO ", " GOSUB ", " TO ",
        " STEP ", " THEN ", "#", "<=", "<>", ">=", "<", ">", "=", "^", "*", "+", "-", "/", " NOT ", " OR ", " AND ",
        "(", ")", "=", "=", "<=", "<>", ">=", "<", ">", "=", "+", "-", "(", "(", "(", "(", "(", ",",
        "STR$", "CHR$", "USR", "ASC", "VAL", "LEN", "ADR", "ATN", "COS", "PEEK", "SIN", "RND", "FRE",
        "EXP", "LOG", "CLOG", "SQR", "SGN", "ABS", "INT", "PADDLE", "STICK", "PTRIG", "STRIG",

        // Turbo Basic
        "DPEEK", "&", "!", "INSTR", "INKEY$", " EXOR ", "HEX$", "DEC",
        " DIV ", "FRAC", "TIME$", "TIME", " MOD ", "EXEC ", "RND", "RAND",
        "TRUNC", "%0", "%1", "%2", "%3", "GO# ", "UINSTR", "ERR", "ERL"
    ];

    function ataribasic(a, i, len) {
        var indenting = _checks['indent'];
        var b = {
            lomem: le16(a, i + 0),   // should be zero
            vnt: le16(a, i + 2),     // start of variable name table
            vnte: le16(a, i + 4),    // end of variable name table
            vvt: le16(a, i + 6),     // start of variable values table
            stmtab: le16(a, i + 8),  // start of token area
            stmcur: le16(a, i + 10), // current line (line 32768)
            starp: le16(a, i + 12),  // end of token area, start of stacks

            variable_names: [],
            variable_values: [],
            statements: []
        }

        function failed(reason) {
            reason = reason || "Bytes don't look like Basic";
            console.log("ataribasic (): =>"); //(PVB ADD)
            console.log(reason);
            console.log(b);
            console.log(listing);
            console.log("*end of ataribasic ()*"); //(PVB ADD)
            return null;
        }

        var origin = b.vnt - b.lomem - 14; // file offsets are weird?
        if (origin < 0)
            return failed();
        b.vnt -= origin;
        b.vnte -= origin;
        b.vvt -= origin;
        b.stmtab -= origin;
        b.stmcur -= origin;
        b.starp -= origin;
        if (b.vnt > b.vnte || b.vnte > b.vvt || b.vvt > b.stmtab || b.stmtab > b.stmcur || b.stmcur > b.starp)
            return failed();    // Not a basic file?

        function get_string(data, si, len) {
            var s = '';
            while (len--) {
                var c = String.fromCharCode(data[si++]);
                s += c;
                if (c == '"')
                    s += c;
            }
            return s;
        }

        function bcd(data, bi) {
            var n = 0;
            var e = data[bi++];
            if (e == 0)
                return 0;
            for (var j = 0; j < 5; j++) {
                var c = data[bi++];
                n *= 10;
                n += c >> 4;
                n *= 10;
                n += c & 0xF;
            }
            e = (e - 68) * 2;

            switch (e) {	// Math.pow was not producing integers
                case -1: return n / 10;
                case -2: return n / 100;
                case -3: return n / 1000;
                case -4: return n / 10000;
            }
            return n * Math.pow(10, e);
        }

        var vnt_begin = i + b.vnt;
        var vnt_end = i + b.vnte;
        var n = '';
        var nmap = {};
        var ncount = 0;
        for (var j = vnt_begin; j < vnt_end; j++) {
            n += String.fromCharCode(a[j] & 0x7F);
            if (a[j] & 0x80) {
                if (n.length && n[n.length - 1] == '(')
                    n = n.substr(0, n.length - 1);	// 
                if (nmap[n])
                    console.log(`ataribasic(): reapeated variable name '${n}'`);
                nmap[n] = 1;
                ncount++;
                b.variable_names.push(n);
                n = '';
            }
        }

        if (Object.keys(nmap).length == 1) {
            console.log("ataribasic(): resetting variable names");
            b.variable_names = [];  // name table was set to the same value: reset it
        }

        var vvt_begin = i + b.vvt;	// NOT SURE WHY THESE ARE +1
        var tokens_begin = i + b.stmtab;
        var vid = 0;
        for (var j = vvt_begin; j < tokens_begin; j += 8) {
            var v = { name: b.variable_names[a[j + 1]] };

            if (!v.name) {  // someone got rid of all the variable names. make new ones
                var ch = String.fromCharCode(65 + (vid % 26));    // 'A'
                var n = Math.floor(vid++ / 26);
                if (n)
                    ch += n + 1;                              // A,B,C ... A2,B2...
                switch (a[j]) {
                    case 0x80:
                    case 0x81:
                        ch += '$';
                        break;
                }
                b.variable_names[a[j + 1]] = v.name = ch;     // make up a name if missing
            }

            var p0 = le16(a, j + 2);
            var p1 = le16(a, j + 4);
            var p2 = le16(a, j + 6);
            switch (a[j]) {
                case 0x00:
                    v.type = "scalar";
                    v.value = bcd(a, j + 2);
                    break;
                case 0x40:
                case 0x41:
                    v.type = "array";
                    break;
                case 0x80:
                case 0x81:
                    v.type = "string";
                    v.value = get_string(a, b.starp + i + p0, p1);
                    break;
                default:
                    v.type = a[j];
            }
            b.variable_values.push(v);
        }

        //var tokens_end = i+b.stmcur;
        var tokens_end = i + b.starp; // kings cribbage see https://www.atariarchives.org/mapping/memorymap.php STMCUR
        var turbo = false;

        var listing = [];
        var indent = 0;
        for (var j = tokens_begin; j < tokens_end;) {
            var s = { tok: [] };
            s.lineno = le16(a, j);
            var len = a[j + 2];

            if (s.lineno == 32768 || len == 0)
                break; // stmcur

            var line = s.lineno + " ";

            if (indent) {
                var cmd = a[j + 4];
                // Check if indent needs to decreased *before* the first command:
                //              NEXT           UNTIL          WEND           LOOP           ENDPROC        ENDIF     ELSE
                if (cmd == 0x09 || cmd == 0x3D || cmd == 0x3F || cmd == 0x46 || cmd == 0x51 || cmd == 0x41 || cmd == 0x40)
                    line = line + " ".repeat(2 * indent - 2);
                else
                    line = line + " ".repeat(2 * indent);
            }

            // Parse statements
            var k = 3;
            var op;
            while (k < len) {
                var end = a[j + k];
                var cmd = a[j + k + 1];
                k += 2;
                if (cmd >= 56) {
                    turbo = true;
                    if (cmd >= 101)
                        return failed("Unrecognized command index:" + cmd);    // not basic
                }

                s.tok.push(_basic_commands[cmd]);
                if (cmd != 0x36) {	// slient LET
                    line += _basic_commands[cmd];
                    if (line[line.length - 1] != ' ')
                        line += ' ';
                }

                if (cmd < 2) {	// REM,DATA
                    var txt = '';
                    while (k < end) {
                        var c = a[j + k++];
                        if (c == 0x9B)
                            break;
                        txt += String.fromCharCode(c);
                    }
                    s.tok.push(txt);
                    line += txt;
                    k = end;
                }

                // Check indent:
                //         FOR            REPEAT         WHILE          DO             PROC
                if (cmd == 0x08 || cmd == 0x3C || cmd == 0x3E || cmd == 0x45 || cmd == 0x4F)
                    indent += indenting;
                //              IF
                else if (cmd == 0x07) {
                    // Verify if there is THEN
                    var got_then = false;
                    for (var l = k; l < end; l++) {
                        var op = a[j + l];
                        if (op == 0x1B) {
                            got_then = true;
                            break;
                        }
                        else if (!op)
                            l++;
                        else if (op == 0x0F)
                            l += a[j + l + 1] + 1;
                        else if (op == 0x0E || op == 0x0D)
                            l += 6;
                    }
                    if (!got_then)
                        indent += indenting;
                }
                //              NEXT           UNTIL          WEND           LOOP           ENDPROC        ENDIF
                else if (cmd == 0x09 || cmd == 0x3D || cmd == 0x3F || cmd == 0x46 || cmd == 0x51 || cmd == 0x41)
                    indent = indent > 0 ? indent - 1 : 0;

                while (k < end) {
                    op = a[j + k++];
                    switch (op) {
                        case 0x0F: // SCONST
                            var txt = '';
                            var blen = a[j + k++];
                            while (blen--) {
                                c = a[j + k++];
                                if (c == 0x9B)
                                    break;
                                txt += String.fromCharCode(c);
                            }
                            s.tok.push(txt);
                            line += '"' + txt + '"';
                            break;
                        case 0x0D: // BCD hex const
                            var n = bcd(a, j + k);
                            var c = 1;
                            while (n >= (1 << c * 8))
                                c++;
                            s.tok.push(n);
                            k += 6;
                            line += '$' + hex(n, c * 2);
                            break;
                        case 0x0E: // NCONST
                            var n = bcd(a, j + k);
                            s.tok.push(n);
                            k += 6;
                            line += n;
                            break;
                        case 0x16: // EOL
                            k = end;
                            break;
                        default: {
                            var txt;
                            if (op & 0x80)
                                txt = b.variable_names[op & 0x7F];
                            else if (!op) {
                                turbo = true;
                                txt = b.variable_names[a[j + k++] ^ 0x80];    // thx dragonstomper
                            } else {
                                if (op >= 85) {
                                    turbo = true;
                                    if (op >= 110)
                                        return failed("Unrecognized operation:" + op);    // not basic
                                }
                                txt = _basic_operators[op];
                            }
                            if (txt == ":" || txt[0] == ' ')
                                line = line.trim();
                            line += txt;
                            s.tok.push(txt);
                        }
                    }
                }
            }
            b.statements.push(s);
            listing.push(line);
            j += len;
        }
        return { listing: listing, tokens: b }
    }

    //===================================================================================================
    // Atari syms equates : https://atariwiki.org/wiki/Wiki.jsp?page=Atari%20800%20Assembler%20Equates
    // also equates can be found in Atari OS Source listings
    // updated with information from Altirra Source Code, Disassembler DIS6502 https://sourceforge.net/p/dis6502/feature-requests/70/

    //(PVB ADD) 5200 EQUATES
    var _bShowA5200Equates = false; //if true, A5200 equates shall be used for disassembly instead of 800/XL/XE equates
    //for Atari 5200:
    //https://archive.org/details/analog-computing-magazine-15/page/n61/mode/2up?view=theater
    //commented by Dan Boris http://www.atarihq.com/danb/files/52analog.pdf
    var _A5200syms_zp = { //syms for Zero Page of Atari 5200
        //A5200 RAM is $0000 to $3FFF
        //PAGE zero $00-FF
        //$00 to $18 are reserved as follows
        '00':['POKMSK','SHADOW FOR IRQEN'],
        '01':['RTCLOKH','REAL TIME CLOCK (MSB)'],
        '02':['RTCLOKL','REAL TIME CLOCK (LSB)'],
        '03':['CRITIC','(ALSO NAMED CODFLG) IF NON-ZERO VBI ROUTINE IS SHORTEN'],
        '04':['ATRACT','ATRACT MODE TIME / FLAG'],
        '05':['SDLSTL','SHADOW FOR DLISTL'],
        '06':['SDLSTH','SHADOW FOR DLISTH'],
        '07':['SDMCTL','SHADOW FOR DMACTL'],
        '08':['PCOLR0','SHADOW FOR COLPM0'],
        '09':['PCOLR1','SHADOW FOR COLPM1'],
        '0A':['PCOLR2','SHADOW FOR COLPM2'],
        '0B':['PCOLR3','SHADOW FOR COLPM3'],
        '0C':['COLOR0','SHADOW FOR COLOR0'],
        '0D':['COLOR1','SHADOW FOR COLOR1'],
        '0E':['COLOR2','SHADOW FOR COLOR2'],
        '0F':['COLOR3','SHADOW FOR COLOR3'],
        '10':['COLOR4','SHADOW FOR COLBK'],
        '11':['PADDL0','SHADOW FOR POTO0'],
        '12':['PADDL1','SHADOW FOR POTO1'],
        '13':['PADDL2','SHADOW FOR POTO2'],
        '14':['PADDL3','SHADOW FOR POTO3'],
        '15':['PADDL4','SHADOW FOR POTO4'],
        '16':['PADDL5','SHADOW FOR POTO5'],
        '17':['PADDL6','SHADOW FOR POTO6'],
        '18':['PADDL7','SHADOW FOR POTO7'],
    }
    var _A5200syms = {
        //A5200 RAM is $0000 to $3FFF
        //PAGE 1 $100-1FF = 6502C CPU STACK
        '0100':["STACK", "6502C CPU STACK (256 BYTES UP TO $1FF)"],
        //$200 to $021B for the OS ROM Registers Shadows as follows
        '0200':['VIMIRQ ','IMMEDIATE IRQ VECTOR'],
        '0201':['VIMIRQ+1 ','...'],
        '0202':['VVBLKI ','IMMEDIATE VBI VECTOR'],
        '0203':['VVBLKI+1 ','...'],
        '0204':['VVBLKD ','DIFFERED VBI VECTOR'],
        '0205':['VVBLKD+1 ','...'],
        '0206':['VDLI ','VDSLST DLI VECTOR LOW'],
        '0207':['VDLI+1 ','VDSLST+1 DLI VECTOR HIGH'],
        '0208':['VKEYBD ','VKYBDI KEYBOARD IRQ VECTOR'],
        '0209':['VKEYBD+1 ','VKYBDI+1 KEYBOARD IRQ VECTOR'],
        '020A':['VKEYPAD ','VKYBDF KEYPAD ROUTINE CONTINUATION VECTOR'],
        '020B':['VKEYPAD+1 ','VKYBDF+1 KEYPAD ROUTINE CONTINUATION VECTOR'],
        '020C':['VBREAK ','VTRIGR BREAK KEY IRQ VECTOR'],
        '020D':['VBREAK+1 ','VTRIGR+1 BREAK KEY IRQ VECTOR'],
        '020E':['VBRK ','VBRKOP BREAK INSTRUCTION IRQ VECTOR'],
        '020F':['VBRK+1 ','VBRKOP+1 BREAK INSTRUCTION IRQ VECTOR'],
        '0210':['VSERIN ','SERIAL INPUT DATA READY IRQ VECTOR'],
        '0211':['VSERIN+1 ','...'],
        '0212':['VSEROR ','SERIAL OUTPUT DATA NEEDED IRQ VECTOR'],
        '0213':['VSEROR+1 ','...'],
        '0214':['VSEROC ','SERIAL OUTPUT FINISHED IRQ VECTOR'],
        '0215':['VSEROC+1 ','...'],
        '0216':['VTIMR1 ','POKEY TIMER 1 IRQ VECTOR'],
        '0217':['VTIMR1+1 ','...'],
        '0218':['VTIMR2 ','POKEY TIMER 2 IRQ VECTOR'],
        '0219':['VTIMR2+1 ','...'],
        '021A':['VTIMR4 ','POKEY TIMER 4 IRQ VECTOR'],
        '021B':['VTIMR4+1 ','...']
        //ROM CHAR SET is $F800 to $FBFF
        //ROM OS/MONITOR is $FC00 to $FFFF
    }
    //(PVB End Of ADD)

    //Atari 800/XL/XE equates
    //(PVB MOD) Update according to Altirra Source Equates & Disassembler
    var _A800syms_zp = { //zero page $00-FF
        '00': ["LINZBS", "[800]LINBUG STORAGE FOR ORIGINAL DEBUGGER"],
        '01': ["NGFLAG", "[XL]FOR POWER-UP SELF TEST"],
        '02': ["CASINI", "CASSETTE INIT LOC"],
        '03': ["CASINI+1", ""],
        '04': ["RAMLO", "RAM POINTER FOR MEM TEST"],
        '05': ["RAMLO+1", ""],
        '06': ["TRAMSZ", "TEMP LOC FOR RAM SIZE"],
        '07': ["TSTDAT", "RAM TEST DATA LOC"],
        '08': ["WARMST", "WARM START FLAG"],
        '09': ["BOOTQ", "SUCCESSFUL BOOT FLAG"],
        '0A': ["DOSVEC", "DOS START VECTOR (PROGRAM RUN VECTOR)"],
        '0B': ["DOSVEC+1", ""],
        '0C': ["DOSINI", "DOS INIT ADDRESS (PROGRAM INITIALIZATION)"],
        '0D': ["DOSINI+1", ""],
        '0E': ["APPMHI", "APPLICATION MEM HI LIMIT (DISPLAY LOW LIMIT)"],
        '0F': ["APPMHI+1", ""],
        '10': ["POKMSK", "SYSTEM MASK FOR POKEY IRQ ENABLE"],
        '11': ["BRKKEY", "BREAK KEY FLAG"],
        '12': ["RTCLOK", "REAL TIME CLOCK (60HZ OR 16.66666 MS) MSB"],
        '13': ["RTCLOK+1", "REAL TIME CLOCK MED BYTE"],
        '14': ["RTCLOK+2", "REAL TIME CLOCK LSB BYTE"],
        '15': ["BUFADR", "INDIRECT BUFFER ADDRESS REG"],
        '16': ["BUFADR+1", ""],
        '17': ["ICCOMT", "COMMAND FOR VECTOR HANDLER"],
        '18': ["DSKFMS", "DISK FILE MANAGER POINTER"],
        '19': ["DSKFMS+1", ""],
        '1A': ["DSKUTL", "DISK UTILITIES POINTER (DUP.SYS)"],
        '1B': ["DSKUTL+1", ""],
        '1C': ["PTIMOT/ABUFPT", "[800]PRINTER TIME OUT REGISTER /[XL]RESERVED"],
        '1D': ["PBPNT/ABUFPT+1", "[800]PRINT BUFFER POINTER /[XL]RESERVED"],
        '1E': ["PBUFSZ/ABUFPT+2", "[800]PRINT BUFFER SIZE /[XL]RESERVED"],
        '1F': ["PTEMP/ABUFPT+3", "[800]TEMPORARY REGISTER /[XL]RESERVED"],
        '20': ["ICHIDZ", "HANDLER INDEX NUMBER ($FF := IOCB FREE)"],//ZIOCB  = $20	; 32 ZERO PAGE IOCB
        '21': ["ICDNOZ", "DEVICE NUMBER (DRIVE NUMBER)"],
        '22': ["ICCOMZ", "COMMAND CODE"],
        '23': ["ICSTAZ", "STATUS OF LAST IOCB ACTION"],
        '24': ["ICBALZ", "BUFFER ADDRESS (LOW)"],
        '25': ["ICBAHZ", "BUFFER ADDRESS (HIGH)"],
        '26': ["ICPTLZ", "PUT BYTE ROUTINE ADDRESS-1 (LOW)"],
        '27': ["ICPTHZ", "PUT BYTE ROUTINE ADDRESS (HIGH)"],
        '28': ["ICBLLZ", "BUFFER LENGTH (LOW)"],
        '29': ["ICBLHZ", "BUFFER LENGTH (HIGH)"],
        '2A': ["ICAX1Z", "AUX INFO BYTE 1"],
        '2B': ["ICAX2Z", "AUX INFO BYTE 2"],
        '2C': ["ICSPRZ", "SPARE BYTE 1 (CIO LOCAL USE)"],
        '2D': ["ICSPRZ+1", "SPARE BYTE 1 (CIO LOCAL USE)"],
        '2E': ["ICIDNO", "IOCB LUMBER x 16"],
        '2F': ["CIOCHR", "CHARACTER BYTE FOR CURRENT OPERATION"],
        '30': ["STATUS", "INTERNAL STATUS STORAGE"],
        '31': ["CHKSUM", "CHECKSUM (SINGLE BYTE SUM WITH CARRY)"],
        '32': ["BUFRLO", "POINTER TO DATA BUFFER (LO BYTE)"],
        '33': ["BUFRHI", "POINTER TO DATA BUFFER (HI BYTE)"],
        '34': ["BFENLO", "NEXT BYTE PAST END OF BUFFER (LO BYTE)"],
        '35': ["BFENHI", "NEXT BYTE PAST END OF BUFFER (HI BYTE)"],
        '36': ["CRETRY/LTEMP", "[800]NBR OF COMMAND FRAME RETRIES /[XL]LOADER TEMP STORAGE"],
        '37': ["DRETRY/LTEMP+1", "[800]NBR OF DEVICE RETRIES/[XL]LOADER TEMP STORAGE"],
        '38': ["BUFRFL", "DATA BUFFER FULL FLAG"],
        '39': ["RECVDN", "RECEIVE DONE FLAG"],
        '3A': ["XMTDON", "XMIT DONE FLAG"],
        '3B': ["CHKSNT", "CHECKSUM SENT FLAG"],
        '3C': ["NOCKSM", "NO CHECKSUM FOLLOWS DATA FLAG"],
        '3D': ["BPTR", "BUFFER POINTER (CASSETTE)"],
        '3E': ["FTYPE", "FILE TYPE (SHORT IRG/LONG IRG)"],
        '3F': ["FEOF", "END OF FILE FLAG (CASSETTE)"],
        '40': ["FREQ", "FREQ COUNTER FOR CONSOLE SPEAKER"],
        '41': ["SOUNDR", "NOISY I/O FLAG (ZERO IS QUIET)"],
        '42': ["CRITIC", "CRITICAL CODE IF NON-ZERO (NO DEFFERED VBI)"],
        '43': ["FMSZPG", "DISK FILE MANAGER SYSTEM STORAGE (7 BYTES)"],
        '44': ["FMSZPG+1", ""],
        '45': ["FMSZPG+2", ""],
        '46': ["FMSZPG+3", ""],
        '47': ["FMSZPG+4", ""],
        '48': ["FMSZPG+5", ""],
        '49': ["FMSZPG+6", ""],
        '4A': ["CKEY/ZCHAIN", "[800]SET WHEN GAME START KEY PRESSED /[XL]HANDLER LOADER TEMP"],
        '4B': ["CASSBT/ZCHAIN+1", "[800]CASSETTE BOOT FLAG /[XL]HANDLER LOADER TEMP"],
        '4C': ["DSTAT", "DISPLAY STATUS"],
        '4D': ["ATRACT", "ATTRACT MODE FLAG"],
        '4E': ["DRKMSK", "DARK ATTRACT MASK"],
        '4F': ["COLRSH", "ATTRACT COLOR SHIFTER (XORED WITH PLAYFIELD)"],
        '50': ["TMPCHR", "TEMP CHAR STORAGE (DISPLAY HANDLER)"],
        '51': ["HOLD1", "TEMP STG (DISPLAY HANDLER)"],
        '52': ["LMARGN", "SCREEN LEFT MARGIN"],
        '53': ["RMARGN", "SCREEN RIGHT MARGIN"],
        '54': ["ROWCRS", "CURSOR COUNTERS (CURSOR ROW)"],
        '55': ["COLCRS", "CURSOR COUNTERS (CURSOR COLUMN), 2 BYTES"],
        '56': ["COLCRS+1", ""],
        '57': ["DINDEX", "DISPLAY INDEX (VARIOUS QUANTS)"],
        '58': ["SAVMSC", "SCREEN ADDRESS"],
        '59': ["SAVMSC+1", ""],
        '5A': ["OLDROW", "PREVIOUS ROW/COL (CURSOR BEFORE DRAW OR FILL)"],
        '5B': ["OLDCOL", ""],
        '5C': ["OLDCOL+1", ""],
        '5D': ["OLDCHR", "DATA UNDER CURSOR"],
        '5E': ["OLDADR", "CURSOR ADDRESS"],
        '5F': ["OLDADR+1", ""],
        '60': ["NEWROW/FKDEF", "[800]DRAWTO ROW DESTINATION /[XL]FUNCTION KEY POINTER"],
        '61': ["NEWCOL/FKDEF+1", "[800]DRAWTO COL DESTINATION /[XL]FUNCTION KEY POINTER"],
        '62': ["NEWCOL+1/PALNTS", "[800]DRAWTO COL DESTINATION /[XL]EUROPE/US TV FLAG"],
        '63': ["LOGCOL", "POINTS AT COLUMN IN LOGICAL LINE"],
        '64': ["ADRESS", "INDIRECT POINTER"],
        '65': ["ADRESS+1", ""],
        '66': ["MLTTMP", "MULTIPLY TEMP"],
        '67': ["TOADR+1", ""],
        '68': ["SAVADR", ""],
        '69': ["SAVADR+1", ""],
        '6A': ["RAMTOP", "RAM SIZE +1 DEFINED BY POWERON LOGIC (HIGH BYTE)"],
        '6B': ["BUFCNT", "BUFFER COUNT"],
        '6C': ["BUFSTR", "EDITOR GETCH POINTER"],
        '6D': ["BUFSTR+1", ""],
        '6E': ["BITMSK", "BIT MASK"],
        '6F': ["SHFAMT", "OUTCHR SHIFT"],
        '70': ["ROWAC", "USED BY \"DRAW\" 11 BYTES"],
        '71': ["ROWAC+1", ""],
        '72': ["COLAC", ""],
        '73': ["COLAC+1", ""],
        '74': ["ENDPT", ""],
        '75': ["ENDPT+1", ""],
        '76': ["DELTAR", ""],
        '77': ["DELTAC", ""],
        '78': ["DELTAC+1", ""],
        '79': ["ROWINC/KEYDEF", "[800] ROW /[XL]KEY DEFINITION POINTER"], //KEYDEF = 0x0079,	// XL/XE
        '7A': ["COLINC/KEYDEF+1", "[800] COL /[XL]KEY DEFINITION POINTER+1"],
        '7B': ["SWPFLG", "NON-0 IF TXT AND RAM SWAPPED"],
        '7C': ["HOLDCH", "CH BEFORE CNTL & SHFT PROCESSING IN KGETCH"],
        '7D': ["INSDAT", "INSERT CHAR SAVE"],
        '7E': ["COUNTR", "DRAW COUNTER"],
        '7F': ["COUNTR+1", ""],
        //$80 TO $FF ARE RESERVED FOR USER APPLICATION
        //ZROFRE = $80-D3 ; FREE ZERO PAGE, OR 84 BYTES USED BY BASIC
        '80': ["LOMEM", "BASIC POINTER TO LOW MEMORY"],
        '81': ["LOMEM+1", ""],
        '82': ["VNTP", "BASIC VARIABLE NAME TABLE"],
        '83': ["VNTP+1", ""],
        '84': ["VNTD", "BASIC VARIABLE NAME TABLE END"],
        '85': ["VNTD+1", ""],
        '86': ["VVTP", "BASIC VARIABLE VALUE TABLE"],
        '87': ["VVTP+1", ""],
        '88': ["STMTAB", "BASIC STATEMENT TABLE"],
        '89': ["STMTAB+1", ""],
        '8A': ["STMCUR", "BASIC CURRENT STATEMENT POINTER"],
        '8B': ["STMCUR+1", ""],
        '8C': ["STARP", "BASIC STRING AND ARRAY POINTER"],
        '8D': ["STARP+1", ""],
        '8E': ["RUNSTK", "BASIC RUNTIME STACK"],
        '8F': ["RUNSTK+1", ""],
        '90': ["MEMTOP", "BASIC TOP OF MEMORY"],
        '91': ["MEMTOP+1", ""],
        '92': ["MEOLFLG", ""],
        '94': ["COX", ""],
        '95': ["POKADR", ""],
        '96': ["POKADR+1", ""],
        '97': ["SVESA", ""],
        '98': ["SVESA+1", ""],
        '99': ["MVFA", ""],
        '9A': ["MVFA+1", ""],
        '9B': ["MVTA", ""],
        '9C': ["MVTA+1", ""],
        '9D': ["CPC", ""],
        '9E': ["CPC+1", ""],
        '9F': ["LLNGTH", ""],
        'A0': ["TSLNUM", ""],
        'A1': ["TSLNUM+1", ""],
        'A2': ["MVLNG", ""],
        'A3': ["MVLNG+1", ""],
        'A4': ["ECSIZE", ""],
        'A5': ["ECSIZE+1", ""],
        'A6': ["DIRFLG", ""],
        'A7': ["STMLBD", ""],
        'A8': ["STINDEX", ""],
        'A9': ["OPSTKX", ""],
        'AA': ["ARSTKX", ""],
        'AB': ["EXSVOP", ""],
        'AC': ["EXSVPR", ""],
        'AD': ["LELNUM", ""],
        'AE': ["LELNUM+1", ""],
        'AF': ["STENUM", ""],
        'B0': ["COMCNT", ""],
        'B1': ["ADFLAG", ""],
        'B2': ["SVDISP", ""],
        'B3': ["ONLOOP", ""],
        'B4': ["ENTDTD", ""],
        'B5': ["LISTDTD", ""],
        'B6': ["DATAD", ""],
        'B7': ["DATALN", ""],
        'B8': ["DATALN+1", ""],
        'B9': ["ERRNUM", ""],
        'BA': ["STOPLN", ""],
        'BB': ["STOPLN+1", ""],
        'BC': ["TRAPLN", ""],
        'BD': ["TRAPLN+1", ""],
        'BE': ["SAVCUR", ""],
        'BF': ["SAVCUR+1", ""],
        'C0': ["IOCMD", ""],
        'C1': ["IODVC", ""],
        'C2': ["PROMPT", ""],
        'C3': ["ERRSAV", ""],
        'C4': ["TEMPA", ""],
        'C5': ["TEMPA+1", ""],
        'C6': ["ZTEMP2", ""],
        'C7': ["ZTEMP2+1", ""],
        'C8': ["COLOR", ""],
        'C9': ["PTABW", ""],
        'CA': ["LOADFLG", ""],
        'D2': ["VTYPE", ""],
        'D3': ["VNUM", ""],
        //FPZRO  = $D4-$FF ; FLOATING POINT RAM, 43 BYTES
        'D4': ["FR0", "FP REGISTER 0 (6 BYTES)"],
        'D5': ["FR0+1", ""],
        'D6': ["FR0+2", ""],
        'D7': ["FR0+3", ""],
        'D8': ["FR0+4", ""],
        'D9': ["FR0+5", ""],
        'DA': ["FRE", "FP REGISTER EXP (6 BYTES)"],
        'DB': ["FRE+1", ""],
        'DC': ["FRE+2", ""],
        'DD': ["FRE+3", ""],
        'DE': ["FRE+4", ""],
        'DF': ["FRE+5", ""],
        'E0': ["FR1", "FP REGISTER 1 (6 BYTES)"],
        'E1': ["FR1+1", ""],
        'E2': ["FR1+2", ""],
        'E3': ["FR1+3", ""],
        'E4': ["FR1+4", ""],
        'E5': ["FR1+5", ""],
        'E6': ["FR2", "FP REGISTER 2 (6 BYTES)"],
        'E7': ["FR2+1", ""],
        'E8': ["FR2+2", ""],
        'E9': ["FR2+3", ""],
        'EA': ["FR2+4", ""],
        'EB': ["FR2+5", ""],
        'EC': ["FRX", "SPARE"],
        'ED': ["EEXP", "VALUE OF E"],
        'EE': ["NSIGN", "SIGN OF FP NUMBER"],
        'EF': ["ESIGN", "SIGN OF FP EXPONENT"],
        'F0': ["FCHRFLG", "FIRST CHARACTER FLAG"],
        'F1': ["DIGRT", "NUMBER OF DIGITS RIGHT OF DECIMAL POINT"],
        'F2': ["CIX", "INPUT INDEX"],
        'F3': ["INBUFF", "POINTER TO ASCII FP NUMBER"],
        'F4': ["INBUFF+1", ""],
        'F5': ["ZTEMP1", ""],
        'F6': ["ZTEMP1+1", ""],
        'F7': ["ZTEMP4", ""],
        'F8': ["ZTEMP4+1", ""],
        'F9': ["ZTEMP3", ""],
        'FA': ["ZTEMP3+1", ""],
        'FB': ["RADFLG", "0=RADIANS, 6=DEGREES"],
        'FC': ["FLPTR", "POINTER TO BCD FP NUMBER"],
        'FD': ["FLPTR+1", ""],
        'FE': ["FPTR2", ""],
        'FF': ["FPTR2+1", ""]
    }
    var _A800syms = {
        //PAGE 1 $100-1FF = 6502C CPU STACK
        '0100': ["STACK", "6502C CPU STACK (256 BYTES UP TO $1FF)"],
        //PAGE 2 $200-2FF
        //INTABS   =$200-232 ;INTERRUPT TABLE
        '0200': ["VDSLST", "DISPLAY LIST NMI VECTOR"],
        '0201': ["VDSLST+1", ""],
        '0202': ["VPRCED", "PROCEED LINE IRQ VECTOR"],
        '0203': ["VPRCED+1", ""],
        '0204': ["VINTER", "INTERRUPT LINE IRQ VECTOR"],
        '0205': ["VINTER+1", ""],
        '0206': ["VBREAK", "\"BRK\" VECTOR"],
        '0207': ["VBREAK+1", ""],
        '0208': ["VKEYBD", "POKEY KEYBOARD IRQ VECTOR"],
        '0209': ["VKEYBD+1", ""],
        '020A': ["VSERIN", "POKEY SERIAL INPUT READY"],
        '020B': ["VSERIN+1", ""],
        '020C': ["VSEROR", "POKEY SERIAL OUTPUT READY"],
        '020D': ["VSEROR+1", ""],
        '020E': ["VSEROC", "POKEY SERIAL OUTPUT DONE"],
        '020F': ["VSEROC+1", ""],
        '0210': ["VTIMR1", "POKEY TIMER 1 IRQ"],
        '0211': ["VTIMR1+1", ""],
        '0212': ["VTIMR2", "POKEY TIMER 2 IRQ"],
        '0213': ["VTIMR2+1", ""],
        '0214': ["VTIMR4", "POKEY TIMER 4 IRQ (DO NOT USE)"],
        '0215': ["VTIMR4+1", ""],
        '0216': ["VIMIRQ", "IMMEDIATE IRQ VECTOR"],
        '0217': ["VIMIRQ+1", ""],
        '0218': ["CDTMV1", "COUNT DOWN TIMER 1"],
        '0219': ["CDTMV1+1", ""],
        '021A': ["CDTMV1", "COUNT DOWN TIMER 2"],
        '021B': ["CDTMV2+1", ""],
        '021C': ["CDTMV1", "COUNT DOWN TIMER 3"],
        '021D': ["CDTMV3+1", ""],
        '021E': ["CDTMV1", "COUNT DOWN TIMER 4"],
        '021F': ["CDTMV4+1", ""],
        '0220': ["CDTMV1", "COUNT DOWN TIMER 5"],
        '0221': ["CDTMV5+1", ""],
        '0222': ["VVBLKI", "IMMEDIATE VERTICAL BLANK NMI VECTOR"],
        '0223': ["VVBLKI+1", ""],
        '0224': ["VVBLKD", "DEFERRED VERTICAL BLANK NMI VECTOR"],
        '0225': ["VVBLKD+1", ""],
        '0226': ["CDTMA1", "COUNT DOWN TIMER 1 JSR ADDRESS"],
        '0227': ["CDTMA1+1", ""],
        '0228': ["CDTMA2", "COUNT DOWN TIMER 2 JSR ADDRESS"],
        '0229': ["CDTMA2+1", ""],
        '022A': ["CDTMF3", "COUNT DOWN TIMER 3 FLAG"],
        '022B': ["SRTIMR", "SOFTWARE REPEAT TIMER"],
        '022C': ["CDTMF4", "COUNT DOWN TIMER 4 FLAG"],
        '022D': ["INTEMP", "IAN'S TEMP (???)"],
        '022E': ["CDTMF5", "COUNT DOWN TIMER 5 FLAG"],
        '022F': ["SDMCTL", "SAVE DMACTL REGISTER (DMACTL SHADOW)"],
        '0230': ["SDLSTL", "SAVE DISPLAY LIST (DL SHADOW)(LOW)"],
        '0231': ["SDLSTH", "SAVE DISPLAY LIST (DL SHADOW)(HIGH)"],
        '0232': ["SSKCTL", "SKCTL REGISTER RAM"],
        '0233': ["LCOUNT", "[XL]LOADER TEMP"],
        '0234': ["LPENH", "LIGHT PEN HORIZ VALUE"],
        '0235': ["LPENV", "LIGHT PEN VERT VALUE"],
        //[400/800] $236 - $239 SPARE
        '0236': ["BRKKY", "[XL]BREAK KEY VECTOR"],
        '0237': ["BRKKY+1", "[XL]BREAK KEY VECTOR"],
        '0238': ["VPIRQ/RELADR", "[XL]LOADER"],
        '0239': ["VPIRQ+1/RELADR+1", "[XL]LOADER"],
        '023A': ["CDEVIC", "COMMAND FRAME BUFFER - DEVICE"],
        '023B': ["CCOMND", "COMMAND"],
        '023C': ["CAUX1", "COMMAND AUX BYTE 1"],
        '023D': ["CAUX2", "COMMAND AUX BYTE 2"],
        '023E': ["TEMP", "TEMPORARY STORAGE"],
        '023F': ["ERRFLG", "ERROR FLAG (ANY DEVICE ERROR EXCEPT TIMEOUT)"],
        '0240': ["DFLAGS", "DISK FLAGS FROM BOOT SECTOR ONE (BYTE#00)"],
        '0241': ["DBSECT", "NUMBER OF DISK BOOT SECTORS (BYTE#01)"],
        '0242': ["BOOTAD", "LOW ADDRESS FOR DISK BOOT LOADER (BYTE#02)"],
        '0243': ["BOOTAD+1", "HIGH ADDRESS FOR DISK BOOT LOADER (BYTE#03)"],
        '0244': ["COLDST", "COLDSTART FLAG (1 = DOING COLDSTART)"],
        '0245': ["RECLEN", "[XL]LOADER"],
        '0246': ["DSKTIM", "[800]DISK TIME OUT REG"],
        //[XL] $246-26E 39 BYTES RESERVED
        '0247': ["LINBUF/PDVMSK", "[800]CHAR LINE BUFFER (40 BYTES UP TO $26E) /[XL]PDVMSK"],
        '0248': ["SHPDVS", "[XL]"],
        '0249': ["PDMSK", "[XL]"],
        '024A': ["RELADR", "[XL]"],
        '024B': ["RELADR+1", "[XL]"],
        '024C': ["PPTMPA", "[XL]"],
        '024D': ["PPTMPX", "[XL]"],
        '026B': ["CHSALT", "[XL]CHARACTER SET POINTER"],
        '026C': ["VSFLAG", "[XL]FINE SCROLL TEMPORARY"],
        '026D': ["KEYDIS", "[XL]KEYBOARD DISABLE"],
        '026E': ["FINE", "[XL]FINE SCROLL FLAG"],
        '026F': ["GPRIOR", "GLOBAL PRIORITY CELL (P-M PRIORITY AND GTIA MODES)"],
        //[XL] 3 MORE PADDLES, (800) 6 MORE PADDLE
        '0270': ["PADDL0", "POT 0 SHADOW"],
        '0271': ["PADDL1", "POT 1 SHADOW"],
        '0272': ["PADDL2", "POT 2 SHADOW"],
        '0273': ["PADDL3", "POT 3 SHADOW"],
        '0274': ["PADDL4", "POT 4 SHADOW"],
        '0275': ["PADDL5", "POT 5 SHADOW"],
        '0276': ["PADDL6", "POT 6 SHADOW"],
        '0277': ["PADDL7", "POT 7 SHADOW"],
        //[XL] 1 MORE STICK, (800) 3 MORE STICKS
        '0278': ["STICK0", "JOYSTICK 0 SHADOW"],
        '0279': ["STICK1", "JOYSTICK 1 SHADOW"],
        '027A': ["STICK2", "JOYSTICK 2 SHADOW"],
        '027B': ["STICK3", "JOYSTICK 3 SHADOW"],
        //[XL] 3 MORE PADDLE TRIGGERS, (800) 6 MOR
        '027C': ["PTRIG0", "PADDLE 0 TRIGGER"],
        '027D': ["PTRIG1", "PADDLE 1 TRIGGER"],
        '027E': ["PTRIG2", "PADDLE 2 TRIGGER"],
        '027F': ["PTRIG3", "PADDLE 3 TRIGGER"],
        '0280': ["PTRIG4", "PADDLE 4 TRIGGER"],
        '0281': ["PTRIG5", "PADDLE 5 TRIGGER"],
        '0282': ["PTRIG6", "PADDLE 6 TRIGGER"],
        '0283': ["PTRIG7", "PADDLE 7 TRIGGER"],
        //[XL] 1 MORE STICK TRIGGER, (800) 3 MORE
        '0284': ["STRIG0", "JOYSTICK 0 TRIGGER"],
        '0285': ["STRIG1", "JOYSTICK 1 TRIGGER"],
        '0286': ["STRIG2", "JOYSTICK 2 TRIGGER"],
        '0287': ["STRIG3", "JOYSTICK 3 TRIGGER"],
        '0288': ["CSTAT", "[800](UNUSED)"],
        '0289': ["WMODE", "R/W FLAG FOR CASSETTE"],
        '028A': ["BLIM", "BUFFER LIMIT (CASSETTE)"],
        //[400/800] $28B - $28F SPARE
        '028B': ["IMASK", "[XL]"],
        '028C': ["JVECK", "[XL]"],
        '028D': ["JVECK+1", "[XL]"],
        '028E': ["NEWADR", "[XL]LOADER RAM"],
        '028F': ["NEWADR+1", "[XL]LOADER RAM"],
        '0290': ["TXTROW", "TEXT ROWCRS"],
        '0291': ["TXTCOL", "TEXT ROWCOL"],
        '0292': ["TXTCOL+1", ""],
        '0293': ["TINDEX", "TEXT INDEX"],
        '0294': ["TXTMSC", "FOOLS CONVRT INTO NEW MSC"],
        '0295': ["TXTMSC+1", ""],
        '0296': ["TXTOLD", "OLDROW AND OLDCOL FOR TEXT (AND THEN SOME)"],
        '0297': ["TXTOLD+1", ""],
        '0298': ["TXTOLD+2", ""],
        '0299': ["TXTOLD+3", ""],
        '029A': ["TXTOLD+4", ""],
        '029B': ["TXTOLD+5", ""],
        '029C': ["TMPX1/CRETRY", " /[XL]NUMBER OF COMMAND FRAME RETRIES"],
        '029D': ["HOLD3", ""],
        '029E': ["SUBTMP", ""],
        '029F': ["HOLD2", ""],
        '02A0': ["DMASK", ""],
        '02A1': ["TMPLBT", ""],
        '02A2': ["ESCFLG", "ESCAPE FLAG"],
        '02A3': ["TABMAP", "TAB BUFFER 15 (BYTE BIT MAP FOR TAB SETTINGS)"],
        '02A4': ["TABMAP+1", ""],
        '02A5': ["TABMAP+2", ""],
        '02A6': ["TABMAP+3", ""],
        '02A7': ["TABMAP+4", ""],
        '02A8': ["TABMAP+5", ""],
        '02A9': ["TABMAP+6", ""],
        '02AA': ["TABMAP+7", ""],
        '02AB': ["TABMAP+8", ""],
        '02AC': ["TABMAP+9", ""],
        '02AD': ["TABMAP+A", ""],
        '02AE': ["TABMAP+B", ""],
        '02AF': ["TABMAP+C", ""],
        '02B0': ["TABMAP+D", ""],
        '02B1': ["TABMAP+E", ""],
        '02B2': ["LOGMAP", "LOGICAL LINE START BIT MAP (4 BYTES)"],
        '02B3': ["LOGMAP+1", ""],
        '02B4': ["LOGMAP+2", ""],
        '02B5': ["LOGMAP+3", ""],
        '02B6': ["INVFLG", "INVERSE VIDEO FLAG (ATARI KEY)"],
        '02B7': ["FILFLG", "RIGHT FILL FLAG FOR DRAW (FILL DIRING DRAW FLAG)"],
        '02B8': ["TMPROW", ""],
        '02B9': ["TMPCOL", ""],
        '02BA': ["TMPCOL+1", ""],
        '02BB': ["SCRFLG", "SET IF SCROLL OCCURS"],
        '02BC': ["HOLD4", "MORE DRAW TEMPS"],
        '02BD': ["HOLD5/DRETRY", "/[XL] NUMBER OF DEVICE RETRIES"],
        '02BE': ["SHFLOK", "SHIFT LOCK KEY"],
        '02BF': ["BOTSCR", "BOTTOM OF SCREEN (24 NORM, 4 SPLIT)"],
        '02C0': ["PCOLR0", "P0 COLOR"],
        '02C1': ["PCOLR1", "P1 COLOR"],
        '02C2': ["PCOLR2", "P2 COLOR"],
        '02C3': ["PCOLR3", "P3 COLOR"],
        '02C4': ["COLOR0", "COLOR 0"],
        '02C5': ["COLOR1", "COLOR 1"],
        '02C6': ["COLOR2", "COLOR 2"],
        '02C7': ["COLOR3", "COLOR 3"],
        '02C8': ["COLOR4", "BACKGROUND COLOR"],
        //[400/800] $2C9 - $2DF SPARE
        '02C9': ["RUNADR", "[XL]LOADER VECTOR"],
        '02CA': ["RUNADR+1", "[XL]LOADER VECTOR"],
        '02CB': ["HIUSED", "[XL]LOADER VECTOR"],
        '02CC': ["HIUSED+1", "[XL]LOADER VECTOR"],
        '02CD': ["ZHIUSE", "[XL]LOADER VECTOR"],
        '02CE': ["ZHIUSE+1", "[XL]LOADER VECTOR"],
        '02CF': ["GBYTEA", "[XL]LOADER VECTOR"],
        '02D0': ["GBYTEA+1", "[XL]LOADER VECTOR"],
        '02D1': ["LOADAD", "[XL]LOADER VECTOR"],
        '02D2': ["LOADAD+1", "[XL]LOADER VECTOR"],
        '02D3': ["ZLOADA", "[XL]LOADER VECTOR"],
        '02D4': ["ZLOADA+1", "[XL]LOADER VECTOR"],
        '02D5': ["DSCTLN", "[XL]LOADER VECTOR"],
        '02D6': ["DSCTLN+1", "[XL]LOADER VECTOR"],
        '02D7': ["ACMISR", "[XL]RESERVED"],
        '02D8': ["ACMISR+1", "[XL]RESERVED"],
        '02D9': ["KRPDEL", "[XL]KEY AUTO REPEAT DELAY"],
        '02DA': ["KEYREP", "[XL]KEY AUTO REPEAT RATE"],
        '02DB': ["NOCLIK", "[XL]KEY CLICK DISABLE"],
        '02DC': ["HELPFG", "[XL]HELP KEY FLAG"],
        '02DD': ["DMASAV", "[XL]SDMCTL (DMA) SAVE"],
        '02DE': ["PBPNT", "[XL]PRINTER BUFFER POINTER"],
        '02DF': ["PBUFSZ", "[XL]PRINTER BUFFER SIZE"],
        //[400/800] $2E0 - $2E3 SPARE
        '02E0': ["RUNAD", "DOS FILE RUN ADDRESS"],
        '02E1': ["RUNAD+1", ""],
        '02E2': ["INITAD", "DOS FILE INIT ADDRESS"],
        '02E3': ["INITAD+1", ""],
        '02E4': ["RAMSIZ", "RAM SIZE (HI BYTE ONLY)"],
        '02E5': ["MEMTOP", "TOP OF AVAILABLE MEMORY (END OF FREE RAM)"],
        '02E6': ["MEMTOP+1", ""],
        '02E7': ["MEMLO", "BOTTOM OF AVAILABLE MEMORY"],
        '02E8': ["MEMLO+1", ""],
        '02E9': ["HNDLOD", "[XL]HANDLER LOADER FLAG"],
        '02EA': ["DVSTAT", "STATUS BUFFER (4 BYTES)"],
        '02EB': ["DVSTAT+1", ""],
        '02EC': ["DVSTAT+2", ""],
        '02ED': ["DVSTAT+3", ""],
        '02EE': ["CBAUDL", "CASSETTE BAUD RATE (LO BYTE)"],
        '02EF': ["CBAUDH", "CASSETTE BAUD RATE (HI BYTE)"],
        '02F0': ["CRSINH", "CURSOR INHIBIT (0 = ON, 1 = INHIBIT)"],
        '02F1': ["KEYDEL", "KEY DELAY AND RATE"],
        '02F2': ["CH1", ""],
        '02F3': ["CHACT", "CHACTL REGISTER (SHADOW)"],
        '02F4': ["CHBAS", "CHBAS REGISTER (CHARACTER SET POINTER)(SHADOW)"],
        //[400/800] $2F5 - $2F9 SPARE
        '02F5': ["NEWROW", "[XL]DRAW DESTINATION"],
        '02F6': ["NEWCOL", "[XL]DRAW DESTINATION"],
        '02F7': ["NEWCOL+1", "[XL]DRAW DESTINATION"],
        '02F8': ["ROWINC", "[XL]"],
        '02F9': ["COLINC", "[XL]"],
        '02FA': ["CHAR", ""],
        '02FB': ["ATACHR", "ATASCII CHARACTER FOR CIO"],
        '02FC': ["CH", "GLOBAL VARIABLE FOR KEYBOARD"],
        '02FD': ["FILDAT", "RIGHT FILL DATA (DRAW)(COLOR FOR SCREEN FILL)"],
        '02FE': ["DSPFLG", "DISPLAY CONTROL CHAR FLAG IF NON-ZERO"],
        '02FF': ["SSFLAG", "DISPLAY START/STOP FLAG (CNTL-1) FOR PAGING"],
        //PAGE 3 $300-3FF RESIDENT DISK HANDLER/SIO INTERFACE
        //DCB = $0300 DEVICE CONTROL BLOCK
        '0300': ["DDEVIC", "BUS I.D. NUMBER"],
        '0301': ["DUNIT", "UNIT NUMBER"],
        '0302': ["DCOMND", "BUS COMMAND"],
        '0303': ["DSTATS", "COMMAND TYPE/STATUS RETURN"],
        '0304': ["DBUFLO", "DATA BUFFER POINTER (LO BYTE ADDR)"],
        '0305': ["DBUFHI", "DATA BUFFER POINTER (HI BYTE ADDR)"],
        '0306': ["DTIMLO", "DEVICE TIME OUT IN 1 SEC. UNITS"],
        '0307': ["DUNUSE", "UNUSED"],
        '0308': ["DBYTLO", "BYTE COUNT (SECTOR SIZE)(LO BYTE)"],
        '0309': ["DBYTHI", "BYTE COUNT (SECTOR SIZE)(HI BYTE)"],
        '030A': ["DAUX1", "COMMAND AUXILLARY BYTES (NBR OF SECTOR)(LO BYTE)"],
        '030B': ["DAUX2", "COMMAND AUXILLARY BYTES (NBR OF SECTOR)(HI BYTE)"],
        '030C': ["TIMER1", "INITIAL TIMER VALUE"],
        '030D': ["TIMER1+1", ""],
        '030E': ["ADDCOR/JMPERS", "[800]ADDITION CORRECTION /[XE]OPTION JUMPERS"],
        '030F': ["CASFLG", "CASSETTE MODE WHEN SET"],
        '0310': ["TIMER2", "FINAL TIME VALUE (USED TO COMPUTE BAUD RATE)"],
        '0311': ["TIMER2+1", ""],
        '0312': ["TEMP1", "TEMP LOCATION"],
        '0313': ["TEMP1+1/TEMP2", "TEMP LOCATION"],
        '0314': ["TEMP2/PTIMOT", "[800]TEMP2 /[XL]PRINTER TIME OUT"],
        '0315': ["TEMP3", ""],
        '0316': ["SAVIO", "SAVE SERIAL IN DATA PORT"],
        '0317': ["TIMFLG", "TIME OUT FLAG FOR BAUD RATE CORRECTION"],
        '0318': ["STACKP", "SIO STACK POINTER SAVE LOC"],
        '0319': ["TSTAT", "TEMP STATUS LOC"],
        '031A': ["HATABS", "HANDLER ADDRESS TABLE (38 BYTES UP TO $33F)"],
        '0321': ["MAXDEV", "MAXIMUM HANDLER ADDRESS INDEX"],
        '033D': ["PUPBT1", "[XL]POWER-UP/RESET"],
        '033E': ["PUPBT2", "[XL]POWER-UP/RESET"],
        '033F': ["PUPBT3", "[XL]POWER-UP/RESET"],
        //IOCB OFFSETS
        '0340': ["IOCB0", "ICHID I/O CONTROL BLOCK 0"],
        '0341': ["ICDNO", "DEVICE NUMBER (DRIVE NUMBER)"],
        '0342': ["ICCOM", "ICCMD COMMAND CODE"],
        '0343': ["ICSTA", "STATUS"],
        '0344': ["ICBAL", "BUFFER ADDRESS"],
        '0345': ["ICBAH", "..."],
        '0346': ["ICPTL", "PUT BYTE ROUTINE ADDRESS - 1"],
        '0347': ["ICPTH", "..."],
        '0348': ["ICBLL", "BUFFER LENGTH"],
        '0349': ["ICBLH", "..."],
        '034A': ["ICAX1", "AUXILLARY INFO"],
        '034B': ["ICAX2", "..."],
        '034C': ["ICSPR", "ICAX3 4 SPARE BYTES"],
        '034D': ["B0-ICAX4", ""],
        '034E': ["B0-ICAX5", ""],
        '034F': ["B0-ICAX6", ""],
        '0350': ["IOCB1", "I/O CONTROL BLOCK 1"],
        '0351': ["B1-ICDNO", ""],
        '0352': ["B1-ICCOM", ""],
        '0353': ["B1-ICSTA", ""],
        '0354': ["B1-ICBAL", ""],
        '0355': ["B1-ICBAH", ""],
        '0356': ["B1-ICPTL", ""],
        '0357': ["B1-ICPTH", ""],
        '0358': ["B1-ICBLL", ""],
        '0359': ["B1-ICBLH", ""],
        '035A': ["B1-ICAX1", ""],
        '035B': ["B1-ICAX2", ""],
        '035C': ["B1-ICAX3", ""],
        '035D': ["B1-ICAX4", ""],
        '035E': ["B1-ICAX5", ""],
        '035F': ["B1-ICAX6", ""],
        '0360': ["IOCB2", "I/O CONTROL BLOCK 2"],
        '0361': ["B2-ICDNO", ""],
        '0362': ["B2-ICCOM", ""],
        '0363': ["B2-ICSTA", ""],
        '0364': ["B2-ICBAL", ""],
        '0365': ["B2-ICBAH", ""],
        '0366': ["B2-ICPTL", ""],
        '0367': ["B2-ICPTH", ""],
        '0368': ["B2-ICBLL", ""],
        '0369': ["B2-ICBLH", ""],
        '036A': ["B2-ICAX1", ""],
        '036B': ["B2-ICAX2", ""],
        '036C': ["B2-ICAX3", ""],
        '036D': ["B2-ICAX4", ""],
        '036E': ["B2-ICAX5", ""],
        '036F': ["B2-ICAX6", ""],
        '0370': ["IOCB3", "I/O CONTROL BLOCK 3"],
        '0371': ["B3-ICDNO", ""],
        '0372': ["B3-ICCOM", ""],
        '0373': ["B3-ICSTA", ""],
        '0374': ["B3-ICBAL", ""],
        '0375': ["B3-ICBAH", ""],
        '0376': ["B3-ICPTL", ""],
        '0377': ["B3-ICPTH", ""],
        '0378': ["B3-ICBLL", ""],
        '0379': ["B3-ICBLH", ""],
        '037A': ["B3-ICAX1", ""],
        '037B': ["B3-ICAX2", ""],
        '037C': ["B3-ICAX3", ""],
        '037D': ["B3-ICAX4", ""],
        '037E': ["B3-ICAX5", ""],
        '037F': ["B3-ICAX6", ""],
        '0380': ["IOCB4", "I/O CONTROL BLOCK 4"],
        '0381': ["B4-ICDNO", ""],
        '0382': ["B4-ICCOM", ""],
        '0383': ["B4-ICSTA", ""],
        '0384': ["B4-ICBAL", ""],
        '0385': ["B4-ICBAH", ""],
        '0386': ["B4-ICPTL", ""],
        '0387': ["B4-ICPTH", ""],
        '0388': ["B4-ICBLL", ""],
        '0389': ["B4-ICBLH", ""],
        '038A': ["B4-ICAX1", ""],
        '038B': ["B4-ICAX2", ""],
        '038C': ["B4-ICAX3", ""],
        '038D': ["B4-ICAX4", ""],
        '038E': ["B4-ICAX5", ""],
        '038F': ["B4-ICAX6", ""],
        '0390': ["IOCB5", "I/O CONTROL BLOCK 5"],
        '0391': ["B5-ICDNO", ""],
        '0392': ["B5-ICCOM", ""],
        '0393': ["B5-ICSTA", ""],
        '0394': ["B5-ICBAL", ""],
        '0395': ["B5-ICBAH", ""],
        '0396': ["B5-ICPTL", ""],
        '0397': ["B5-ICPTH", ""],
        '0398': ["B5-ICBLL", ""],
        '0399': ["B5-ICBLH", ""],
        '039A': ["B5-ICAX1", ""],
        '039B': ["B5-ICAX2", ""],
        '039C': ["B5-ICAX3", ""],
        '039D': ["B5-ICAX4", ""],
        '039E': ["B5-ICAX5", ""],
        '039F': ["B5-ICAX6", ""],
        '03A0': ["IOCB6", "I/O CONTROL BLOCK 6"],
        '03A1': ["B6-ICDNO", ""],
        '03A2': ["B6-ICCOM", ""],
        '03A3': ["B6-ICSTA", ""],
        '03A4': ["B6-ICBAL", ""],
        '03A5': ["B6-ICBAH", ""],
        '03A6': ["B6-ICPTL", ""],
        '03A7': ["B6-ICPTH", ""],
        '03A8': ["B6-ICBLL", ""],
        '03A9': ["B6-ICBLH", ""],
        '03AA': ["B6-ICAX1", ""],
        '03AB': ["B6-ICAX2", ""],
        '03AC': ["B6-ICAX3", ""],
        '03AD': ["B6-ICAX4", ""],
        '03AE': ["B6-ICAX5", ""],
        '03AF': ["B6-ICAX6", ""],
        '03B0': ["IOCB7", "I/O CONTROL BLOCK 7"],
        '03B1': ["B7-ICDNO", ""],
        '03B2': ["B7-ICCOM", ""],
        '03B3': ["B7-ICSTA", ""],
        '03B4': ["B7-ICBAL", ""],
        '03B5': ["B7-ICBAH", ""],
        '03B6': ["B7-ICPTL", ""],
        '03B7': ["B7-ICPTH", ""],
        '03B8': ["B7-ICBLL", ""],
        '03B9': ["B7-ICBLH", ""],
        '03BA': ["B7-ICAX1", ""],
        '03BB': ["B7-ICAX2", ""],
        '03BC': ["B7-ICAX3", ""],
        '03BD': ["B7-ICAX4", ""],
        '03BE': ["B7-ICAX5", ""],
        '03BF': ["B7-ICAX6", ""],
        '03C0': ["PRNBUF", "PRINTER BUFFER (42 BYTES UP TO $3E9)"],
        '03E8': ["SUPERF", "[XL]SCREEN EDITOR"],
        '03E9': ["CKEY", "[XL]START KEY FLAG"],
        //[400/800] $3EA - $3FC SPARE
        '03EA': ["CASSBT", "[XL]CASSETTE BOOT FLAG"],
        '03EB': ["CARTCK", "[XL]CARTRIDGE CHECKSUM"],
        '03EC': ["DERRF", "[XL]"],
        '03ED': ["ACMVAR", "[XL]RESERVED, 6 BYTES"],
        '03F8': ["BASICF", "[XL]"],
        '03F9': ["MINTLK", "[XL]RESERVED"],
        '03FA': ["GINTLK", "[XL]CARTRIDGE INTERLOCK"],
        '03FB': ["CHLINK", "[XL]HANDLER CHAIN (2 BYTES)"],
        '03FC': ["CHLINK+1", "[XL]HANDLER CHAIN (2 BYTES)"],
        '03FD': ["CASBUF", "CASSETTE BUFFER (131 BYTES UP TO $47F)"],
        //USAREA $480-57F 256 BYTES AREA FOR USER
        '0580': ["LBUFF", "TEMP BUFFER (128 BYTES UP TO $5FF)"],
        //RAM ALWAYS FREE ABOVE $600
        //CART LOW (RIGHT)
        '9FFA': ["R-CARTCS", "R-CARTRIDGE COLD START ADDRESS"],
        '9FFB': ["R-CARTCS+1", "..."],
        '9FFC': ["R-CART", "R-CARTRIDGE AVAILABLE FLAG BYTE"],
        '9FFD': ["R-CARTFG", "R-CARTRIDGE FLAG BYTE"],
        '9FFE': ["R-CARTAD", "R-CARTRIDGE START VECTOR ADDRESS"],
        '9FFF': ["R-CARTAD+1", "..."],
        //CART HIGH
        'BFFA': ["CARTCS", "CARTRIDGE COLD START ADDRESS"],
        'BFFB': ["CARTCS+1", "..."],
        'BFFC': ["CART", "CARTRIDGE AVAILABLE FLAG BYTE"],
        'BFFD': ["CARTFG", "CARTRIDGE FLAG BYTE"],
        'BFFE': ["CARTAD", "CARTRIDGE START VECTOR ADDRESS"],
        'BFFF': ["CARTAD+1", "..."],
        //$C000-CFFF 4K OS ROM for XL/XE
        //$D000-D7FF is the hardware chip interface -> no RAM, nor ROM
        //NOTE : in ATARI XL/XE ROM, data from $D000 to D7FF are the diagnostic 2K ROM program, are copied in RAM at $5000-57FF when requested
        //GTIA $D000-D01F
        'D000': ["M0PF/HPOSP0", "MIS-PLAYF COLLISION(R)/P0 POSITION(W)"],
        'D001': ["M1PF/HPOSP1", "MIS-PLAYF COLLISION(R)/P1 POSITION(W)"],
        'D002': ["M2PF/HPOSP2", "MIS-PLAYF COLLISION(R)/P2 POSITION(W)"],
        'D003': ["M3PF/HPOSP3", "MIS-PLAYF COLLISION(R)/P3 POSITION(W)"],
        'D004': ["P0PF/HPOSM0", "PLAYER-PLAYF COLLISION(R)/M0 POSITION(W)"],
        'D005': ["P1PF/HPOSM1", "PLAYER-PLAYF COLLISION(R)/M1 POSITION(W)"],
        'D006': ["P2PF/HPOSM2", "PLAYER-PLAYF COLLISION(R)/M2 POSITION(W)"],
        'D007': ["P3PF/HPOSM3", "PLAYER-PLAYF COLLISION(R)/M3 POSITION(W)"],
        'D008': ["M0PL/SIZEP0", "MIS-PLAYER COLLISION(R)/P0 SIZE(W)"],
        'D009': ["M1PL/SIZEP1", "MIS-PLAYER COLLISION(R)/P1 SIZE(W)"],
        'D00A': ["M2PL/SIZEP2", "MIS-PLAYER COLLISION(R)/P2 SIZE(W)"],
        'D00B': ["M3PL/SIZEP3", "MIS-PLAYER COLLISION(R)/P3 SIZE(W)"],
        'D00C': ["P0PL/SIZEM", "PLAYER-PLAYER COLLISION(R)/MIS SIZE(W)"],
        'D00D': ["P1PL/GRAFP0", "PLAYER-PLAYER COLLISION(R)/P0 GRAPH LATCH(W)"],
        'D00E': ["P2PL/GRAFP1", "PLAYER-PLAYER COLLISION(R)/P1 GRAPH LATCH(W)"],
        'D00F': ["P3PL/GRAFP2", "PLAYER-PLAYER COLLISION(R)/P2 GRAPH LATCH(W)"],
        'D010': ["TRIG0/GRAFP3", "JOYSTK0 TRIGG(R)/P4 GRAPH LATCH(W)"],
        'D011': ["TRIG1/GRAFM", "JOYSTK1 TRIGG(R)/MISSILE GRAPH LATCH(W)"],
        'D012': ["TRIG2/COLPM0", "JOYSTK2 TRIGG(R)/PLAYER&MISS COLOR(W)"],
        'D013': ["TRIG3/COLPM1", "JOYSTK3 TRIGG(R)/PLAYER&MISS COLOR(W)"],
        'D014': ["PAL/COLPM2", "NTSC/PAL DETECT(R)/PLAYER&MISS COLOR(W)"],
        'D015': ["COLPM3", "PLAYER&MISS COLOR(W)"],
        'D016': ["COLPF0", "PALYFIELD0 COLOR(W)"],
        'D017': ["COLPF1", "PALYFIELD1 COLOR(W)"],
        'D018': ["COLPF2", "PALYFIELD2 COLOR(W)"],
        'D019': ["COLPF3", "PALYFIELD3 COLOR(W)"],
        'D01A': ["COLBK", "BACKGROUND COLOR(W)"],
        'D01B': ["PRIOR", "PRIORITY CONTROL(W)"],
        'D01C': ["VDELAY", "VERTICAL DELAY(W)"],
        'D01D': ["GRACTL", "GRAPHIC CONTROL(W)"],
        'D01E': ["HITCLR", "COLLISION CLEAR STROBE(W)"],
        'D01F': ["CONSOL", "CONSOLE SWITCHES OPTION-SELECT-START(R&W)"],
        //PBI Paralel bus interface CONTROL $D100
        'D100': ["PBI", ""],
        'D1FF': ["PDVI", ""],
        //POKEY $D200-D20F
        'D200': ["POT0/AUDF1", "PAD POT POS(R)/AUDIO CHANNEL 1 FREQ(W)"], 
        'D201': ["POT1/AUDF2", "PAD POT POS(R)/AUDIO CHANNEL 2 FREQ(W)"],
        'D202': ["POT2/AUDF3", "PAD POT POS(R)/AUDIO CHANNEL 3 FREQ(W)"],
        'D203': ["POT3/AUDF4", "PAD POT POS(R)/AUDIO CHANNEL 4 FREQ(W)"],
        'D204': ["POT4/AUDC1", "PAD POT POS(R)/AUDIO CHANNEL 1 CONTROL(W)"],
        'D205': ["POT5/AUDC2", "PAD POT POS(R)/AUDIO CHANNEL 2 CONTROL(W)"],
        'D206': ["POT6/AUDC3", "PAD POT POS(R)/AUDIO CHANNEL 3 CONTROL(W)"],
        'D207': ["POT7/AUDC4", "PAD POT POS(R)/AUDIO CHANNEL 4 CONTROL(W)"],
        'D208': ["ALLPOT/AUDCTL", "PAD DIRECTION(R)/AUDIO CONTROL(W)"],
        'D209': ["KBCODE/STIMER", "KEYB CODE(R)/START TIMER STROBE(W)"],
        'D20A': ["RANDOM/SKRES", "RANDOM(R)/SERIAL&KEYB RESET(W)"],
        'D20B': ["POTGO", "PADDLE POT READ START STROBE(W)"],
        'D20D': ["SERIN/SEROUT", "SERIAL IN(R)/SERIAL OUT(W) DATA"],
        'D20E': ["IRQST/IRQEN", "IRQ STATUS(R)/IRQ ENABLE(W)"],
        'D20F': ["SKSTAT/SKCTL", "SERIAL&KEYB STATUS(R)/SERIAL&KEYB CONTROL(W)"],
        //PIA $D300-D303
        'D300': ["PORTA", "PORT A DATA DIRECTION JOYSTICKS(R&W)"],
        'D301': ["PORTB", "PORT B DATA DIRECTION(R&W)"],
        'D302': ["PACTL", "PORT A CONTROL(R&W)"],
        'D303': ["PBCTL", "PORT B CONTROL(R&W)"],
        //ANTIC $D400-D40F
        'D400': ["DMACTL", "DMA CONTROL(W)"],
        'D401': ["CHACTL", "CHAR CONTROL(W)"],
        'D402': ["DLISTL", "DISPLAY LIST ADDRESS (LO BYTE)(W)"],
        'D403': ["DLISTH", "DISPLAY LIST ADDRESS (HI BYTE)(W)"],
        'D404': ["HSCROL", "HORIZONTAL SCROLL(W)"],
        'D405': ["VSCROL", "VERTICAL SCROLL(W)"],
        'D407': ["PMBASE", "PLAYER MISSILE BASE(W)"],
        'D409': ["CHBASE", "CHAR SET BASE(W)"],
        'D40A': ["WSYNC", "WAIT FOR H SYNC(W)"],
        'D40B': ["VCOUNT", "VERTICAL COUNT(R)"],
        'D40C': ["PENH", "PEN H POSITION(R)"],
        'D40D': ["PENV", "PEN H POSITION(R)"],
        'D40E': ["NMIEN", "NMI INTERRUPT ENABLE(W)"],
        'D40F': ["NMIST/NMIRES", "NMI STATUS(R)/NMI RESET(W)"],
        //CART CONBTROL $D500-D5FF => ROM BANK SWITCHING CONTROL
        'D500': ["BKSWITCH", "MEMORY BANK SWITCHING CONTROL"],
        //PBI CONTROL $D600-$D7FF
        'D600': ["PBIRAM", ""],
        //MATH PACK (Floating Point FP) 2K OS ROM $D800-DFFF
        'D800': ["AFP", ""],
        'D803': ["PDID1", ""],
        'D805': ["PDIOV", ""],
        'D806': ["PDIOV+1", ""],
        'D808': ["PDIRQV", ""],
        'D809': ["PDIRQV+1", ""],
        'D80B': ["PDID2", ""],
        'D80D': ["PDVV", ""],
        'D8E6': ["FASC", ""],
        'D9AA': ["IFP", ""], //IPF    = 0xD9AA,
        'D9D2': ["FPI", ""],
        'DA44': ["ZFR0", ""],
        'DA46': ["ZF1", ""],
        'DA60': ["FSUB", ""],
        'DA66': ["FADD", ""],
        'DADB': ["FMUL", ""],
        'DB28': ["FDIV", ""],
        'DD40': ["PLYEVL", ""],
        'DD89': ["FLD0R", ""],
        'DD8D': ["FLD0P", ""],
        'DD98': ["FLD1R", ""],
        'DD9C': ["FLD1P", ""],
        'DDA7': ["FST0R", ""],
        'DDAB': ["FST0P", ""],
        'DDB6': ["FMOVE", ""],
        'DDC0': ["EXP", ""],
        'DDCC': ["EXP10", ""],
        'DECD': ["LOG", ""],
        'DED1': ["LOG10", ""],
        //OS ROM 8K $E000-FFFF
        //$E000-E3FF RESIDENT CHAR SET 
        //$E400-EFFF OS ROM ROUTINES
        'E400': ["EDITRV", "EDITOR"],
        'E410': ["SCRENV", "TELEVISION SCREEN"],
        'E420': ["KEYBDV", "KEYBOARD"],
        'E430': ["PRINTV", "PRINTER"],
        'E440': ["CASETV", "CASSETTE"],
        'E450': ["DISKIV", "DISK INITIALIZATION"],
        'E453': ["DSKINV", "DISK INTERFACE"],
        'E456': ["CIOV", "CIO ROUTINE"],
        'E459': ["SIOV", "SIO ROUTINE"],
        'E45C': ["SETVBV", "SET VERTICAL BLANK VECTORS"],
        'E45F': ["SYSVBV", "SYSTEM VERTICAL BLANK ROUTINE"],
        'E462': ["XITVBV", "EXIT VERTICAL BLANK ROUTINE"],
        'E465': ["SIOINV", "SIO INIT"],
        'E468': ["SENDEV", "SEND ENABLE ROUTINE"],
        'E46B': ["INTINV", "INTERRUPT HANDLER INIT"],
        'E46E': ["CIOINV", "CIO INIT"],
        'E471': ["BLKBDV", "BLACKBOARD MODE"],
        'E474': ["WARMSV", "WARM START ENTRY POINT"],
        'E477': ["COLDSV", "COLD START ENTRY POINT"],
        'E47A': ["RBLOKV", "CASSETTE READ BLOCK VECTOR"],
        'E47D': ["CSOPIV", "CASSETTE OPEN FOR INPUT VECTOR"],
        'E480': ["VCTABL", "PUPDIV"],
        'E483': ["SLFTSV", ""],
        'E486': ["PHENTV", ""],
        'E489': ["PHUNLV", ""],
        'E48C': ["PHINIV", ""],
        'E48F': ["GPDVV", ""],
        'F385': ["PUTLIN", "OUTPUT LINE TO IOCB#0"],
        'F6A4': ["EOUTCH", "OUTPUT CHAR TO SCREEN"],
        'F6E2': ["KGETCH", "GET CHAR FROM KEYBOARD"],
        //6502 CPU RESIDENT CPU VECTORS
        'FFFA': ["NMIVEC", "NMI NON MASKABLE INTERRUPT OS ROM VECTOR"],
        'FFFB': ["NMIVEC+1", "..."],
        'FFFC': ["RESETVEC", "RESET OS ROM VECTOR"],
        'FFFD': ["RESETVEC+1", "..."],
        'FFFE': ["IRQVEC", "IRQ INTERRUPT REQUEST OS ROM VECTOR"],
        'FFFF': ["IRQVEC+1", "..."],
    }

    //===================================================================================================
    // 6502 disassembler derived from
    // n. landsteiner, mass:werk / electronic tradion 2005; e-tradion.net
    //(PVB COM) see also https://www.masswerk.at/6502/6502_instruction_set.html
    var opctab = [ //00..................................................+
        ['BRK', 'imp'], ['ORA', 'inx'], ['???', 'imp'], ['???', 'imp'], //00--03
        ['???', 'imp'], ['ORA', 'zpg'], ['ASL', 'zpg'], ['???', 'imp'], //04--07
        ['PHP', 'imp'], ['ORA', 'imm'], ['ASL', 'acc'], ['???', 'imp'], //08--0B
        ['???', 'imp'], ['ORA', 'abs'], ['ASL', 'abs'], ['???', 'imp'], //0C--0F
        //10
        ['BPL', 'rel'], ['ORA', 'iny'], ['???', 'imp'], ['???', 'imp'],
        ['???', 'imp'], ['ORA', 'zpx'], ['ASL', 'zpx'], ['???', 'imp'],
        ['CLC', 'imp'], ['ORA', 'aby'], ['???', 'imp'], ['???', 'imp'],
        ['???', 'imp'], ['ORA', 'abx'], ['ASL', 'abx'], ['???', 'imp'],
        //20
        ['JSR', 'abs'], ['AND', 'inx'], ['???', 'imp'], ['???', 'imp'],
        ['BIT', 'zpg'], ['AND', 'zpg'], ['ROL', 'zpg'], ['???', 'imp'],
        ['PLP', 'imp'], ['AND', 'imm'], ['ROL', 'acc'], ['???', 'imp'],
        ['BIT', 'abs'], ['AND', 'abs'], ['ROL', 'abs'], ['???', 'imp'],
        //30
        ['BMI', 'rel'], ['AND', 'iny'], ['???', 'imp'], ['???', 'imp'],
        ['???', 'imp'], ['AND', 'zpx'], ['ROL', 'zpx'], ['???', 'imp'],
        ['SEC', 'imp'], ['AND', 'aby'], ['???', 'imp'], ['???', 'imp'],
        ['???', 'imp'], ['AND', 'abx'], ['ROL', 'abx'], ['???', 'imp'],
        //40
        ['RTI', 'imp'], ['EOR', 'inx'], ['???', 'imp'], ['???', 'imp'],
        ['???', 'imp'], ['EOR', 'zpg'], ['LSR', 'zpg'], ['???', 'imp'],
        ['PHA', 'imp'], ['EOR', 'imm'], ['LSR', 'acc'], ['???', 'imp'],
        ['JMP', 'abs'], ['EOR', 'abs'], ['LSR', 'abs'], ['???', 'imp'],
        //50
        ['BVC', 'rel'], ['EOR', 'iny'], ['???', 'imp'], ['???', 'imp'],
        ['???', 'imp'], ['EOR', 'zpx'], ['LSR', 'zpx'], ['???', 'imp'],
        ['CLI', 'imp'], ['EOR', 'aby'], ['???', 'imp'], ['???', 'imp'],
        ['???', 'imp'], ['EOR', 'abx'], ['LSR', 'abx'], ['???', 'imp'],
        //60
        ['RTS', 'imp'], ['ADC', 'inx'], ['???', 'imp'], ['???', 'imp'],
        ['???', 'imp'], ['ADC', 'zpg'], ['ROR', 'zpg'], ['???', 'imp'],
        ['PLA', 'imp'], ['ADC', 'imm'], ['ROR', 'acc'], ['???', 'imp'],
        ['JMP', 'ind'], ['ADC', 'abs'], ['ROR', 'abs'], ['???', 'imp'],
        //70
        ['BVS', 'rel'], ['ADC', 'iny'], ['???', 'imp'], ['???', 'imp'],
        ['???', 'imp'], ['ADC', 'zpx'], ['ROR', 'zpx'], ['???', 'imp'],
        ['SEI', 'imp'], ['ADC', 'aby'], ['???', 'imp'], ['???', 'imp'],
        ['???', 'imp'], ['ADC', 'abx'], ['ROR', 'abx'], ['???', 'imp'],
        //80
        ['???', 'imp'], ['STA', 'inx'], ['???', 'imp'], ['???', 'imp'],
        ['STY', 'zpg'], ['STA', 'zpg'], ['STX', 'zpg'], ['???', 'imp'],
        ['DEY', 'imp'], ['???', 'imp'], ['TXA', 'imp'], ['???', 'imp'],
        ['STY', 'abs'], ['STA', 'abs'], ['STX', 'abs'], ['???', 'imp'],
        //90
        ['BCC', 'rel'], ['STA', 'iny'], ['???', 'imp'], ['???', 'imp'],
        ['STY', 'zpx'], ['STA', 'zpx'], ['STX', 'zpy'], ['???', 'imp'],
        ['TYA', 'imp'], ['STA', 'aby'], ['TXS', 'imp'], ['???', 'imp'],
        ['???', 'imp'], ['STA', 'abx'], ['???', 'imp'], ['???', 'imp'],
        //A0
        ['LDY', 'imm'], ['LDA', 'inx'], ['LDX', 'imm'], ['???', 'imp'],
        ['LDY', 'zpg'], ['LDA', 'zpg'], ['LDX', 'zpg'], ['???', 'imp'],
        ['TAY', 'imp'], ['LDA', 'imm'], ['TAX', 'imp'], ['???', 'imp'],
        ['LDY', 'abs'], ['LDA', 'abs'], ['LDX', 'abs'], ['???', 'imp'],
        //B0
        ['BCS', 'rel'], ['LDA', 'iny'], ['???', 'imp'], ['???', 'imp'],
        ['LDY', 'zpx'], ['LDA', 'zpx'], ['LDX', 'zpy'], ['???', 'imp'],
        ['CLV', 'imp'], ['LDA', 'aby'], ['TSX', 'imp'], ['???', 'imp'],
        ['LDY', 'abx'], ['LDA', 'abx'], ['LDX', 'aby'], ['???', 'imp'],
        //C0
        ['CPY', 'imm'], ['CMP', 'inx'], ['???', 'imp'], ['???', 'imp'],
        ['CPY', 'zpg'], ['CMP', 'zpg'], ['DEC', 'zpg'], ['???', 'imp'],
        ['INY', 'imp'], ['CMP', 'imm'], ['DEX', 'imp'], ['???', 'imp'],
        ['CPY', 'abs'], ['CMP', 'abs'], ['DEC', 'abs'], ['???', 'imp'],
        //D0
        ['BNE', 'rel'], ['CMP', 'iny'], ['???', 'imp'], ['???', 'imp'],
        ['???', 'imp'], ['CMP', 'zpx'], ['DEC', 'zpx'], ['???', 'imp'],
        ['CLD', 'imp'], ['CMP', 'aby'], ['???', 'imp'], ['???', 'imp'],
        ['???', 'imp'], ['CMP', 'abx'], ['DEC', 'abx'], ['???', 'imp'],
        //E0
        ['CPX', 'imm'], ['SBC', 'inx'], ['???', 'imp'], ['???', 'imp'],
        ['CPX', 'zpg'], ['SBC', 'zpg'], ['INC', 'zpg'], ['???', 'imp'],
        ['INX', 'imp'], ['SBC', 'imm'], ['NOP', 'imp'], ['???', 'imp'],
        ['CPX', 'abs'], ['SBC', 'abs'], ['INC', 'abs'], ['???', 'imp'],
        //F0
        ['BEQ', 'rel'], ['SBC', 'iny'], ['???', 'imp'], ['???', 'imp'],
        ['???', 'imp'], ['SBC', 'zpx'], ['INC', 'zpx'], ['???', 'imp'],
        ['SED', 'imp'], ['SBC', 'aby'], ['???', 'imp'], ['???', 'imp'],
        ['???', 'imp'], ['SBC', 'abx'], ['INC', 'abx'], ['???', 'imp']
    ];

    var addrtab = {
        acc: 'A',
        abs: 'abs',
        abx: 'abs,X',
        aby: 'abs,Y',
        imm: '#',
        imp: 'impl',
        ind: 'ind',
        inx: 'X,ind',
        iny: 'ind,Y',
        rel: 'rel',
        zpg: 'zpg',
        zpx: 'zpg,X',
        zpy: 'zpg,Y'
    }

    var steptab = { //step is the number of bytes within the instruction line
        imp: 1,
        acc: 1,
        imm: 2,
        abs: 3,
        abx: 3,
        aby: 3,
        zpg: 2,
        zpx: 2,
        zpy: 2,
        ind: 3,
        inx: 2,
        iny: 2,
        rel: 2
    };
    //(PVB ADD) boolean flag for disassemble display options //(PVB TODO) use bits in a byte rather than global variables ?
    var _bShowDisLinks = true; // change to true to show disassembly links
    var _bShowDisFlags = false; // change to true to show flags in disassembly
    var _bShowDisBRK = false; // change to true for up to 2 x BRK in disassembly
    var _bShowATRChar = false; // change to true for listing display with Atari Font
    var _bShowROMBank = false; //change to true for showing rom bank in disassembly
    
    // functions

    //(PVB ADD) toggle_bShow(t) function to handle above disassemble display options
    function toggle_bShow(t) {
        switch (t) {
            case "L":
                _bShowDisLinks ^= true;
                break;
            case "F":
                _bShowDisFlags ^= true;
                break;
            case "B":
                _bShowDisBRK ^= true;
                break;
            case "A":
                _bShowATRChar ^= true;
                break;
            case "K":
                _bShowROMBank ^= true;
                break;
        }
        refresh();   
    }
    //(PVB END OF ADD)

    //(PVB ADD) the get_symbol(memadd, opc) function
    function get_symbol(memadd, opc) {
        var str1, str2, n1, n2, sym, a;
        var a5200eq = _bShowA5200Equates;
        if (memadd.length == 2) { //zero page
            return (a5200eq ? _A5200syms_zp[memadd] : _A800syms_zp[memadd]);
        }
        //(PVB TODO) : convert memadd for A5200 ?//
        a = Number("0x" + memadd);
        if (a < 0xC000)
            return (a5200eq ? _A5200syms[memadd] : _A800syms[memadd]);
        if (a5200eq) { //Hardware chip addressing in A5200
            if (a >= 0xC000 && a <= 0xC0FF ) //GTIA at $C000-C0FF, that is at $D000-D0FF for A800
                memadd = hex(((a & 0x001F) | 0xD000),4);
            if (a >= 0xE800 && a <= 0xEBFF ) //POKEY at $E800-EBFF (that can feature 4xPOKEY chips ?), that is at $D200-D2FF for A800
                memadd = hex(((a & 0x000F) | 0xD200),4);
            if (a >= 0xD400 && a <= 0xD4FF ) {//ANTIC at $D400-D4FF, that is also at $D400-D4FF for A800
                memadd = hex(((a & 0x000F) | 0xD400),4);
            }
            if (a >= 0xF800 && a <= 0xFFF9)
            //(PVB TODO) : EXPERIMENTAL : within the OS ROM, shows "A5200 ROM"//
                return [" ", "A5200 ROM"]; //EXPERIMENTAL
            //if (a in the 2KB ROM)
            //ROM CHARSET is $F800 to $FBFF
            //ROM MONITOR is $FC00 to $FFFF
        } 
        else { // for A800
            if (a < 0xD000 || a> 0xDFFF) //ROM
                return _A800syms[memadd];
        }
        //check and display the READ or WRITE symbol and information text
        sym = _A800syms[memadd];
        if (!sym) return sym;
        str1 = sym[0];
        n1 = str1.indexOf("/");
        str2 = sym[1];
        n2 = str2.indexOf("/");
        switch(opc) {
            // following case are "write to OS chips"
            case 0x8C: //STY abs
            case 0x8D: //STA abs
            case 0x8E: //STX abs
            case 0x99: //STA abs,Y
            case 0x9D: //STA abs,X
                // extract write text
                if (n1 > 1) {
                    str1 = str1.slice(n1+1);
                }
                if (n2 > 1) {
                    str2 = str2.slice(n2+1);
                }
                break;
            default:
                // else by default, this is a read from OS chips
                // extract read text
                if (n1 > 1) {
                    str1 = str1.slice(0,n1);
                }
                if (n2 > 1) {
                    str2 = str2.slice(0,n2);
                }
                break;
        }
        sym = [str1, str2];
        return sym;
    }
    //(PVB END OF ADD)

    //(PVB MOD) improvement of disassembleStep() function 
    //previously //function disassembleStep(pc, ram, asm, flags)// so it is added :
    //'lastopcode' for identifying the last opcode matter, and then to stop fetching from the memory
    //so number of remaining bytes to desassemble is given in 'lastopcode' variable (lastopcode is included !)
    //'inner' = true to avoid display of "End of data or max address reached" when it's note the case when reajusting disassembly in dissassemble()
    function disassembleStep(pc, ram, asm, flags, lastopcode, inner) {
        var instr, op1, op2, addr, ops, disas, adm, step;
        var symbol;
        // get instruction and ops, inc PC (PC = program counter)
        
        function u8(i) {
            return ram[i];
        }

        instr = u8(pc);
        addr = hex(pc, 4); //Convert PC into address like '$0A39'
        ops = hex(instr); //Convert the instruction byte into hex like 'A0'
        disin = opctab[instr][0]; //(PVB MOD) opcode instruction like 'LDA'
        disas = ""; //(PVB ADD) variable initialization for operand display string like '#$A0'
        adm = opctab[instr][1]; //(PVB COM) type of opcode instruction like "imm" for immediat
        step = steptab[adm]; //(PVB COM) number of step = number of opcode+operands including the instruction (like 3 for LDA $A039)
        //(PVB MOD) change the validity declaration
        var valid = true;
        var oldstep = step;
        //(PVB ADD) Check the remaining bytes in the data block to disassemble
        var r = lastopcode - pc; // if pc = lastopcode then r == 0; no more data to disassemble, it is OK with Step = 1
        if (step > 1) {
            if (r == 0) {
                op1 = op2 = '..'; //even if op2 not used
                step = 1; // reajust step by forcing opcode = last instruction
            }
            else if ((r == 1) && (step > 2)) {
                op2 = '..';
                step = 2; // // reajust step by forcing opcode & operand n°1 as last instructions
            }
        }
        if (step > 1) op1 = hex(u8(pc + 1)); // (PVB COM) get operand n°1
        if (step > 2) op2 = hex(u8(pc + 2)); //(PVB COM) get operand n°2
        //(PVB ADD) Priority to entry_points identified with a 0x84 flags at PC
        if (oldstep > 1) { // step = 2 or 3;
            if ((flags[pc + 1] & 0x84) == 0x84) { //entry_point flag
                op1 = op2 = '..'; //even if op2 not used
                flags[pc] &= 0xFE; //reset valid bit for a display in disassembly Data Block in case of
                step = 1; //force to last instruction before entry_point
                valid = false;
                }
            else if (oldstep == 3 && ((flags[pc + 2] & 0x84) == 0x84)) { //entry_point flag
                op2 = '..';
                flags[pc] &= 0xFE; //reset valid bit for a display in disassembly Data Block in case of
                step = 2; //force to 2 last instructions before entry_point
                valid = false;
                }
        }
        //(PVB MOD) disas and disin
        // format and output to listing
        switch (adm) {
            case 'imm':
                ops += ' ' + op1 + '   '; // 'ops' string looks like 'EA A0   '
                disas = '#$' + op1;
                break;
            case 'zpg':
                ops += ' ' + op1 + '   ';
                disas = '$' + op1;
                break;
            case 'acc':
                ops += '      ';
                disas = 'A';
                break;
            case 'abs':
                ops += ' ' + op1 + ' ' + op2; // 'ops' string looks like 'EA A0 00'
                disas = '$' + op2 + op1;
                break;
            case 'zpx':
                ops += ' ' + op1 + '   ';
                disas = '$' + op1 + ',X';
                break;
            case 'zpy':
                ops += ' ' + op1 + '   ';
                disas = '$' + op1 + ',Y';
                break;
            case 'abx':
                ops += ' ' + op1 + ' ' + op2;
                disas = '$' + op2 + op1 + ',X';
                break;
            case 'aby':
                ops += ' ' + op1 + ' ' + op2;
                disas = '$' + op2 + op1 + ',Y';
                break;
            case 'iny':
                ops += ' ' + op1 + '   ';
                disas = '($' + op1 + '),Y';
                break;
            case 'inx':
                ops += ' ' + op1 + '   ';
                disas = '($' + op1 + ',X)';
                break;
            case 'rel':
                //(PVB ADD & MOD)
                ops += ' ' + op1 + '   ';
                if (op1 == '..') { //no calculation of target address was possible
                    disas = '$----'; // so display  '$----' as target
                    break;
                }
                //(PVB end of ADD & MOD)
                var opv = u8(pc + 1); //(PVB COM) operand = displacement value
                var targ = pc + 2; //(PVB COM) min target for calculation
                if (opv & 0x80) { //(PVB COM) negative displacement if bit #7 is on
                    targ -= (opv ^ 255) + 1; //(PVB COM) compute the backward displacement = (displacement XOR $FF) + 1
                }
                else { //(PVB COM) forward displacement
                    targ += opv; //(PVB COM) target = jump length
                }
                targ &= 0xffff; //(PVB COM) clipping to 64K boundary
                disas = '$' + hex(targ, 4); // 'disas' string looks like 'BNE $targ' -> 'BNE $A000'
                break;
            case 'ind':
                ops += ' ' + op1 + ' ' + op2;
                disas = '($' + op2 + op1 + ')';
                break;
            case 'imp': //(PVB ADD) guess it was "imp" implied by default
            default: //(PVB ADD) in case of we miss an 'adm' type
                ops += '      '; // no ops string and 'disin' variable will contain the instruction
                break;
        }
        // add symbols
        // (PVB ADD) use the new function get_symbol():
        // - to retreive memory equate symbol for XL, A800, A5200
        // - and for CHIP ROM, make the difference in Sym equate & displayed text if read (R) or if write (W) 
        switch (adm) {
            //zero page address instructions
            case 'zpg':
            case 'zpx':
            case 'zpy':
            case 'inx':
            case 'iny':
                symbol = get_symbol(op1);
                break;
            //normal address instructions
            case 'abs':
            case 'abx':
            case 'aby':
            case 'ind':
                if (op2 == '00') { //in case of 2-byte adress operand is in zero page like 'CMP $0052'
                    symbol = get_symbol(op1);
                }
                else {
                    symbol = get_symbol(op2+op1, instr);
                }
                break;
        }
        if (ops == '')
            ops = '        ';
        //(PVB MOD) change and improve the "valid" management
        //previously // var valid = instr && disas != '???';
        if (disin == '???') valid = false; //disin = disassembled instruction like 'CMP'
        //mark validity, entry and exit points:
        //in the memory flag chart: 
        // 0x01 = opcode is valid
        // 0x02 = "BRK" opcode (PVB ADD)
        // 0x04 = entry_point, with 0x80 = 0x84 (PVB ADD)
        // + 0x08 = end of block => request empty line after after block
        // 0x10 = "RTS" opcode
        // 0x20 = "RTI" opcode
        // 0x40 = "JMP" opcode
        // + 0x80 = start of block => request empty line before - target of relative instruction (BEQ..) are flagged with 0x80 to start a new bloc
        //(PVB MOD) mark validity in flags improvment as described below
        if (valid) { 
            for (var i = 0; i < step; i++){
                flags[i + pc] |= 1;    // valid code
            }
            var a = (step > 2) ? (ram[pc + 1] + (ram[pc + 2] << 8)) : -1; //a = destination address, -1 if not valid (in case of end-of-file was reached)
            switch (instr) {
                case 0x20: // jsr JSR
                    //check validity of destination address
                    if ((a >= 0) && (opctab[u8(a)][0] != '???')) { //instruction at target is valid (zero is valid because somewhere in the memory but not loaded at that time),
                        if ((r > 2) && (opctab[u8(pc+3)][0] != '???')) //if there is remaining code to dissassemble && next instruction after JSR is valid
                            flags[a] |= 0x81; //target is validated
                    }
                    break; 
                case 0x4C: // jump JMP
                    //check validity of destination address
                    if (a >= 0 && opctab[u8(a)][0] != '???') { //instruction at target is valid (zero is valid)
                        flags[a] |= 0x81; //target is validated
                    }
                    flags[pc] |= 0x48; // + 0x08 jump a ligne after
                    break;
                case 0x6C:  //JMP (indirect)
                    a = -1; //no destination since it's an indirect, like JMP (DOSINI) => DOSINI is not the destination address, but its content yes
                    flags[pc] |= 0x48; // + 0x08 jump a ligne after
                    break;
                case 0x40: flags[pc] |= 0x28; a = -1; break; // rti // + 0x08 jump a ligne after
                case 0x60: flags[pc] |= 0x18; a = -1; break; // rts // + 0x08 jump a ligne after
                case 0x00: flags[pc] |= 0x02; a = -1; break; // brk instruction
                default:
                    a = -1;
            }
            // (PVB ADD) create hyperlink to destination and display in bold if OPTION '_bShowDisLinks' is true
            if (_bShowDisLinks)
                if (a != -1) { //for JMP & JSR if destination 'a' is valid
                    disin = '<b>' + disin;
                    disas = '<a href="#PCB' + _nBankId + '$' + hex(a,4) + '">' + disas + '</a></b>';
                }
                else {
                    if (flags[pc] & 0x08) { //make it display in bold for RTS, RTI et JMP (ADD)
                        disin = '<b>' + disin;
                        disas = disas + '</b>';
                    }
                }
            // (PVB ADD) handle the 'rel' instruction (BEQ, BNE, Bxx...) validity and target validity
            if (adm == 'rel' && step > 1) { //if step == 1, there was no operand because end of file was reached, so no check exit 'if' statement
                //by default, invalid the 'rel' instruction, and seek and set validity...
                flags[pc] &= 0xFE;
                flags[pc+1] &= 0xFE;
                valid = false;
                var c = false;
                while (true) { //there nothing like an infinite loop to break ;-)
                    if ((pc != 0) && !(flags[pc-1] & 0x01)) break; // previous is not valid (seen if the flag) => exit
                    //check the next instruction validity
                    if (flags[pc] & 0x08) { //if there is already a flag set, it means we are at the second 'rel' in the pair like BEQ/BNE
                        c = true; //so 'rel' is valid
                        break; //and exit without any other verification
                    } 
                    if (pc > 0xFFFD) break; // if so, checking of the next instruction at pc+2 is not possible, so exit
                    if (ram[pc+2] == ram[pc]) break; // next is the same 'rel' instruction, like BNE xx BNE xx, we assume not possible, exit
                    if ((pc > 1) && ((ram[pc-2] == 0xA9) || (ram[pc-2] == 0xA0) || (ram[pc-2] == 0xA2))) {
                        //the previous instruction is a load imm like LDA #$00, the load imm sets the 'rel' status
                        flags[pc] |= 0x08; //valid 'rel' jump => so we set the flag for a line feed to create a bloc before
                    } //(PVB TODO) we could validate the same with "store" & "transfer" instruction, and 6502 flag set instruction like SEC/BCS & CLC/BCC
                    if (opctab[u8(pc + 2)][0] == '???') break; // if the next instruction at PC+2 is unknown => exit
                    if (!_bShowDisBRK && opctab[u8(pc + 2)][0] == 'BRK') break; //if the next instruction at PC+2 is BRK instruction => exit
                    //note : same as "if (!_bShowDisBRK && !ram[pc+2])"
                    if (!c && (opctab[u8(pc + 2)][1] == 'rel') && ((ram[pc] & 0xC0) == (ram[pc+2] & 0xC0))) { //check i's a pair with the next instruction like BEQ/BNE
                        //for a pair, 'rel' have same bits #7 #6 (0xC0), they only differ on bit #5, remaining bits are always 0x10.
                        flags[pc + 2] |= 0x08; //valid 'rel' jump pair => so we set the flag for a line feed to create a bloc
                    }
                    //at this point we have a valid 'rel' instruction, next instruction is OK (or it is a BRK that is accepted)
                    //or next is not OK but 'rel' is OK thanks to previous instruction like in "LDA #$00 BEQ XXX"
                    //or next instruction is also a 'rel' pair like BEQ/BNE..
                    c = true; //so set 'rel' as a valid instruction
                    break; //and exit loop
                }      
                //and now, let's check the target...
                if ((c && (opctab[u8(targ)][0] == '???') || (!_bShowDisBRK && !ram[targ]))) {
                    //if instruction at target is unknown or is equal to zero (BRK) memory not accepted)
                    c = false; //'rel' is no more valid
                }
                if (c) { //validation of 'rel' instruction if c = true
                    flags[targ] |= 0x81; // target set to valid
                    if (_bShowDisLinks) {
                        disas = '<a href="#PCB' + _nBankId + '$' + hex(targ,4) + '">' + disas + '</a>'; //create hyperlink to destination
                    }
                    flags[pc] |= 1;
                    flags[pc+1] |= 1;
                    valid = true;
                }   
            } 
        }
        //(PVB ADD) mark the end of disassembly
        if ((valid && (op1 == ".." || op2 == ".."))) {
            flags[pc] &= 0xFE;
            valid = false;
            if (!inner)
                disas += ' <span style="color:red;">[!End of data or max address reached!]</span>';
        }
        //(PVB ADD) Add the ROM bank number id for ROM disassembly
        if (_bShowROMBank && _nBankId)
            addr = "B" + _nBankId + ":" + addr;
        // then finaly make the asm listing
        asm.push({
            pc: pc, step: step, valid: valid,
            s: addr + '   ' + ops + '   ' + disin + ' ' + disas + (symbol ? " ; " + symbol[0] + (symbol[1] ? (" <i>" + " >" + symbol[1] + "</i>") : "") : "")
         });
        return (pc + step);
    }

    //  First disassembly pass
    //(PVB MOD) improvement of disassemble() function 
    function disassemble(addr, data, i, len, ram, flags) {
        //(PVB COM) "addr" = disassembly start address, "data" = data to disassemble (bytes array), "len" = number of bytes to disassemble 
        //array of variables : "ram" byte array that is the 64KB Atari memory (0-$FFFF) where data are copied, and corresponding byte array of "flags"
        var asm = []; //asm is the disassembly result (string of text)
        //(PVB ADD) add a protection in order not to overpass the 0xFFFF in the "ram" byte array !
        if ((addr + len) > 0x10000) { //len + start address should not be greater than 0xFFFF otherwise there is a bug
            len = 0x10000 - addr; //if it is the case, len is decreased (clipped) to max 64K memory = 0xFFFF
            console.log("disassemble() => has limited the lenght of bloc to disassemble for not overpass 0xFFFF");
        }
        //(PVB end of ADD)
        for (var j = 0; j < len; j++) //(PVB COM) 'data[]' are stored in the corresponding 'ram[]' 64K buffer at the real starting address
            ram[addr + j] = data[i + j];
        var pc = addr;
        var lastopcode =  addr + len; //(PVB ADD) Adde the 'lastopcode' variable feature for handling the last opcode issue to stop fetching from the memory, 
        while (pc < lastopcode) {
            //(PVB MOD) pc = lastopcode for the last instruction byte
            pc = disassembleStep(pc, ram, asm, flags, lastopcode-1, false); //inner = false
        }
        return asm;
    }
    
    // Two pass: disassembly then basic blocks
    //(PVB MOD) improvement of disassemble2() function
    function disassemble2(asm, str, ram, flags) {
        var start = 0xFFFF; //overall of asm
        var end = 0;        //overall of asm
        var blocks = [];
        var block = { lines: [], errs: 0, bll: 0 };
        var nbrk = 0;
        var _sh = false; // valid the console.log() DISASSEMBLE HINT display in the console

        //(PVB MOD) initialization of the "asm" array
        function asmlist_add_flags(asmlist) {
            asmlist.forEach(a => { // for each desassembly lines
                a.flags = flags[a.pc];
                start = Math.min(start, a.pc);
                end = Math.max(end, a.pc + a.step); //(PVB MOD)
                if (_bShowDisFlags)
                    a.s = "["+ hex(a.flags) + "]" + a.s; //(PVB COM) show the flag for each line
            });
        }

        function separator() {
        if (str[str.length - 1] == "")
                return;
            str.push("");
        }

        function end_of_lines(lines) {
            return lines[lines.length - 1].pc + lines[lines.length - 1].step;
        }

        function runny(lines) {
            if (lines === undefined)
                return false;
            if (!lines[0].pc)
                console.log("Huston we've got a problem: !lines[0].pc == true");
            var start = lines[0].pc;
            var end = end_of_lines(lines); //end is not included (end is the 1st instruction of next bloc)
            if ((end - start) < 4) //(PVB MOD) runny lines is considered above 3 instructions (i.e. 4C 4C4C is valid within a bloc)
                return;
            for (var i = start + 1; i < end; i++)
                if (ram[start] != ram[i])
                    return false;
            return true;    // All data is the same value in all the lines
        }

        function as_data(blocks) { //(PVB) "Show as Code" = as data
            var from = blocks[0].lines[0].pc;
            var to = end_of_lines(blocks[blocks.length - 1].lines);
            var di = to - from; //(PVB ADD) to simplify

            var key = hex(from, 4);
            str.push(`; Data bloc of $${di.toString(16).toUpperCase()} (${di}) bytes at $${key}:${hex(to - 1, 4)}<em class='showcode' onclick='toggle("#_${key}")'>Show As Code</em>`);
            //  stick all the code in too
            str.push(`<div id='_${key}' style='color:#00F;display:none'>;`); //(PVB MOD) color set to blue instead of red
            blocks.forEach(block => block.lines.forEach(line => str.push(line.s)));
            str.push(`</div>;`);

            while (from < to) {
                var mx = 16 - (from & 0xF);
                var n = Math.min(mx, to - from);
                str.push(hex_line(from, ram, from, n, 4));
                from += n;
            }
            str.push(";");
            separator(); //line feed in the disassembly
        }

        // slice into blocks, mark those
        function flush_block() {
            //(PVB COM) create a block
            if (block.lines.length) {
                block.bll = block.lines.length;
                blocks.push(block);   
            }
            block = { lines: [], errs: 0, bll: 0}; //and initialize new empty block
        }
        //(PVB ADD)
        function make_disas_anchor(a) {
            if ((a.flags & 0x01) && _bShowDisLinks) {
                a.s = a.s.replace(' ', ' </strong>');
                a.s = '<strong id="PCB' + _nBankId + '$' + hex(a.pc,4) + '">' + a.s; //create destination HTML anchor for disassembly address hyperlinks
            }
        }
        //(PVB END OF ADD)
        
        //(PVB MOD & ADD) disassemble2() starts now here
        asmlist_add_flags(asm);
        nbrk = 0;
        asm.forEach(a => {
            //(PVB ADD) add a tolerance of 2 errors when this is a BRK instruction if _bShowDisBRK
            if (a.flags & 0x02) { //BRK instruction
                if (_bShowDisBRK && (nbrk < 3)) {
                    nbrk++;
                }
                else {
                    block.errs++;
                    nbrk = 0;
                }     
            }
            //else { //else activated = BRK can not be a jump Target
                if (a.flags & 0x80) { //if the asm listing encounter a 0x80 then create a new block
                    make_disas_anchor(a);
                    if (a.flags & 0x04) //if 0x84 then this is an entry point
                        a.s = ";<i><b>[Entry_Point]</i></b><br />"+ a.s;
                    flush_block(); //creat new block starting with 0x81
                }
            //}
            block.lines.push(a); //put asm listing in a new block lines

            if (!a.valid)
                block.errs++; //(PVB COM) err++ counts the number of error in the block, that is the number of "valid = false"
            
            //if the asm listing encounter a 0x08 then create a new block
            if ((a.flags & 0x08) && !block.errs)
                flush_block();
        });

        flush_block(); // the last block is created
        separator(); //line feed in the disassembly
        
        // determine if each block is ASM or DATA

        //(PVB MOD) block analysis and adjust disassembly listing if needed
        var tmpb = [];
        var blen, pcmax, pcmin;
        var b = 0;
        var b2;
        var f = 0;
        var lb, nbe, pbe;

        //check each 'b' blocks for validity set in the above "asm.forEach" loop
        for (b = 0; b < blocks.length; b++) { //for each block in blocks
            if (runny(blocks[b].lines)) {
                blocks[b].errs = 1; //RULE : the current block shall not contain the same bytes value
            }
            //if (b > 0 && b < (blocks.length - 1)) { //not the first block, neither the last => replaced by 'lb'
            lb = (b == (blocks.length - 1)) ? true : false;
            if (b > 0) pbe = blocks[b - 1].errs ? true : false; else pbe = false;
            if (!lb) nbe = blocks[b + 1].errs ? true : false; else nbe = false;
            //checking validity of blocks...
            while (true) { // there is nothing like a while(true) loop to avoid chaining the if/else...
                ///break;
                tmpb = blocks[b]; //copy of current block
                if (!tmpb.bll) {
                    if (_sh) console.log("Skipping block b=" + b + " that is empty...");
                    break; //if empty block then exit the loop (and go to next block)
                }
                if (tmpb.errs) {
                    //if (_sh) console.log("Skipping block b=" + b + " that has " + tmpb.errs + " errors...");
                    break; //if non valid block then exit the loop (and go to next block)
                }
                if (!nbe && !pbe) {
                    //if (_sh) console.log("Skipping block b=" + b + " that has no error, like next and previous");
                    break; //exit the loop (and go to next block)
                }
                blen = tmpb.lines.length; //block number of lines
                f = tmpb.lines[0].flags;
                if (blen != tmpb.bll) console.log("Huston we've got a problem: blen != tmpb.bll");
               
                if (_sh) console.log("!>Chekking block b=" + b + ", errs=" + tmpb.errs + ", lines length=" + tmpb.lines.length + ", PC=" + hex(tmpb.lines[0].pc,4));

                if (blen == 1) { // RULE for a single line block //
                    if (_sh) console.log(" ...one line checking...");
                    //RULE: if a block is a valid one-line instruction, before an invalid block [nbe],
                    //it must be the end of block, hence containing the 0x08 flag (JMP, RTI, RTS, BXX pair) => otherwise invalid current block
                    if (nbe && !(f & 0x08)) { //if next block invalid && the single block is not "a end of block" like JMP, RTI, RTS, BXX couple
                        tmpb.errs = 1;
                        if (_sh) console.log(" --1- >>single line block before invalid block shall end with JMP, RTI, RTS or Bxx pair!")
                        if (!pbe && b > 0) { //if previous was valid...
                            b = b - 2; // re-check previous bloc by decreasing b (-2 because the for loop increase by 1)
                        }
                        break;
                    }
                    //RULE: if the one-line valid block containing a single RTI, RTS ou JMP (that is a 0x70)
                    // => cannot be after an invalid bloc [pbe] (except if containing the 0x80 flag)
                    // => cannot follow a valid bloc that already ends with RTI, RTS instruction (that is a 0x30) (except if containing the 0x80 flag)
                    if ((f & 0x70) && !(f & 0x80)) { //the single line is RTS, RTI, JMP; and does not contain a 0x80 flag
                        if (pbe) { //if previous block is not valid
                            tmpb.errs = 1; //then block not valid
                            if (_sh) console.log(" --2- >>cannot have a single line RTS/RTI/JMP without 0x80 flag after invalid block!");
                            break;
                        }
                        else { // if previous block is valid
                            if ((b>0) && (blocks[b - 1].lines[(blocks[b - 1].lines.length - 1)].flags & 0x30)) { //if previous block also ends with RTS or RTI
                                tmpb.errs = 1; //then block not valid
                                if (_sh) console.log(" --3- >>cannot have a single line RTS/RTI/JMP without 0x80 flag after a block ending with RTS/RTI/JMP!");
                                if (!pbe && b>0) { //if previous was valid...
                                    b = b - 2; // re-check previous bloc by decreasing b (-2 because the for loop increase by 1)
                                }
                                break;
                            }
                        }
                    }
                    //RULE: the one-line valid block cannot have the same instruction as the previous block
                    if (b>0 && pbe) { //if previous block is not valid
                        var s0 = tmpb.lines[0].s.substring((tmpb.lines[0].s.indexOf('  ')))
                        var s1 = blocks[b-1].lines[0].s.substring((blocks[b-1].lines[0].s.indexOf('  ')));
                        if (s0 && s1 && (s0 == s1)) { //the single ligne is same as the previous (instruction & operands)
                            tmpb.errs = 1; //then block not valid
                            if (_sh) console.log(" --4- >>2 lines of instruction identical found!");
                            break;
                        }
                    }
                    break;    
                }//END OF RULE for a single line block

                //RULE for normal current valid & previous invalid
                if (pbe && !(f & 0x81 == 0x81)) { //if no 0x81 flag at the beginning of bloc, then invalidate
                    tmpb.errs = 1;
                    if (_sh) console.log(" --5- => current block shall start with valid 0x81 flag when previous is not valid")
                    break;
                }
                //RULE for normal current valid, next invalid and last line of current valid block not ending with 0x08
                var r = false;
                if (!lb)
                    r = runny(blocks[b+1].lines);
                if ((r || nbe) && !(tmpb.lines[(blen-1)].flags & 0x08)) {
                    tmpb.errs = 1;
                    if (_sh) console.log(" --6- => cannot have a next bloc invalid and current block not ending with RTS/RTI/JMP 0x08 flag")
                    if (!pbe && b>0) { //if previous was valid...
                        b = b - 2; // re-check previous bloc by decreasing b (-2 because the for loop increase by 1)
                    }
                    break;
                }
                
                if (_sh) console.log("  => end of block " + b + " verification---");
                break; //security
            } //end Of while(true) for checking validity of blocks...
        } //enf of 'for' loop for all blocks  

        //Routine for Searching for 0x80 flags in previous unvalid block, and rajust disassembly blocs
        for (b = 1; b < blocks.length; b++) { //for each block in blocks starting at block #1
            //if current block is valid, but previous is not, then
            //seek the 0x81 hidden flag in the previous and if needed reajust block disassembly
            pbe = blocks[b - 1].errs ? true : false;
            b2 = b; //save b in b2
            if (!blocks[b].errs && pbe) { //RULE for current valid block && previous invalid;
                tmpb = blocks[b-1]; //tmpb = previous

                var pc, i, pc_flag, b2;
                var errs, ite = 0;
                var tmpasm =[];
                var m = false;

                blen = tmpb.lines.length
                pcmax = tmpb.lines[blen - 1].pc + tmpb.lines[blen - 1].step; //pcmax not included, it is the pc of next block
                pcmin = tmpb.lines[0].pc;
                while (true) { // as long as we find 0x80 flags in the non-valid current block
                    if (!blen) break; //protection just in case
                    ite ++;
                    if (_sh) console.log("!>Seek 0x80 flags in previous Block b-1=" + (b-1) + " of "+ blocks.length + ", line len=" + blen + ", iteration #" + ite + ", PC=" + hex(pcmin,4) + "-" + hex(pcmax,4));
                    //search a hidden 0x81 from the end of block
                    if (m) //if m then a first one has been found but was wrong
                        i = pc_flag - 1;
                    else
                        i = pcmax - 1 ; //i is set to PcMax of the block
                    m = false; //reset
                    while (i > pcmin) {
                        if (flags[i] & 0x80) {
                        //if ((flags[i] & 0x81) == 0x81) {
                            pc_flag = i;
                            m = true;
                            break; // exit the "while" loop
                        }
                    i--;
                    }
                    if (!m) {
                        if (_sh) console.log("  >>Nothing found !");
                        break;
                    } // flag 0x81 not find, so exi0 &&
                    tmpasm =[];
                    pc = i;
                    while (pc < pcmax) {
                        pc = disassembleStep(pc, ram, tmpasm, flags, pcmax-1, true);
                    }
                    if (pc != pcmax) { // disassembly does not match the current disassembly, so exit the while (true) loop!
                        if (_sh) console.log("  >>but no recovery with current block b=" + b + " ! ..continue..");
                        continue;
                        //break;
                    } 
                    //prepare new asm list and check the validity (errs)
                    errs = 0;
                    tmpasm.forEach(a => {
                        a.flags = flags[a.pc];
                        if (_bShowDisFlags)
                            a.s = "[" + hex(a.flags) + "]" + a.s;
                        if (a.flags & 0x80)
                            make_disas_anchor(a);
                        if (!a.valid)
                            errs++;
                    });
                    if (errs) {
                        if (_sh) console.log("  >>but previous Block b-1=" + (b-1) + " has errors! ..continue..");
                        // if there is non-valid in the disassembly, return to the beginnning of loop to find another 0x81
                        continue; 
                    }
                    if (_sh) {
                        console.log("  >>Previous Block b-1=" + (b-1) + " making OK >>tmplines :");
                        console.log(tmpasm);
                    }
                    //push new valid bloc into the blocks list at next position
                    blocks.splice(b, 0, {lines: tmpasm, errs: 0, bll: tmpasm.length});
                    b2++; //index of the current bloc is +1
                    if (_sh) console.log("  >>Block b=" + b + " created in the block chart !!, Nbr of blocks=" + blocks.length);
        
                    // reajust the first part of the current block (before the found 0x81)
                    pc = pcmin; //pc for the 1st line
                    tmpasm = []; //reset
                    while (pc < pc_flag) {
                        pc = disassembleStep(pc, ram, tmpasm, flags, pc_flag-1, true);
                    }
                    errs = 0;
                    tmpasm.forEach(a => {
                        a.flags = flags[a.pc];
                        if (_bShowDisFlags)
                            a.s = "[" + hex(a.flags) + "]" + a.s;
                        if (!a.valid)
                             errs++;
                    });
                    blocks[b-1].lines = tmpasm;
                    blocks[b-1].errs = errs;
                    blocks[b-1].bll = blocks[b-1].lines.length;
                    
                    //adjust the block
                    tmpb = blocks[b-1]; //copy of current block
                    blen = tmpb.lines.length;
                    if (!blen) break;
                    pcmax = tmpb.lines[blen - 1].pc + tmpb.lines[blen - 1].step;
                    m = false; // to analyse new remaining block
                    //back to the beginning of the while(true) loop
                }
                b = b2; //update bloc pointer after having add the previous blocs
            }
        }//end of for loop

        // determine if each block is ASM or DATA
        var first_code = true;
        separator();
        var data = [];
        if (_sh) console.log("!>making block of Data");
        blocks.forEach(block => {
            if (block.errs || runny(block.lines)) {
                data.push(block);           // start of data
            } else {
                if (first_code) {
                    str.push("; <b>Disassembly listing from $" + hex(start, 4) + " to $" + hex(end - 1, 4) + ":</b>\n");
                    first_code = false;
                }
                if (data.length) {
                    as_data(data);    // end of data
                    data = [];
                }
                block.lines.forEach(a => str.push(a.s));
            }
            separator();
        });
        if (_sh) console.log("  => end of block of Data making!");
        if (data.length)
            as_data(data);
        separator();
    }

    // eof

    //===================================================================================================
    //===================================================================================================

    function le16(a, i) {
        return a[i] | ((a[i + 1]) << 8);
    }

    function le24(a, i) {
        return a[i] | ((a[i + 1]) << 8) | ((a[i + 2]) << 16);
    }

    function le32(a, i) {
        return a[i] | ((a[i + 1]) << 8) | ((a[i + 2]) << 16) | ((a[i + 3]) << 24);
    }

    function is_zero(d, i, len) {
        while (len--)
            if (d[i++])
                return false;
        return true;
    }

    function toAscii(a, i, len) {
        var s = '';
        while (len--)
            s += String.fromCharCode(a[i++] & 0x7F); //(PVB MOD) add the 0x7F mask to force the inverted Atari char into normal ($80-$FF => $00-$7F)
        return s;
    }
    
    //(PVB ADD)
    function isAtariNameChar(str, md) { //isAtariText // valid filename char are 'space' 0-9 A-Z a-z
    // plus '@' and '_' for myDos fileName
        for (var i = 0; i < str.length; i++) {
            var c = str[i];
            if (!((c >= 0x30 && c <= 0x39) || (c >= 0x41 && c <= 0x5A) || (c >= 0x61 && c <= 0x7A))) //not OK if not alphabet
                if (!(c == 0x20)) //not OK if not 'space'
                    if (!(md && (c == 0x40 || c == 0x5F))) //note OK if not '@' or '_' (for myDos fileName)
                        return false; //exit because char not OK
        }
        return true;
    }
    //(PVB END OF ADD)

    function err(e) {
        _m("#err", "#toc", { err: e });
    }

    function ataritext(a) {
        var s = '';
        var lst = [];
        for (var i = 0; i < a.length; i++) {
            if (a[i] == 0x9B) {
                lst.push(s);
                s = '';
            } else
                s += String.fromCharCode(a[i]);
        }
        if (s.length)
            lst.push(s);
        return lst;
    }

    function parse_failed(f) {
        return [`Can't parse ${f.name} as a ${f.ext} file`]; //'
    }

    function show_m65(f) {
        var asm = mac65(f.data, 0, f.data.length);
        // expand tabs?
        show_ataritext(f, asm ? asm : parse_failed(f));
    }

    function show_bas(f) {
        var t = ataribasic(f.data, 0, f.data.length);
        show_ataritext(f, t ? t.listing : parse_failed(f));
    }

    function show_txt(f) {
        var t = ataritext(f.data, 0, f.data.length);
        show_ataritext(f, t);
    }

    // 160*192 2 bit + [4 byte palette]
    function show_img(f) {
        render_file(f);
        var c = _q("#show");
        var aspect = render_image(c, f);
        resize_parent(c, aspect[0], aspect[1]);
    }

    // https://github.com/TheRobotFactory/EightBit-Atari-Fonts
    function show_fnt(f) {
        var pal = _reload_palette ? [0, 5, 10, 15] : _palette.slice();
        var multicolor = _checks['multicolor'];

        function fnt(n, len) {
            var space = (n & 0x80) ? String.fromCharCode(128 + 32) : ' ';
            var s = space;
            for (var i = 0; i < len; i++)
                s += String.fromCharCode(n + i);
            return s + space;
        }
        var inverted = '';
        for (var i = 0; i < 34; i++)
            inverted += String.fromCharCode(32 + 128);

        var t = [];
        t.push("");
        t.push(fnt(32, 32)); t.push("");
        t.push(fnt(64, 32)); t.push("");
        t.push(fnt(0, 32)); t.push("");
        t.push(fnt(96, 32)); t.push("");
        t.push(inverted);
        t.push(fnt(32 + 128, 32)); t.push(inverted);
        t.push(fnt(64 + 128, 32)); t.push(inverted);
        t.push(fnt(0 + 128, 32)); t.push(inverted);
        t.push(fnt(96 + 128, 32)); t.push(inverted);
        var s = [
            "",
            "YOU ARE IN A MAZE OF TWISTY",
            "LITTLE PASSAGES, ALL ALIKE.",
            "",
            " - Crowther & Woods",
            "",
            "",
            "Never argue with an idiot.",
            "They will drag you down to their",
            "level and beat you with",
            "experience.",
            "",
            " - Mark Twain",
            "",
            "",
            "Nobody ever figures out what",
            "life is all about, and it doesn't",
            "matter. Explore the world. Nearly",
            "everything is really interesting",
            "if you go into it deeply enough.",
            "",
            " - Richard P. Feynman",
            "",
        ];
        s.forEach(line => t.push(' ' + line));
        t.push("");
        show_font(f, t, f.data, multicolor ? _palette : null);
    }

    //(PVB MOD) update the list of possible extensions
    var _exts = {
        "atr": { name: "ATR Disk Image", is_disk: true },
        "atx": { name: "ATX Disk Image", is_disk: true },
        "pro": { name: "PRO Disk Image", is_disk: true },
        "xfd": { name: "XFD Disk Image", is_disk: true },
        "dsk": { name: "Raw Sectors for Disk Image File", is_disk: true }, //(PVB MOD)
        "dat": { name: "Raw Data or DAT Image File (default)", is_dat: true }, //(PVB MOD)
        "arc": { name: "ARC Archive of Image File"},

        "--0": { name: "Languages (formated text files)" }, //(PVB MOD)
        "bas": { name: "Atari Basic/Turbo Basic XL", is_txt: true },
        "lst": { name: "Atari Basic Listing", is_txt: true },
        "asm": { name: "Assembly Listing", is_txt: true },
        "m65": { name: "MAC/65 Assembly Listing", is_txt: true },
        "lis": { name: "Listing", is_txt: true },
        "doc": { name: "Document", is_txt: true },
        "ata": { name: "ATASCII Text File", is_txt: true },
        "txt": { name: "Text File", is_txt: true },
        "bat": { name: "Batch File", is_txt: true },
        "man": { name: "Manual", is_txt: true },

        "--1": { name: "Font & Graphics" },
        "fnt": { name: "Font File", is_txt: true, font_set: true },
        "set": { name: "Font File", is_txt: true, font_set: true },

        "gr7": { name: "Graphics 7 Image", is_img: true },
        "gr8": { name: "Graphics 8 Image", is_img: true },
        "gr9": { name: "Graphics 9 Image", is_img: true },
        "g10": { name: "Graphics 10 Image", is_img: true },

        "mic": { name: "Micropainter Image", is_img: true },
        "mcp": { name: "McPainter/Paradox Image", is_img: true },
        "apc": { name: "APAC 256 Color Image", is_img: true },
        "plm": { name: "Plasma 256 Color Image", is_img: true },
        "pzm": { name: "Pryzm Artist Image", is_img: true },
        "ilc": { name: "Digi Paint Image", is_img: true },
        "inp": { name: "InterPainter Image", is_img: true },
        "cin": { name: "Champions' Interlace", is_img: true },
        "pic": { name: "Koala MicroIllustrator", is_img: true },
        "raw": { name: "XL-Paint MAX Image", is_img: true },
        "scr": { name: "Atari Graphics Works Image", is_img: true },
        "ist": { name: "Interlace Studio Image", is_img: true },
        "rip": { name: "Rocky Interlace Picture", is_img: true },
        "hip": { name: "Hard Interlace Picture", is_img: true },
        "tip": { name: "Taquart Interlace Picture", is_img: true },

        "--2": { name: "Executables Atari DOS Files & Dumps" }, //(PVB MOD) here file are "code" an not "text"
        "sys": { name: "DOS System file", is_code: true, has_header: true }, //(PVB MOD) special file from DOS, they have header, except DOS.SYS
        "obj": { name: "Object Code", is_code: true }, //(PVB MOD) normaly has an header 0xFFFF
        "xex": { name: "Load and Go Executable", is_code: true, has_header: true }, //(PVB MOD) normaly has an header 0xFFFF
        "exe": { name: "Load and Go Executable", is_code: true, has_header: true }, //(PVB MOD) normaly has an header 0xFFFF
        "com": { name: "Load and Go Executable", is_code: true, has_header: true }, //(PVB MOD) normaly has an header 0xFFFF
        "car": { name: "Cartridge File with header", is_code: true, is_romdump: true }, //(PVB MOD) add the is_romdump for the ROM dump
        "rom": { name: "ROM Dump File", is_code: true, is_romdump: true }, //(PVB MOD) Never seen a ROM dump file in DOS File ?
        "bin": { name: "Atari Raw Binary Dump File", is_code: true, is_romdump: true }, //(PVB MOD) never seen a BIN in a DOS File ?
        "a52": { name: "Atari 5200 Rom Dump File", is_code: true, is_romdump: true }, //(PVB MOD) never seen an a52 in a DOS File ?
    };
    
    //(PVB ADD) Added the ROM Types table from
    //https://github.com/dmlloyd/atari800/blob/master/DOC/cart.txt
    //https://github.com/atari800/atari800/blob/master/DOC/cart.txt
    var _romtypes = {
        "Type_##" : {machine : "on Machine...", size : "Size in KB...", name : "Cart name..."}, //memmap: [size (in page HB), start address (in page HB), number of bank at same address]
        "Type_00" : {machine : "Unknown", size : "0", name : "Unknown CART cartridge", memmap : [0, 0, 0]},
        "Type_01" : {machine : "800/XL/XE", size : "8", name : "Standard 8 KB cartridge", memmap : [0x20, 0xA0, 1]},
        "Type_02" : {machine : "800/XL/XE", size : "16", name : "Standard 16 KB cartridge", memmap : [0x40, 0x80, 1]},
        "Type_03" : {machine : "800/XL/XE", size : "16", name : "OSS two chip 16 KB cartridge (034M)", memmap : [0x10, 0xA0, 3, 0x10, 0xB0, 1]},
        "Type_04" : {machine : "5200", size : "32", name : "Standard 32 KB 5200 cartridge", memmap : [0x80, 0x40, 1]},
        "Type_05" : {machine : "800/XL/XE", size : "32", name : "DB 32 KB cartridge", memmap : [0x20, 0x80, 3, 0x20, 0xA0, 1]},
        "Type_06" : {machine : "5200", size : "16", name : "Two chip 16 KB 5200 cartridge", memmap : [0x20, 0x60, 1, 0x20, 0xA0, 1]}, //todo : handle copie bank (address duplicate)
        "Type_07" : {machine : "5200", size : "40", name : "Bounty Bob Strikes Back 40 KB 5200 cartridge", memmap : [0x10, 0x40, 4, 0x10, 0x50, 4, 0x20, 0xA0, 1]}, //todo : handle copie bank (address duplicate)
        //It exists an alternate Type_07 in Altirra : "Same as cart mapper 7 except that the fixed bank is first" as per Altirra sources "cartridgetypes.h"; that would be :
        //"Type_07" : {machine : "5200", size : "40", name : "Bounty Bob Strikes Back 40 KB 5200 cartridge (Alt Layout)", memmap : [0x20, 0xA0, 1, 0x10, 0x40, 4, 0x10, 0x50, 4]},
        "Type_08" : {machine : "800/XL/XE", size : "64", name : "64 KB Williams cartridge", memmap : [0x20, 0xA0, 8]},
        "Type_09" : {machine : "800/XL/XE", size : "64", name : "Express 64 KB cartridge", memmap : [0x20, 0xA0, 8]},
        "Type_10" : {machine : "800/XL/XE", size : "64", name : "Diamond 64 KB cartridge", memmap : [0x20, 0xA0, 8]},
        "Type_11" : {machine : "800/XL/XE", size : "64", name : "SpartaDOS X 64 KB cartridge", memmap : [0x20, 0xA0, 8]},
        "Type_12" : {machine : "800/XL/XE", size : "32", name : "XEGS 32 KB cartridge", memmap : [0x20, 0x80, 3, 0x20, 0xA0, 1]},
        "Type_13" : {machine : "800/XL/XE", size : "64", name : "XEGS 64 KB cartridge", memmap : [0x20, 0x80, 7, 0x20, 0xA0, 1]},
        "Type_14" : {machine : "800/XL/XE", size : "128", name : "XEGS 128 KB cartridge", memmap : [0x20, 0x80, 15, 0x20, 0xA0, 1]},
        "Type_15" : {machine : "800/XL/XE", size : "16", name : "OSS one chip 16 KB cartridge", memmap : [0x10, 0xB0, 1, 0x10, 0xA0, 3]},
        "Type_16" : {machine : "5200", size : "16", name : "One chip 16 KB 5200 cartridge", memmap : [0x40, 0x80, 1]},
        "Type_17" : {machine : "800/XL/XE", size : "128", name : "(decoded) Atrax 128 KB cartridge", memmap : [0x20, 0xA0, 16]},
        "Type_18" : {machine : "800/XL/XE", size : "40", name : "Bounty Bob Strikes Back 40 KB cartridge", memmap : [0x10, 0x80, 4, 0x10, 0x90, 4, 0x20, 0xA0, 1]},
        "Type_19" : {machine : "5200", size : "8", name : "Standard 8 KB 5200 cartridge", memmap : [0x20, 0xA0, 1]},
        "Type_20" : {machine : "5200", size : "4", name : "Standard 4 KB 5200 cartridge", memmap : [0x10, 0xB0, 1]},
        "Type_21" : {machine : "800", size : "8", name : "Right slot 8 KB cartridge", memmap : [0x20, 0x80, 1]},
        "Type_22" : {machine : "800/XL/XE", size : "32", name : "32 KB Williams cartridge", memmap : [0x20, 0xA0, 4]},
        "Type_23" : {machine : "800/XL/XE", size : "256", name : "XEGS 256 KB cartridge", memmap : [0x20, 0x80, 31, 0x20, 0xA0, 1]},
        "Type_24" : {machine : "800/XL/XE", size : "512", name : "XEGS 512 KB cartridge", memmap : [0x20, 0x80, 63, 0x20, 0xA0, 1]},
        "Type_25" : {machine : "800/XL/XE", size : "1024", name : "XEGS 1 MB cartridge", memmap : [0x20, 0x80, 127, 0x20, 0xA0, 1]},
        "Type_26" : {machine : "800/XL/XE", size : "16", name : "MegaCart 16 KB cartridge", memmap : [0x40, 0x80, 1]},
        "Type_27" : {machine : "800/XL/XE", size : "32", name : "MegaCart 32 KB cartridge", memmap : [0x40, 0x80, 2]},
        "Type_28" : {machine : "800/XL/XE", size : "64", name : "MegaCart 64 KB cartridge", memmap : [0x40, 0x80, 4]},
        "Type_29" : {machine : "800/XL/XE", size : "128", name : "MegaCart 128 KB cartridge", memmap : [0x40, 0x80, 8]},
        "Type_30" : {machine : "800/XL/XE", size : "256", name : "MegaCart 256 KB cartridge", memmap : [0x40, 0x80, 16]},
        "Type_31" : {machine : "800/XL/XE", size : "512", name : "MegaCart 512 KB cartridge", memmap : [0x40, 0x80, 32]},
        "Type_32" : {machine : "800/XL/XE", size : "1024", name : "MegaCart 1 MB cartridge", memmap : [0x40, 0x80, 64]},
        "Type_33" : {machine : "800/XL/XE", size : "32", name : "Switchable XEGS 32 KB cartridge", memmap : [0x20, 0x80, 3, 0x20, 0xA0, 1]},
        "Type_34" : {machine : "800/XL/XE", size : "64", name : "Switchable XEGS 64 KB cartridge", memmap : [0x20, 0x80, 7, 0x20, 0xA0, 1]},
        "Type_35" : {machine : "800/XL/XE", size : "128", name : "Switchable XEGS 128 KB cartridge", memmap : [0x20, 0x80, 15, 0x20, 0xA0, 1]},
        "Type_36" : {machine : "800/XL/XE", size : "256", name : "Switchable XEGS 256 KB cartridge", memmap : [0x20, 0x80, 31, 0x20, 0xA0, 1]},
        "Type_37" : {machine : "800/XL/XE", size : "512", name : "Switchable XEGS 512 KB cartridge", memmap : [0x20, 0x80, 63, 0x20, 0xA0, 1]},
        "Type_38" : {machine : "800/XL/XE", size : "1024", name : "Switchable XEGS 1 MB cartridge", memmap : [0x20, 0x80, 127, 0x20, 0xA0, 1]},
        "Type_39" : {machine : "800/XL/XE", size : "8", name : "Phoenix 8 KB cartridge", memmap : [0x20, 0xA0, 1]},
        "Type_40" : {machine : "800/XL/XE", size : "16", name : "Blizzard 16 KB cartridge", memmap : [0x40, 0x80, 1]},
        "Type_41" : {machine : "800/XL/XE", size : "128", name : "Atarimax 128 KB Flash cartridge", memmap : [0x20, 0xA0, 16]},
        "Type_42" : {machine : "800/XL/XE", size : "1024", name : "Atarimax 1 MB Flash cartridge", memmap : [0x20, 0xA0, 128]},
        "Type_43" : {machine : "800/XL/XE", size : "128", name : "SpartaDOS X 128 KB cartridge", memmap : [0x20, 0xA0, 16]},
        "Type_44" : {machine : "800/XL/XE", size : "8", name : "OSS 8 KB cartridge", memmap : [0x10, 0xB0, 1, 0x10, 0xA0, 1]},
        "Type_45" : {machine : "800/XL/XE", size : "16", name : "OSS two chip 16 KB cartridge (043M)", memmap : [0x10, 0xA0, 3, 0x10, 0xB0, 1]},
        "Type_46" : {machine : "800/XL/XE", size : "4", name : "Blizzard 4 KB cartridge", memmap : [0x10, 0xB0, 1]},
        "Type_47" : {machine : "800/XL/XE", size : "32", name : "AST 32 KB cartridge", memmap : [0x01, 0xBF, 256]},
        "Type_48" : {machine : "800/XL/XE", size : "64", name : "Atrax SDX 64 KB cartridge", memmap : [0x20, 0xA0, 8]},
        "Type_49" : {machine : "800/XL/XE", size : "128", name : "Atrax SDX 128 KB cartridge", memmap : [0x20, 0xA0, 16]},
        "Type_50" : {machine : "800/XL/XE", size : "64", name : "Turbosoft 64 KB cartridge", memmap : [0x20, 0xA0, 8]},
        "Type_51" : {machine : "800/XL/XE", size : "128", name : "Turbosoft 128 KB cartridge", memmap : [0x20, 0xA0, 16]},
        "Type_52" : {machine : "800/XL/XE", size : "32", name : "Ultracart 32 KB cartridge", memmap : [0x20, 0xA0, 4]},
        "Type_53" : {machine : "800/XL/XE", size : "8", name : "Low bank 8 KB cartridge", memmap : [0x20, 0x80, 1]},
        "Type_54" : {machine : "800/XL/XE", size : "128", name : "SIC! 128 KB cartridge", memmap : [0x40, 0x80, 8]}, //to check
        "Type_55" : {machine : "800/XL/XE", size : "256", name : "SIC! 256 KB cartridge", memmap : [0x40, 0x80, 16]}, //to check
        "Type_56" : {machine : "800/XL/XE", size : "512", name : "SIC! 512 KB cartridge", memmap : [0x40, 0x80, 32]}, //to check
        "Type_57" : {machine : "800/XL/XE", size : "2", name : "Standard 2 KB cartridge", memmap : [0x08, 0xB8, 1]},
        "Type_58" : {machine : "800/XL/XE", size : "4", name : "Standard 4 KB cartridge", memmap : [0x10, 0xB0, 1]},
        "Type_59" : {machine : "800", size : "4", name : "Right slot 4 KB cartridge", memmap : [0x10, 0x90, 1]},
        "Type_60" : {machine : "800/XL/XE", size : "32", name : "Blizzard 32 KB cartridge", memmap : [0x20, 0xA0, 4]},
        "Type_61" : {machine : "800/XL/XE", size : "2048", name : "MegaMax 2 MB cartridge", memmap : [0x40, 0x80, 128]}, //bank 0 first
        "Type_62" : {machine : "800/XL/XE", size : "128M", name : "The!Cart 128 MB cartridge", memmap : [0, 0, 0]}, //bank 0 first //(PVB TODO) =>not supported yet
        "Type_63" : {machine : "800/XL/XE", size : "4096", name : "Flash MegaCart 4 MB cartridge", memmap : [0x40, 0x80, 255]}, //bank 254 is ennable, no 255 bank
        "Type_64" : {machine : "800/XL/XE", size : "2048", name : "MegaCart 2 MB cartridge", memmap : [0x40, 0x80, 128]},
        "Type_65" : {machine : "800/XL/XE", size : "32M", name : "The!Cart 32 MB cartridge (!not supported yet)", memmap : [0, 0, 0]}, //bank 0 first //(PVB TODO) =>not supported yet
        "Type_66 ": {machine : "800/XL/XE", size : "64M", name : "The!Cart 64 MB cartridge (!not supported yet)", memmap : [0, 0, 0]}, //bank 0 first //(PVB TODO) =>not supported yet
        "Type_67" : {machine : "800/XL/XE", size : "64", name : "XEGS 64 KB cartridge (banks 8-15)", memmap : [0x20, 0x80, 7, 0x20, 0xA0, 1]}, //bank 0 first
        "Type_68" : {machine : "800/XL/XE", size : "128", name : "Atrax 128 KB cartridge", memmap : [0x20, 0xA0, 16]}, //coded cartridge of type 17
        "Type_69" : {machine : "800/XL/XE", size : "32", name : "aDawliah 32 KB cartridge", memmap : [0x20, 0xA0, 4]}, //bank 0 first 
        "Type_70" : {machine : "800/XL/XE", size : "64", name : "aDawliah 64 KB cartridge", memmap : [0x20, 0xA0, 8]}, //bank 0 first 
        // ALTIRRA V3.90 does not support next types ?
        "Type_71" : {machine : "5200", size : "64", name : "Super Cart 64 KB 5200 cartridge (32K banks)", memmap : [0x80, 0x40, 2]},
        "Type_72" : {machine : "5200", size : "128", name : "Super Cart 128 KB 5200 cartridge (32K banks)", memmap : [0x80, 0x40, 4]},
        "Type_73" : {machine : "5200", size : "256", name : "Super Cart 256 KB 5200 cartridge (32K banks)", memmap : [0x80, 0x40, 8]},
        "Type_74" : {machine : "5200", size : "512", name : "Super Cart 512 KB 5200 cartridge (32K banks)", memmap : [0x80, 0x40, 16]},
        "Type_75" : {machine : "800/XL/XE", size : "1024", name : "Atarimax 1 MB Flash cartridge (new)", memmap : [0x20, 0xA0, 128]},
        //(PVB TODO) Add futur type above type_75 : https://github.com/atari800/atari800/blob/master/DOC/cart.txt
    };
    //(PVB end of ADD)

    //(PVB ADD) "_extractedfile" = default values in the disk file extract to be disassembled
    var _extracted_disk = {start_sect: 1, start_sect_off: 6, end_sect: 3, start_add: 0x706 };
    var _extracted_file = {start_offset: 0, end_offset: 15, start_add: 0x1000 };
    //(PVB end of ADD)

    // guess the file type
    //(PVB MOD) improvement of get_ext() function
    function get_ext(name, a, imgTag) { //(PVB COM get_ext() is called by load_data() function and returns, the loaded file extension "xxx"
        //(PVB COM) name = file name; a = the file byte data; imgTag = is set with the image (type/mime) extension
        var n = name.lastIndexOf("."); //(PVB COM) uber of char before the extension "."
        if (n != -1) { //(PVB COM) if it is not -1, then an extension has been found in the loaded file
            var ext = name.substr(n + 1).toLowerCase(); //(PVB COM) ext is set to lowercase
            if (_exts[ext]) {
                //(PVB COM) returns the extension if found in the table of extensions
                console.log("get_ext() has found extension '" + ext + "' for file " + name);
                return ext;
            }
        }
        //(PVB COM) no ext in the file name, or unknown extension from the table... is it a type/mime image ?
        if (imgTag) {
            console.log("get_ext() has found imgTag for image in file " + name);
            return imgTag.width == 320 ? "gr8" : "gr7"; //(PVB COM) if yes, the ext is forced to gr8 or gr7
        }
        //(PVB COM) no ext in the file name, or unknown extension from the table, or not a type/mime image
        //check disk type....
        console.log("get_ext() checks if " + name + " is a disk ...");
        if (ATR.is_atr(a)) //(PVB MOD) function is_atr() has been added, so use it to check is it is an ATR
            //(previously) if (sig == 0x0296) //(PVB COM) $0296 (sum of 'NICKATARI') return "atr";)
            return "atr";
        if (ATX.is_atx(a)) //(PVB COM) note : static function call is done by CLASS.funtion()
            return "atx";
        if (PRO.is_pro(a))
            return "pro";
        if (XFD.is_xfd(a))  //(PVB COM) XFD is identified with the OS/Windows file size that corresponds to an Atari disk size
            return "xfd";
        console.log("get_ext() checks if " + name + " is an Atari file ...");
        //(PVB COM) check in the header of file...
        var sig = le16(a, 0); //(PVB COM)  sig = signature or file header (2 first bytes)
        //(PVB MOD) use a switch function
        switch (sig) {
            case 0xFFFF:
                if (le16(a, 2) < le16(a, 4)) {
                    return "xex"; //(PVB COM) it is a valid executable Atari file with 0xFFFF header and the 2 segment address vector are consistent
                }
                break;
            case 0x80FF:
                if (le16(a, 2) == 0xC7C9) {
                    return "pic";
                }
                break;
            case 0x4952:
                return "rip";
            case 0xFEFE:
                return "m65";
            case 0x081A:
            case 0x041A:
                return "arc";
        }
        console.log("get_ext() checks if " + name + " is an Atari BASIC file ...");
        //(PVB COM) check for Basic file...
        try {
            if (ataribasic(a, 0, a.length)) {
                console.log("... yes it is BASIC file !");
                return "bas";
            }
        }
        catch (err) {
            console.log(err);   // guess it wasn't basic because ataribasic() returns an error
        }
        console.log("get_ext() checks if " + name + " is an Atari LST file ...");
        //still not find the type here, so check for general LST file (basic listing)
        var s = '';
        for (var i = 0; i < a.length; i++) //(PVB COM) searching in the file for keywords "REM, GOTO, THEN" that should be in an Atari LST file
            s += String.fromCharCode(a[i]);
        if ((s.indexOf("REM") != -1) || (s.indexOf("GOTO") != -1) || (s.indexOf("THEN") != -1)) {
            console.log("... yes it is LST file !");
            return "lst";
        }
        console.log("get_ext() has not find a known Atari file, so ext of  " + name + " is set to '???'");
        //still not find the type here
        return "???"; //(PVB MOD) ext = "???" that is an unknown type, so it will be displayed as a DAT file
    }

    //(PVB ADD) get_type() function to get the overall type among isFile, isRomdump, isDisk, isRaw adn isArc. This will be used by ext_option(f) 
    function get_type(ext) {
        var e = _exts[ext];
        if (!e || ext == "???" || ext == "dat") {
            console.log("get_type() has set file with extension '" + ext + "' to Raw file");
            return "isRaw";
        }
        if (ext == "arc")
            return "isArc";
        if (e.is_romdump)
            return "isRomdump";
        if (e.is_disk)
            return "isDisk";
        if (e.is_txt || e.is_img)
            return "isTxtImg";
        console.log("get_type() assume that file with extension '" + ext + "' is an Atari DOS File (isFile)");
        return "isFile";
    }
    //(PVB END OF ADD)

    var _id = 1;
    var _container_id = 1;
    var _containers = [];
    function get_file(id) {
        var f;
        _containers.forEach(c => c.files.forEach(i => { if (i.id == id) f = i }));
        return f;
    }
    var _shown;

    function save(as_lst) {
        var f = _shown;
        if (as_lst) {
            var data = get_ataritext();
            var n = f.name;
            if (n.substr(n.length - 4).toLowerCase() == ".bas")
                n = n.substr(0, n.length - 4);     // trim ".BAS"
            save_bytes(n + ".LST", data);
        } else if (f.packed_img) {
            if (f.rgb)
                save_bytes(f.name + ".rgb", f.rgb);
            else
                save_bytes(f.name + "." + f.ext, f.packed_img);
        } else
            save_bytes(f.name, f.data);
    }

    //(PVB ADD) new save_as_xxx() functionx
    function save_as_dsk(ext) {
        var f = _shown;
        if (ext == "ATR")
            save_bytes(f.name + ".ATR", f.atr.d);
        if (ext == "XFD") {
            var d = f.atr.d.slice(16);
            save_bytes(f.name + ".XFD", d);
        }
    }
    function save_as_cart() {
        var f = _shown;
        save_bytes(f.name + ".car", f.rom.romData);
        /*if (f.rom.tmpData) save_bytes(f.name, f.rom.tmpData); //Saving the new bank map : See apply_rommap(id)*/
    }
    function save_wo_header() {
        var f = _shown;
        var d = f.rom.romData.slice(16);
        save_bytes(f.name + ".rom", d);
    }
    function save_disassembly(h) {
        var f = _shown;
        var s = "Atari 8-bit rom image file explorer - Listing";
        if (!h) { //request to save in txt format: _txt("#show") get the text (inner text) of the listing display in the html page
            var str = s + "\n\n" + f.name + "\n\n" + _txt("#show") + "\n\nThis text listing is given without any warranty - PVBestInFoo on @github";
            save_bytes(f.name + ".txt", str);
        }
        else { //request to save in html format: get the (inner html) of the listing display in the html page
            var strhtml = `<!DOCTYPE html>
            <html lang="en">
            <head><title>${s}</title>
            <style>`;
            if (h == 2) { //save with the atari font and style, go get the style
                var ff = document.getElementsByTagName("STYLE");
                strhtml += ff[0].innerHTML;
            }
            strhtml += `</style>
            <body>
                <h2>${s}</h2><h3>${f.name}</h3><br />
                <div><pre>`;
            strhtml += document.querySelector("#show").innerHTML;
            strhtml += `</div></pre><br />
            This HTML page may have bugs and is given without any warranty - PVBestInFoo on @github
            </body>
            </html>`;
            save_bytes(f.name + ".html", strhtml);
        }
    }
    //(PVB END OF ADD)
    
    //===================================================================================================
    //===================================================================================================
    // xex/obj disassembly 

    //(PVB MOD) improvement of get_xex_segs(): accept several 0xFFFF headers in same file, check segment validity
    function get_xex_segs(a, i, len) {
        //(PVB COM) a = file data, i = 0 (offset) //len = file size
        var segs = [];
        var segnum = 0; //(PVB ADD) segment counter
        var e = i + len;
        //(PVB MOD) put the variable declaration before code
        //(PVB COM) test the first 2 bytes
        if (le16(a, i) != 0xFFFF) //(PVB COM) header shall be 0xFFFF for Atari Executable files (COM, EXE, XEX)
            return null; //(PVB COM) This is not an executable file - return !
        //(PVB TODO) handle the Obj File, or file without 0xFFFF header 
        while (i < e) { 
            while (le16(a, i) == 0xFFFF) {//(PVB COM) header 0xFFFF is okay. 2 successive 0xFFFF is not allowed
                //(PVB ADD)(PVB MOD) 0xFFFF segments are stored in the 'segs' array, with the number 0xFFFF. Added the "segid" in the 'segs' array.
                seg = { segid: 0xFFFF, start: 0, end: 0, offset: i, len: 2 };
                segs.push(seg); //push the seg in the segs table
                //(PVB end of ADD)
                i += 2; // increase of 2
            }
            // i is lower that e, this shoulb be a valid segment
            var start = le16(a, i); // then the start address of segment
            var end = le16(a, i + 2); // then the end address of segment
            i += 4; // then at +4 there are the segment data
            var slen = end + 1 - start; // length of data formula - shall be from 1 to max length of file
            if ((slen < 0) || (i + slen > e)){ //check if segment is consistent
                //(PVB ADD)(PVB MOD) checkthe segment validity
                if (!segnum){ //(PVB) in case of there is no segment found (should not appear in real life for binary file!)
                    console.log("get_xex_segs(..)===> function has not found valid segment !"); //(PVB CONSOLE HINT)
                    return null; //(PVB) first segment is not OK, we do nothing and return
                }
                else { //(PVB) in case of there are some segments found
                    //(PVB) save this last not-OK segment as number "-1", and return (this is the last and identified segment, with segid =-1)
                    seg = { segid:-1, start: start, end: end, offset: i, len: slen }; 
                    segs.push(seg);
                    return segs;
                }
            } 
            segnum ++; //increase the segment counter
            //(PVB end Of add)
            //(PVB MOD) added : "segid" in the 'segs' array
            var seg = { segid:segnum, start: start, end: end, offset: i, len: slen }; //(PVB COM) offset is the memory pointer of the first byte in the segment
            segs.push(seg); //push the seg in the segs table
            i += slen; // i is set for next segment
        }
        return segs;
    }
    
    var _nBankId = ""; //(PVB ADD)
    //(PVB MOD) improvement of xex_dump(): handle ROM, entry_points, dump types, disassembly origin
    var _hr = "; ===============================================================================";
    function xex_dump(name, a, i, len, dump_type, org, entry_points) {
        //previously //function xex_dump(name, a, i, len, expect_header, org, entry) { //(PVB COM) expect_header & entry have no use!
        //"name" is name of file; "a" is the UintArray of Data; "i" is the offset index in the Data; "len" is the length of Data to disassemble
        //"dump_type" is the string of the type of Data to disassemble : "HEAD" is for binary file with 0xFFFF headers, "ROM" for ROM, "BOOT" for boot sector
        //"org" = address origin of the disassembly // for dump_type = "BOOT", "org" is the "BLDADDR" boot loading address
        //"entry_points" = array of important addresses to highlight in the disassembly listing:
        // => BCONT address of boot continuation after JUMP $4C (like $714 for DOS); "BINTAD" for Boot Initializarion Address (after a SEC + RTS)
        // => rom_coldstart = CARTCS (cold start at len-6); rom_init = CARTAD (initialisation start vector at len-2) for the "ROM"
        // note : RUNAD (DOS RUN ADDRESS) at $2E0; and INITAD (DOS INIT ADDRESS) at $2E2 for "HEAD" are set in the present function and not pass in entry_points

        if (name == "DOS.SYS") { //http://data.atariwiki.org/DOC/Inside_Atari_DOS_GBXL.pdf
            org = _shown.dosType == 1 ? 0x0780 : 0x07CB;   //DOS.SYS start loading address 
            entry_points = _shown.dosType == 1 ? [0x1300] : [0x1540]; //DOS.SYS entry run address
        }
        else if (org === undefined || org === 0 )
            org = 0x700;
        //(PVB COM) memory array for flags and ram
        var flags = new Uint8Array(0x10000);
        var ram = new Uint8Array(0x10000);
        //(PVB ADD) seems to be better to erase arrays, in case of...
        flags.fill(0); 
        ram.fill(0);

        if (org >= 0xFFFF) {
            console.log("xex_dump ()==> 'org' error ! value was :" + org);
            org = 0;
        }

        //(PVB MOD & ADD)
        //(PVB MOD) here declaration of the segheader
        var segheader = false;
        //(PVB ADD) here declaration of the is_rom
        var is_rom = false;
        //(PVB ADD) "dump_type" managment
        if (dump_type.lastIndexOf("ROM") >= 0) {
            _nBankId = dump_type.slice(dump_type.indexOf("_") + 1);
            is_rom = true;
        }
        else _nBankId = "";
        if (dump_type == 'HEAD') { //(PVB ADD) if it is "HEAD" => seek the headers; it is not necessary for "SEL", "BOOT" & "EXTRACT"
            var segs = get_xex_segs(a, i, len);
            //(PVB COM) segs is an array of n seg (n = 0, 1, ...), n is the segment number "seg.segid" if segment is valid
            //if not, segid can be 0xFFFF if segment is an header (= just 2 bytes), or -1 if segment if wrong (wrong length)
            segheader = segs && segs.length;  //(PVB COM) segheader is "null" if not segments / header have been found (case for DOS.SYS for exemple)
        }
        var lines = [];
        
        /*showDisOption(); ==> now put in render_file()*/
        if (dump_type == 'BOOT') {
            lines.push(_hr);
            lines.push("; <b>Disk Boot program is $" + len.toString(16).toUpperCase() + " (" + len + ") bytes on " + name + " sectors </b>");
        }
        else if (!is_rom) {
            lines.push("; <b>File '" + name + "' is $" + len.toString(16).toUpperCase() + " (" + len + ") bytes</b>");
            if (_shown.start && (dump_type == 'HEAD' || !dump_type))
                lines.push("; [Start sector: " + _shown.start + " ($" + hex(_shown.start, 3) + "); " + _shown.total + " ($" + hex(_shown.total, 3) + ") blocs]\n");
            else lines.push("");
        }
        //else //(PVB COM) we are in a ROM here !
            //lines.push("; <b>Disassembly of ROM bank at $" + hex(org, 4) + ", size: " + len + " ($" + len.toString(16).toUpperCase() + ") bytes</b>");

        if (!segheader) { //(PVB COM) if no segments, it is not a binary file with header.
            
            if (dump_type == "BOOT")
                flags[org + 6] = 0x84; //add the address (org + 6) as an entry_points (flags = 0x84 to for the disassembly address)
            if (entry_points) {
                console.log("xex_dump ()==> entry_points (length=" + entry_points.length + "):"); //(PVB CONSOLE HINT)
                console.log(entry_points); //(PVB CONSOLE HINT)
                var n = entry_points.length;
                while (n--)
                    flags[entry_points[n]] = 0x84;
            }
            var asms = [];
            asms.push(disassemble(org, a, i, len, ram, flags));
            if (!is_rom)
                lines.push(_hr); //(PVB ADD)
            asms.forEach(asm => disassemble2(asm, lines, ram, flags));
        }
        else { //(PVB COM) There are segments
            var s;
            // walk segments, collect entry points
            // draw them all at head, repeat them in body
            segs.forEach(seg => {
                //(PVB MOD) Adding the hyperlinks display 
                var stmp = seg.segid; //(PVB) segment number
                if (stmp == 0xFFFF) { //(PVB) this is a header 
                    s="; Header 0xFFFF at file offset $" + seg.offset.toString(16).toUpperCase();  //(PVB ADD)
                }
                else { // this is not a header but a segment
                    s = "; Code <a id='BKTOSEG" + stmp + "' href='#FWTOSEG" + stmp + "'>segment \#" + stmp + "</a>";  // hypertext vers le segment
                    s = s + ": $" + seg.len.toString(16).toUpperCase() + " (" + seg.len + ") bytes at $" + hex(seg.start, 4) + ":" + hex(seg.end, 4);//(PVB) ajout hexa $ et valeur
                }
                if (stmp == -1)
                    seg.note = '<span style="color:red;"> => WRONG SEGMENT! at offset $' + seg.offset.toString(16).toUpperCase() + '</span>'; // (PVB ADD) unvalid segment display
                // note initialization and run addresses
                switch (seg.start) {
                    case 0x2E0: //RUNAD (DOS RUN ADDRESS) at $2E0 (736)
                        flags[seg.run = le16(a, seg.offset)] = 0x84; //(PVB ADD) flagged as an entry point for disassembly listing
                        if (seg.len == 4) { // if the len is 4, then 2E0 to 2E3 are initialized within the same segment
                            flags[seg.initialize = le16(a, seg.offset + 2)] = 0x84;
                            seg.note = " -> initialize at $" + hex(seg.initialize, 4) + ", run at $" + hex(seg.run, 4); // (PVB) rajout hexa $ et valeur hexa
                        } else
                            seg.note = " -> run at $" + hex(seg.run, 4); //(PVB MOD) hexa $ display
                        break;
                    case 0x2E2: //INITAD (DOS INIT ADDRESS) at $2E2 (738)
                        flags[seg.initialize = le16(a, seg.offset)] = 0x84; //(PVB ADD) flagged as an entry point for disassembly listing
                        seg.note = " -> initialize at $" + hex(seg.initialize, 4); //(PVB MOD) hexa $ display
                        break;
                }
                if (seg.note)
                    s += seg.note;
                lines.push(s);
            });
            lines.push('');

            // Do the disassembly, first pass
            var asms = {};
            segs.forEach(seg => {
                if (seg.segid != 0xFFFF) { //(PVB) if segment number is not header
                    console.log("DISASS 1st PASS of SEGMENT #" + seg.segid);
                    asms[seg.segid] = disassemble(seg.start, a, seg.offset, seg.len, ram, flags);  // disassemble the segment with first pass
                }
            });

            // Complete the disassembly, second pass
            segs.forEach(seg => {
                //lines.push(hr); //(PVB ADD) more char
                //(PVB MOD) Adding the hyperlinks display
                var stmp = seg.segid; //(PVB COM) segment display
                if (seg.segid != 0xFFFF){ //(PVB COM) segment number is not header
                    lines.push(_hr);
                    s = "<span id='FWTOSEG" + stmp + "'>; Code segment \#" + stmp + "<a href='#BKTOSEG" + stmp + "'>(back)</a></span>";  // hyperlink to the segement
                    s = s + ": $" + seg.len.toString(16).toUpperCase() + " (" + seg.len + ") bytes at $" + hex(seg.start, 4) + ":" + hex(seg.end, 4); // (PVB) hexa $ and value display
                    if (seg.note)
                        s += seg.note;
                    lines.push(s);
                    lines.push(_hr); //(PVB ADD) more char
                    lines.push('');
                    if (asms[seg.segid]) {
                        console.log("DISASS 2nd PASS of SEGMENT #" + seg.segid);
                        disassemble2(asms[seg.segid], lines, ram, flags); // disassemble the segment with 2nd pass
                    }
                }
            });
        }
        if (!is_rom)
            lines.push(';<i>End of disassembly \><a href="#top">Back to top</a></i>');
        return lines.join("\n");
    }

    //===================================================================================================
    // (PVB COM) Class declaration of the different possible Disk Images

    class PRO {
        static
        is_pro(d) {
            var s = toAscii(d, 2, 2);
            return s == "P2" || s == "P3";
        }

        static
        to_atr(d) {
            var sector_total = (d[0] << 8) | d[1];
            var sector_count = (d[6] << 8) | d[7];
            if (sector_count == 0)
                sector_count = 720; // p2?
            var sector_size = 128;
            var size = sector_count * sector_size;

            var atr = new Uint8Array(16 + size);
            atr[0] = 0x96;  // (PVB COM) $0296 (checksum of 'NICKATARI')
            atr[1] = 0x02;
            atr[2] = (size >> 4) & 0xFF;
            atr[3] = (size >> 4) >> 8;
            atr[4] = sector_size & 0xFF;
            atr[5] = sector_size >> 8;
            atr[6] = (size >> 4) >> 16;
            var dst = 16;
            for (var i = 0; i < sector_count; i++) {
                var src = 16 + 12 + (12 + sector_size) * i;
                var n = sector_size;
                while (n--)
                    atr[dst++] = d[src++];
            }
            return atr;
        }
    }
    
    //(PVB ADD) add the ROM class, its constructor and additional functions
    class ROM {
        calChkSum(d, i){
            var chksm = 0;
            while (i < d.length)
                chksm += d[i++];
            return chksm;
        }
        is_cart(d) {
            if (le32(d,0) == 0x54524143) // 'ATASCII code of Cart signature 'C' 'A' 'R' 'T'
                if ((d.length - 16) && 0x3FF) {
                     //var i = 0;
                    var tchksm = (d[8] << 24) | ((d[9]) << 16) | ((d[10]) << 8) | (d[11]);
                    var chksm = this.calChkSum(d, 16);
                    console.log("ROM Constructor ==>checksum in rom $" + tchksm.toString(16) + " vs $" + chksm.toString(16));
                    if (tchksm != chksm)
                         console.log("ROM Constructor ==>Error : checksum does not match !!");
                    return true;
                    }
            return false;
        }
        to_cart(d) {
            var cartRom = new Uint8Array(16 + d.length);
            cartRom[0] = 0x43; 
            cartRom[1] = 0x41;
            cartRom[2] = 0x52;
            cartRom[3] = 0x54;
            for (var i = 4; i < 16; i++)
                cartRom[i] = 0; //at this stage : unkown type is 00 in header [7]
            //set the checksum
            var chksm = this.calChkSum(d, 0);
            console.log("ROM Constructor ==>calculated checksum is $" + chksm.toString(16));
            cartRom[8] = (chksm >> 24) & 0xFF;
            cartRom[9] = (chksm >> 16) & 0xFF;
            cartRom[10] = (chksm >> 8) & 0xFF;
            cartRom[11] = chksm & 0xFF;
            cartRom.set(d, 16);
            return cartRom;
        }
        constructor(d, name) {
            var re;
            var len = d.length;
            this.romData = d;
            this.isCart = this.is_cart(d);
            if (this.isCart) { // this is a CART due to size and CART signature
                if (d[7] > 0 && d[7] < 76) { //signature = type if CART ROM, according to https://github.com/atari800/atari800/blob/master/DOC/cart.txt
                    this.romType = d[7];
                    console.log("ROM Constructor ==>Cart Rom Type is " + this.romType);
                }
                else { //no valid signature
                    this.romType = 0;
                    console.log("ROM Constructor ==>Cart Rom Type is unknown in the CART !!");
                }
                re = ( (this.romType < 10) ? "Type_0" : "Type_" ) + this.romType;
                // TODO tester si re est dans la liste ...
                this.romName = _romtypes[re].name;
                this.romMachine = _romtypes[re].machine;
                this.romKBSize = _romtypes[re].size;
                if (this.romKBSize != (d.length >> 10))
                    console.log("ROM Constructor ==>CART Rom size in KB mismatch as not a KB multiple !!");
                else
                    console.log("ROM Constructor ==>OK CART Rom type is valid with size...");
                this.romMachine = _romtypes[re].machine;
                this.romMap = _romtypes[re].memmap;
                this.romTypeTxt = re;
            }
            else { //this is not a CART, so there are no 16 bytes header
                console.log("ROM Constructor ==>This is not a CART ROM");
                if (len & 0x3FF) {
                    console.log("ROM Constructor ==>ROM size " + len + " is not a multiple of KB !!");
                    // modifier romLen ???
                }
                this.romData = this.to_cart(d); //conversion
                this.romType = 0;
                this.romTypeTxt = "Type_00";
                if (name.includes(".a52"))
                    this.romMachine = "5200";
                else
                    this.romMachine = "800/XL/XE";
                this.romKBSize = '' + (d.length >> 10);
                switch (len) { //romMap = memmap: [size in page, start address in page, number of bank at same address]
                    case 0x0800: //2K use for A5200 ROM 
                        this.romMap = [0x08, 0xF8, 1];
                        this.romMachine = "5200";
                        console.log("ROM Constructor ==>Using the 2K ROM Mapping for A5200!");
                        break;
                    case 0x1000: //4K default 
                        this.romMap = [0x10, 0xB0, 1];
                        break;
                    case 0x2000: //8K use for ATARI BASIC ROM ROM 
                        this.romMap = [0x20, 0xA0, 1];
                        break;
                    case 0x2800: //10K use for ATARI OS A/B 
                        this.romMap = [0x28, 0xD8, 1];
                        console.log("ROM Constructor ==>Using the 10K ROM Mapping for OS A/B ROM!");
                        break;
                    case 0x4000: //16k use for XE/XL OS ROM
                        this.romMap = [0x40, 0xC0, 1];
                        console.log("ROM Constructor ==>Using the 16K ROM Mapping for XL/XE OS ROM!");
                        break;
                    case 0x8000: //32k (only works for A5200, ROM can start at $4000)
                        this.romMap = [0x80, 0x40, 1];
                        break;
                    default: //use a default mapping, n 4k banks in B000-BFFF
                        this.romMap = [0x10, 0xB0, len >> 12]; //'>> 12' is eq to divide by 0x1000
                        console.log("ROM Constructor ==>Using default mapping!");
                }
                this.romName = "Unknown cartridge for " + this.romMachine + "? => set to default / OS ROM";
            }
        }
    }
    //(PVB end of ADD)

    class XFD {
        static
        is_xfd(d) {
            //(PVB MOD) Modified : no rule for data in XFD image, since it's just an Atari raw disk image file.
            //Hence to be an XFD, image size shoud only be equal a disk size.
            //note : 256*720 stands for buggy image that considers the 3 first sectors may be 256 bytes on double density disk
            //https://forums.atariage.com/topic/123109-atr-format-reference/
            //https://forums.atariage.com/topic/293817-first-3-disk-sectors-always-128-bytes/
            //previously //return (le16(d,0) == 0x0300) && (le16(d,2) == 0x0700);    
            if ((d.length == 720*128) || (d.length == 3*128 + (720-3)*256) || (d.length == 1040*128) || (d.length == 720*256) || (d.length == 3*128 + (2*720 - 3)*256))
                return true;
            //(PVB end of MOD)
        }

        static
        to_atr(d) {  // (PVB) append header to raw atrs or new raw XFD = convert the XFD into ATR
            //(PVB COM) assume the defaut is Single Density disk:
            var sector_total = 720; // raw image was 702 sectors... typo of 720?
            var sector_size = 128;
            //(PVB) Enhanced Density disk:
            if (d.length == 1040*128)
                sector_total = 1040;
            //(PVB) Double Density disk:
            if ((d.length == (128*3 + (720-3)*256)) || (d.length == 256*720)) { //(PVB MOD) Correct the Double Density which has 717+3 sectors) + buggy XFD with 256*720 :
                sector_total = 720;
                sector_size = 256;
            }
            //(PVB ADD) Double Sided, Double Density disk:
            if ((d.length == (3*128 + (2*720 - 3)*256))) {
                sector_total = 1040; 
                sector_size = 256;
            }
            //(PVB end of ADD)  
            var size = sector_total * sector_size;
            var atr = new Uint8Array(16 + size);
            atr[0] = 0x96; // (PVB COM) $0296 (sum of 'NICKATARI')
            atr[1] = 0x02;
            atr[2] = (size >> 4) & 0xFF;
            atr[3] = (size >> 4) >> 8;
            atr[4] = sector_size & 0xFF;
            atr[5] = sector_size >> 8;
            atr[6] = (size >> 4) >> 16;
            atr.set(d, 16);
            return atr;
        }
    }

    class ATX {
        static
        is_atx(d) {
            return toAscii(d, 0, 4) == "AT8X";
        }

        static
        to_atr(d) {
            if (!ATX.is_atx(d))
                return null;
            var atx = new ATX(d);
            var atr = new Uint8Array(16 + atx.size);
            var sector_count = 720;

            atr[0] = 0x96;   //(PVB COM) $0296 (sum of 'NICKATARI')
            atr[1] = 0x02;
            atr[2] = (atx.size >> 4) & 0xFF;
            atr[3] = (atx.size >> 4) >> 8;
            atr[4] = atx.sector_size & 0xFF;
            atr[5] = atx.sector_size >> 8;
            atr[6] = (atx.size >> 4) >> 16;
            var dst = 16;
            for (var i = 0; i < sector_count; i++)
                dst = atx.readsector(i, atr, dst); //(PVB COM) appel de la fonction non static
            return atr;
        }

        constructor(d) {
            this.d = d;
            this.sector_size = 128;
            this.tracks = [];
            var t = le32(d, 28);
            while (t > 0 && t < d.length) {
                var track = { toff: [] };
                track.offset = t;
                track.size = le32(d, t);
                track.type = le16(d, t + 4);
                track.tracknum = d[t + 8];
                track.sectorcount = le16(d, t + 10);
                track.headersize = le32(d, t + 20);
                track.sectorlistsize = le32(d, t + 32) - 8;
                for (var i = 0; i < 16; i++)
                    track.toff[i] = 0;
                var sl = t + 40;
                for (var i = 0; i < track.sectorlistsize; i += 8) {
                    var dat = le32(d, sl + i + 4);
                    if (dat && d[sl + i])
                        track.toff[d[sl + i] - 1] = dat;
                }
                this.tracks.push(track);
                t += track.size;
            }
            this.size = 720 * this.sector_size;
        }

        readsector(n, dst, dsti) {
            var d = this.d;
            var track = n / 18 | 0;
            var ss = this.sector_size;
            this.tracks.forEach(t => {
                if (t.tracknum == track) {
                    var dat = t.toff[n % 18];
                    if (dat) {
                        for (var i = 0; i < ss; i++)
                            dst[dsti + i] = d[t.offset + dat++];
                    }
                }
            });
            return dsti + this.sector_size;
        }
    }

    class SpartaDOS {
        constructor(atr) {
            var d = atr.d;
            this.atr = atr;
            this.boot = {
                sector_map: le16(d, 16 + 9),       // Sector, where is the first Sector map of the main directory.
                sector_count: le16(d, 16 + 11),    // Number of every sectors on the disk
                free_sectors: le16(d, 16 + 13),    // Number of free sectors
                bitmaps: d[16 + 15],               // Number of Bitmaps
                first_bitmap: le16(d, 16 + 16),    // Sector used for the first Bitmap.
                sector_file: le16(d, 16 + 18),     // The first sector, where may be allocated a data sector for a file
                sector_dir: le16(d, 16 + 20),      // The first sector, where may be allocated a data sector for a directory
                volume_name: toAscii(d, 16 + 22, 8).trim(),
                tracks: d[16 + 30],                // Number of tracks; when the bit D7 is set, then the drive is double
                sector_size: d[16 + 31] ? 128 : 256,// Size of sectors (128 or 0 == 256)
                version: d[16 + 32],               // $11 - created by SpartaDOS 1.x
                sequential: d[16 + 38],            // This number is incremented every time you're making any changes on the disk
                random: d[16 + 39],                // Random number of the disk. This number is created while formatting the disk.
                boot_sector: le16(d, 16 + 40)      // Sector, where is the first Sector map of file specified for booting
            }
            this.file_info = {};
        }

        // first entry in directory is information about the directory itself
        // start == parent;
        get_dir(sector_map) {
            sector_map = sector_map || this.boot.sector_map;
            var dir = this.read_file(sector_map);
            var files = [];
            var dir_info;
            var sector_size = this.boot.sector_size;
            var idf = 1; //(PVB ADD)
            for (var i = 0; i < dir.length && dir[i]; i += 23) {
                if (i == 0) {
                    dir_info = {
                        flags: dir[i],
                        parent: le16(dir, i + 1),
                        len: le24(dir, i + 3),
                        name83: toAscii(dir, i + 6, 8),
                        name: toAscii(dir, i + 6, 8).trim()
                    }
                } else {
                    /*
                    0x01 // protected
                    0x04 // in use
                    0x10 // Erased
                    0x20 // subdirectory
                    */
                    var flags = (dir[i] & 0x04) ? 0 : 0x42;
                    if (dir[i] & 1)
                        flags |= 0x20;  // locked
                    var f = {
                        numidf: idf++, //(PVB ADD)
                        flags: flags,
                        valid: true,
                        start: le16(dir, i + 1),
                        len: le24(dir, i + 3), //(PVB TODO) check if it can be replaced by fsize
                        fsize: le24(dir, i + 3), //(PVB ADD)
                        name83: toAscii(dir, i + 6, 11),
                        name: toAscii(dir, i + 6, 8).trim(),
                        date: le24(dir, i + 17),
                        time: le24(dir, i + 20),
                        is_dir: dir[i] & 0x20
                    }
                    var ext = toAscii(dir, i + 14, 3).trim();
                    if (ext.length)
                        f.name += '.' + ext;

                    this.file_info[f.start] = f; // we know the length

                    f.sectors = [];
                    var sec = this.get_sectors(f.start);
                    for (var j = 0; j < sec.length; j++) {
                        f.sectors.push({
                            sector: sec[j],
                            len: Math.min(sector_size, f.len - j * sector_size),
                            offset: j
                        });
                    }
                    f.total = f.sectors.length;
                    files.push(f);

                    // recurse?
                    if (f.is_dir)
                        files = files.concat(this.get_dir(f.start));
                }
            }
            return files;
        }

        // get all the sectors associated with the file
        get_sectors(sector_map) {
            var atr = this.atr;
            var d = atr.d;
            var sector_size = this.boot.sector_size;

            // format is next:prev:s:s:s.... 16 bit entries
            var sectors = [];
            while (sector_map) {
                var sm = atr.sector_offset(sector_map);
                for (var i = 2; i < sector_size / 2; i++) {
                    var s = le16(d, sm + i * 2);
                    if (!s)
                        break;
                    sectors.push(s);
                }
                sector_map = le16(d, sm);    // next sector of sector map
            }
            return sectors;
        }

        read_file(sector_map) {
            var atr = this.atr;
            var file_info = this.file_info[sector_map];
            var d = atr.d;
            var dst = [];
            this.get_sectors(sector_map).forEach(s => {
                var src = atr.sector_offset(s);
                for (var i = 0; i < this.boot.sector_size; i++)
                    dst.push(d[src + i]);
            });
            if (file_info && !file_info.is_dir)
                dst.length = file_info.len;   // clip it if we know the size
            return new Uint8Array(dst);
        }
    }

    //(PVB COM) ATARI DOS file flags
    //see http://ftp.pigwa.net/stuff/collections/nir_dary_cds/Tech%20Info/DOS.HTM (not accurate enough)
    //and for DOS 3 : https://www.atarimax.com/jindroush.atari.org/afsdos3.html (not accurate neither !)
    // SO USE THIS MUST LINK => http://atariki.krap.pl/index.php/Formaty_system%C3%B3w_plik%C3%B3w
    //0x80 value: File (or MyDOS DIRECTORY) deleted for any DOS (all other bits are cleared) (may be recovered if not overriden ?)
    //0x40 bit 6: File exits and in use for any DOS (normal), then bit 7 is clear. Bit cleared for a MyDOS DIRECTORY.
    //0x20 bit 5: File Locked (protected from overwriting and deleting) for any DOS (appears with '*' in directory).
    //0x10 bit 4: bit set only for Mydos DIRECTORY (bits 6, 2 and 1 then have the value 0)
    //0x08 bit 3: not used
    //0x04 bit 2: is used by MyDOS only, if set means that file has a 16bits sector linking (MyDOS non-DOS2x compatible)
    //0x02 bit 1: is set, file created by DOS2x (if cleared, file created by DOS1). Set also fo a MyDOS file.
    //0x01 bit 0: File Opened for Output for any DOS. Used also by DOS2.5 to indicate that files is stored above sector 719 (and shown with <..>)
    //examples:
    // DOS1: $40=file exists, $60=write-protected file, and $80=file deleted. DOS2: $42=file exists, $62=write-protected file.
    // DOS2.5: $42=existing file available for DOS 2.0; $62= write-protected file available for DOS 2.0;
    //  $03=existing file not available for DOS 2.0; $43=file open for writing and never closed
    // MyDOS: $42 or $46 means an existing file, $62 or $66 - a read-only file, $10 - a directory, $80 - a file or directory deleted
    // DOS3: status of an existing file is $C0, a protected file is $C2, and a deleted file is $80.
    
    // For ATR structure see: http://www.atarimax.com/jindroush.atari.org/afmtatr.html

    class ATR {
        //(PVB ADD) is_atr(d) function to check if data d is an atr file
        static
        is_atr(d) {
            var sig = le16(d, 0); //(PVB COM) signature (2 first bytes)
            if (sig == 0x0296) //(PVB COM) $0296 (sum of 'NICKATARI') [MSB 150; LSB 2]
                return true;
        }
        //(PVB END OF ADD)
        constructor(d, name) {
            //(PVB COM) "d" is the OS/windows file data; "name" is the filename like "FoO.Ext"
            if (ATX.is_atx(d))
                d = ATX.to_atr(d); // Convert ATX into ATR
            else if (PRO.is_pro(d))
                d = PRO.to_atr(d); // Convert PRO into ATR
            else if (XFD.is_xfd(d))
                d = XFD.to_atr(d); // Convert XFD into ATR
            //(PVB ADD) convert raw image file with XFD or ATR extention, but without any known format, into an ATR disk
            else if (!ATR.is_atr(d)) {
                console.log("ATR Constructor() => name '" + name + "' is not ATX, nor PRO, nor XFD, nor ATR !!! => Convert it into a disk with 6 bytes of boot.."); //(PVB CONSOLE HINT)
                var m = d.length;
                if (m > (92160 - 6)) { //128*720 bytes (minus 6 bytes for boot)
                    m = 92160 - 6;
                    console.log("ATR Constructor() => '" + name + "' size is above 9260 b1ytes !! => Clip its data to size the ATR disk..."); //(PVB CONSOLE HINT)
                }
                var z = new Uint8Array(92160); //create a new 92160 bytes disk (default size)
                z.set([0, 0x03, 0, 0x10, 0x06, 0x10], 0); //put a "standard" boot header
                z.set(d.subarray(0, m), 6); //copie the rest of data (maximum m = 92160 - 6) // remaining data are clipped
                d = XFD.to_atr(z); //add the ATR header
                this.restructured = true; //flag for identifyong the making of the ATR file from scratch data
            }
            //(PVB COM "else" this is an ATR file, obviously
            //(PVB END OF ADD)
            this.d = d;
            this.name = name;
            this.size = (le16(d, 2) + (d[6] << 16)) << 4;
            this.sector_size = le16(d, 4);
            this.sector_count = (this.size - 128 * 3) / this.sector_size + 3;
            this.dir_sector = -1; //(PVB COM) by default, no directory sector
            if (!this.restructured && d[16 + 7] == 0x80) { //(PVB MOD) identifying data as Sparta disk
                //(PVB TODO) to be more robust and not rely only on one byte value to identify a sparta disk...
                console.log("ATR constructor() => has found a Sparta disk !"); //(PVB HINT)
                this.sparta = new SpartaDOS(this);
            }
            //(PVB ADD) identify DOS type
            this.dosType = this.identify_dos(); 
            if (this.dosType == 3) this.isDos3 = true; //to simplify logic test in case of specific DOS3
            console.log("ATR constructor() => identify_dos returns ATR.dosType = " + this.dosType); //(PVB HINT)
            console.log("ATR constructor() => ATR construction done !"); //(PVB HINT)
        }

        sector_offset(n) {    // 1 based (first sector is number 1 (and not 0)
            //(PVB COM) sector_offset(n) computes the memory pointeur for sector 'n' into the ATR 'data'
            n--;
            if (n < 3) //(PVB COM) first 3 sectors for boot are always 0x80 bytes
                return 16 + n * 0x80; //(PVB COM) 16 = for ATR header bytes
            return 16 + 3 * 0x80 + (n - 3) * this.sector_size; //(PVB COM) 16 are for ATR header bytes, plus 3 * 0x80 bytes for 3 sectors of boot
        }

        //(PVB ADD) read_sector() function, to read any raw sector from the disk
        read_sector(n) {
            var offset = this.sector_offset(n);
            var d = this.d;
            var sectordata = [];
            if (n < 3)
                sectordata = d.slice(offset, offset + 128);
            else
                sectordata = d.slice(offset, offset + this.sector_size);
            return sectordata;
        }
        //(PVB END OF ADD)

        //(PVB MOD) one_dir() improvement and DOS3 support
        one_dir(n, sector, idf) {// one_dir() is called by get_dir_range() and scan_files()
            // (PVB COM) 'n' is the dir entry (1 to 8) into the directory 'sector'; idf is the count of file (file number in the directory)
            //previously // sector = sector || 361;
            var m = 16; //(PVB CONSOLE HINT) limits the consolelog event display for the 16 first directory entry
            var d = this.d;
            var j = this.sector_offset(sector + (n >> 3)) + (n & 7) * 16; //index in the memory for the start of sector n  
            var dirEntry = [];
            var tdos = this.dosType; // to simplify
            if ((tdos != 5) && (is_zero(d, j, 16))) {
                console.log("one_dir() =>Error! File#" + idf + " entry is $00 bytes into DOS TOC!"); //(PVB CONSOLE HINT)
                return dirEntry; //no dir entry, 16 times $00 bytes found on the dir entry
            } 

            if (tdos == 3) // for DOS 3
                dirEntry = {
                numidf: idf, // (PVB ADD) the idf to count & identify files
                flags: d[j],  //(PVB) Byte 0 : Flag Byte of the DOS3 file: 0xC2 is OK, 0xC1 file exists and is open, 0x80 deleted, 00 no entry, bit 0x02 file is protected
                total: d[j +12], // Byte 12 : Total number of bloc (1 bloc = 8 sectors)
                startbloc: d[j +13], // Byte 13 : start bloc byte.
                start: d[j +13] * 8 + 25, // "start" = Startsector = start bloc byte * 8 + 25; Starting sector number of the DOS file
                fsize: le16(d, j +14), //size of the file in bytes (last 16 bits)
                name83: toAscii(d, j +1, 11), // Byte 5-15 : 11 char = 8 character filename padded with spaces at end + 3 character filename extension padded with spaces at end
                name: toAscii(d, j +1, 8).trim(), // Byte 1-8 : 8 character filename padded with spaces at end
                ext: toAscii(d, j +9, 3).trim() // Byte 9-11 : 3 character filename extension padded with spaces at end
                };
            else 
                dirEntry = {
                numidf: idf, // (PVB ADD) the idf to count & identify files
                flags: d[j],  // Byte 0 : Flag Byte of the DOS2 file
                total: le16(d, j +1), // Byte 1-2 : Total number of sectors of DOS file. 
                start: le16(d, j +3), // Byte 3-4 : Starting sector number of the DOS file.
                fsize: 0, // filesize in bytes default value 0 : dirEntry.fsize will be compute with the read_file() result in load_data()
                name83: toAscii(d, j +5, 11), // Byte 5-15 : 11 char = 8 character filename padded with spaces at end + 3 character filename extension padded with spaces at end
                name: toAscii(d, j +5, 8).trim(), // Byte 5-12 : 8 character filename padded with spaces at end
                ext: toAscii(d, j +13, 3).trim() // Byte 13-15 : 3 character filename extension padded with spaces at end
                };

            if (dirEntry.ext)
                dirEntry.name += '.' + dirEntry.ext; //"name" is like "dup.sys", without space but with ".ext"
            //(PVB MOD) cancelled to change the handling of flags
            //previously //dir.valid = (dir.flags & 0x40) != 0 && !(dir.flags & 0x8C);  // Valid File Flag
            //(dir.flags & 0x80) == 0;

            //(PVB MOD & ADD) Improvement of DOS file detection and validation
            dirEntry.valid = true;

            //following 2 conditions to check are the minimum to get a file from the dir entry: a valid name & a consistant start sector
            var title = (tdos != 3) ? d.slice(j +5, j +16) : d.slice(j +1, j +12); //name in Atacii
            var isName = isAtariNameChar(title, this.dosType == 7); //is that name is valid with atari char text ?
            if (!isName) {
                dirEntry.valid = false;
                if (idf < m) //(PVB CONSOLE HINT)
                    console.log("one_dir() =>Error! File#" + idf + ": has a name with invalid chars!"); //(PVB CONSOLE HINT)
            }
            /*if (is_zero(d, j, 14)) { //14 or 16 ?? 14 is for DOS3
                dirEntry.valid = false;
                dirEntry.sectors = [];
                if (idf < m) //(PVB CONSOLE HINT)
                    console.log("one_dir() =>Error! File#" + idf + ": has an empty entry into DOS TOC!"); //(PVB CONSOLE HINT)
            }*/
            if ((dirEntry.start < this.file_start) || (dirEntry.start > this.sector_count)) {
                dirEntry.valid = false;
                if (idf < m) //(PVB CONSOLE HINT)
                    console.log("one_dir() =>Error! File#" + idf + ": wrong start sector! ($" + hex(dirEntry.start, 3) + ")"); //(PVB CONSOLE HINT)
            }

            /*dir.valid = dir.valid && (dir.total < this.sector_count) && (dir.start < this.sector_count);
            dir.valid = dir.valid && dir.total && (dir.start > 3);*/

            //dir.total is checked below while reading sectors of the file
            dirEntry.err = '';
            if (isName) { //if name is valid
                if (d[j] == 0x80) {
                    dirEntry.err += " >file is deleted ($80 flag)"
                    if (idf < m) //(PVB CONSOLE HINT)
                        console.log("one_dir() =>Info: File#" + idf + ": " + dirEntry.name + " is a deleted file that could be wrong!"); //(PVB CONSOLE HINT)
                }
                else {
                    if (tdos == 3 && !(d[j] & 0xC0)) {
                        dirEntry.valid = false;
                        dirEntry.err += " >DOS3 dir entry file is not valid (no $0C flag)!"
                        if (idf < m) //(PVB CONSOLE HINT)
                            console.log("one_dir() =>Error! File#" + idf + ": " + dirEntry.name + " (DOS3) is not existing (no 0xC0 flag)!"); //(PVB CONSOLE HINT)
                    }
                    if ((d[j] & 0x41) == 0x41) {
                        dirEntry.err += " >non-closed file (open-for-writing flag)!";
                        if (idf < m) //(PVB CONSOLE HINT)
                            console.log("one_dir() =>Info: File#" + idf + ": " + dirEntry.name + " is a non-closed file that is open for writing, so may be wrong!"); //(PVB CONSOLE HINT)
                    }
                }
            }
            if (!dirEntry.valid) return dirEntry; //returns an empty dirEntry if non valid

            // get all sectors associated with this entry & check validity
            dirEntry.sectors = []; //initialisation of the DOS file sector table
            if (dirEntry.valid && tdos != 3) {
                var sector = dirEntry.start; //current sector is the first one
                var num = -1; //initialisation of the file number index
                if (dirEntry.total) {
                    console.log("one_dir() =>File#" + idf + ": DOS1/DOS2x/MyDOS " + dirEntry.name + " reading sectors...");
                    for (var k = 0; k < dirEntry.total; k++) { //up to the total number of bloc (sector)
                        var end = this.sector_offset(sector) + this.sector_size; //end of file pointer
                        var len = d[end - 1]; //len of data in the sector is set in the last byte of the sector

                        if (tdos == 7) { //MyDOS 16 bits next sector
                            var next = le16(d, end-2);
                            if (!f.dirEntry.flag & 0x04) {
                                dirEntry.err += " >MyDos 16bit sector chain flag not set! ($04)";
                                console.log("one_dir() =>Error! File#" + idf + ": MyDOS 16bits " + dirEntry.name + " not set in thedirectory");
                            }    
                        }
                        else {
                            var next = ((d[end - 3] & 0x3) << 8) | d[end - 2];
                            if (num == -1)  //first issue...
                                num = d[end - 3] >> 2; //.. set the file number from the MSB byte of the first sector
                            if (num != idf || num != (d[end - 3] >> 2)) { //file number in the MSB index of the next sector is not right or has changed
                                dirEntry.valid = false;
                                dirEntry.err += " >wrong file number in sector chain (DOS err.164)";
                                console.log("one_dir() =>Error! File#" + idf + ": DOS2x/MyDOS " + dirEntry.name + " has wrong file number #" + num + " in sector " + sector +"!");
                                break;
                            }
                        }
                        if (tdos != 1) { 
                            var is_good_len = (next == 0) ? (len <= (this.sector_size - 3) && len) : len == (this.sector_size - 3);
                            //is_good_len = true if (end sector && length of data to read is <= (sector size - 3) and not zero) or 
                            // (not end sector and length of data to read is = (sector size - 3))
                            if (!is_good_len) {
                                dirEntry.valid = false;
                                dirEntry.err += " >wrong length in sector chain!";
                                console.log("one_dir() =>Error! File#" + idf + ": DOS2x/MyDOS " + dirEntry.name + " has wrong byte_length (" + len + ") in sector " + sector +"!");
                                break;
                            }
                        }
                        else { //else if (tdos == 1) //(PVB TO DO) count the file sector in len if z set
                            if (len & 0x80) { //check Z : if set, it is the last sector of DOS1 file
                                if (next) {
                                    dirEntry.err += " > Z bit is set in last byte of sector chain!";
                                    console.log("one_dir() =>Error! File#" + idf + ": DOS1 " + dirEntry.name + " has Z bit set in last sector " + sector +"!");
                                    break;
                                }
                            }
                            else { //if Z clear, we are not in the last sector of DOS1 file (PVB TO DO) : count the file sector in len...
                                len = this.sector_size - 3; //that is $7F
                                if (!next) {
                                    dirEntry.valid = false;
                                    dirEntry.err += " > Z bit is cleared in last byte of sector chain!";
                                    console.log("one_dir() =>Error! File#" + idf + ": DOS1 " + dirEntry.name + " has Z clear and no next sector in sector " + sector +"!");
                                    break;
                                }
                            }
                            len &= 0x7F; //any way clear the bit 8
                        }
                        if (next > this.sector_count) {
                            //next is above last sector of disk
                            dirEntry.valid = false;
                            dirEntry.err += " >wrong next sector in sector chain!";
                            console.log("one_dir() =>Error ! File#" + idf + ": DOS2x/MyDOS " + dirEntry.name + " has wrong next_sector (" + next + ") in sector " + sector +"!");
                            break;
                        }
                        /*if (num != (d[end - 3] >> 2)) {
                            //file numberin the MSB index of the next sector has changed
                            dirEntry.valid = false;
                            console.log("one_dir() =>File#" + idf + ": DOS2x/MyDOS " + dirEntry.name + " has wrong file_number in sector " + sector +"!");
                            break;
                        }*/
                        dirEntry.sectors[sector] = { sector: sector, slen: len, snext: next, fbloc: k }; //save the sector (offset = sector number)
                        
                        if (next == 0) { // check real end of file
                            if (k != dirEntry.total - 1) { // EndOfFile reached before the end of total sector get from the file VTOC directory
                                dirEntry.valid = false;
                                dirEntry.err += " >truncated file: no next sector & total from dir entry not reached!";
                                console.log("one_dir() =>Error! File#" + idf + ": DOS2x " + dirEntry.name + " is truncated: next sector after " + sector + " is zero!");
                            } 
                            break;  // EOF?
                        }
                        sector = next;
                    }
                }
                else { // else if (!dirEntry.total) //if size is zero block or zero sector //(PVB CONSOLE HINT)
                    console.log("one_dir() =>Info: File#" + idf + ": DOS2x/MyDOS " + dirEntry.name + " is zero byte length!");
                }
            }
            else if (dirEntry.valid && tdos == 3) {
                //DOS3 gives the total number of bloc in dir.total as the file max size
                //file max size = (dirEntry.total * 8 * this.sector_size); //max size = 255KB for Dos 3 = 261120 bytes = $3FC00 bytes
                //fsize in the directory table is the lowest 16 bit (2 bytes) value of the actual file size, so "file max size" is the highest byte of actual file size
                dirEntry.fsize = ((dirEntry.total * 8 * this.sector_size) & 0xF0000) + dirEntry.fsize; //update fsize with fsize added with the file max size
                if (!dirEntry.fsize) {
                    console.log("one_dir() =>File#" + idf + ": DOS3 " + dirEntry.name + " is an invalid file with zero byte length!");
                }
                else {
                    console.log("one_dir() =>File#" + idf + ": DOS3 " + dirEntry.name + " reading sectors...");
                    var dos3Table = this.read_sector(24); //initialisation of the file layout table (sector 24)
                    var nextbloc = dos3Table[dirEntry.startbloc]; //number of current bloc, initialised to the start one
                    var sector = dirEntry.start; //current sector is the first one
                    for (var k = 0; k < dirEntry.total; k++) { //up to the total number of bloc
                        if (nextbloc >= 0xFD && (k != dirEntry.total -1)) {
                            dirEntry.valid = false;
                            console.log("one_dir() =>File#" + idf + ": DOS3 " + dirEntry.name + "  has wrong next/end bloc " + nextbloc +"!");
                            break;
                        }
                        if (sector > this.sector_count) {
                            //next est au delà du nombre de secteur
                            dirEntry.valid = false;
                            console.log("one_dir() =>File#" + idf + ": DOS3 " + dirEntry.name + "  has wrong bloc/target sector " + sector +"!");
                            break;
                        }
                        for (var s = 0; s < 8; s++) { //do the 8 sectors of the DOS3 bloc
                            dirEntry.sectors[sector + s] = { sector: sector + s, slen: this.sector_size, snext: -1, fbloc: k }; //save the sector (offset is sector number)
                        }
                        //compute next sector and read next bloc
                        sector = nextbloc * 8 + 25;
                        nextbloc = dos3Table[nextbloc];
                    }
                }
            }
            if (!dirEntry.valid)
                dirEntry.sectors = []; //if file entry not valid, no sector is save in the dirEntry
            else
                console.log("one_dir() =>OK: File#" + idf + ": " + (tdos == 3 ? "DOS3 " : "DOS2x ") + dirEntry.name + " file is valid !!");
            
            return dirEntry;
        }

        // Search the entire disk for sneaky directory entries
        get_dir_range(from, to) // get_dir_range() is called by get_dir()
        // (PVB) Search in the directory table that is (from, to) sectors ('to' is not included !)
        {
            var dirs = [];
            var idf = 0; // (PVB ADD) number of file found
            for (var i = from; i < to; i++) {   // (PVB COM) "i" stands for the sector range of the dir table (like the 8 sectors 361-368)
                for (var n = 0; n < 8; n++) {   // (PVB COM) "n" stands for the 8 lines of file entry in each sector of the dir table
                    var dir = this.one_dir(n, i, idf++); // (PVB COM) "dir" gets the content of one file entry
                    if (dir.valid) {
                        if (this.dir_sector == -1)
                            this.dir_sector = i;
                        dirs.push(dir);
                    }
                }
            }
            return dirs;
        }

        //(PVB MOD) DOS3 added for get_dir()
        //(PVB TODO) add other DOS get_dir support + MyDOS subdir sub directory ?? //WIP//
        get_dir() {
            if (this.sparta) {
                console.log("get_dir() => Retreiving the Sparta disk directory...");
                return this.sparta.get_dir();
            }
            var dirs = [];
            if (this.dosType == 3) {
                //try DOS3 disk
                console.log("get_dir() => Retreiving the DOS3 disk directory at 16-23...");
                dirs = this.get_dir_range(16, 24);
                if (dirs.length < 1 ) {
                    //(PVB TODO) // WIP // find other dirs or try the whole disk ??
                    console.log("get_dir() => No DOS3 directory entry in 16-23! Aborting process !");
                }
            }
            else if (this.dosType > 0) {
                console.log("get_dir() => Retreiving DOS1, DOS2x or MyDOS disk directory at 361-368...");
                dirs = this.get_dir_range(361, 369);
                if (dirs.length < 1) {
                    console.log("get_dir() => No DOS2x directory found at 361-368.... let's try into the whole disk...");
                    dirs = this.get_dir_range(4, this.sector_count);  // try the whole disk
                }
                if (this.dir_sector == -1) { // if nothing found...
                    console.log("get_dir() => No DOS2x directory entry found on whole disk");
                    this.dir_sector = 361;  // didn't find one, so use default (that is sector 361)
                }
                console.log("get_dir() => Try and find files that don't have a real directory entry like the erased ones...");
                //(PVB TODO) // WIP // find other dirs only if not a DOS2x disk ? like Subdir that are part of MyDos system ??
                this.scan_files(dirs);      // try and find files that don't have a real directory entry 
            }
            return dirs; //(PVB COM) complete directory table is returned, 'dirs' is empty if no file found
        }

        scan_files(dirs) { //scan_files() is called by get_dir(), only for DOS2x system
            var d = this.d;
            var sectors = [];

            var used = [];
            dirs.forEach(dir => dir.sectors.forEach(s => used[s] = dir));

            var files = [];
            for (var i = 4; i < this.sector_count; i++) {
                var end = this.sector_offset(i) + this.sector_size;
                var len = d[end - 1];
                var next = ((d[end - 3] & 0x03) << 8) | (d[end - 2]);   // TODO: 10 bits
                if (len == (this.sector_size - 3) || ((len <= (this.sector_size - 3)) && next == 0))
                    sectors[i] = { sector: i, len: len, next: next, num: d[end - 3] >> 2 };
            }
            sectors.forEach(s => {
                var n = sectors[s.next];
                if (n)
                    n.prev = s.sector;
            });
            sectors.forEach(s => {
                if (!s.prev) {
                    s.total = 0;
                    s.bytes = 0;
                    s.used = 0;
                    s.error = 0;
                    s.sectors = [];
                    var n = s;
                    do {
                        s.sectors.push(n);
                        if (used[n.sector])
                            s.used = used[n.sector];
                        s.bytes += n.len;
                        s.total++;
                        if (s.num != n.num)
                            s.error++;
                        if (n.next == 0)
                            break;
                        var np = sectors[n.next];
                        if ((n != s) && (!np || (np.prev != n.sector))) {
                            s.error++;
                            break;
                        }
                        n = np;
                    } while (n);
                    if (s.error == 0 && s.total > 1)
                        files.push(s);
                }
            });

            var _correlated = 0;
            function match(s) {
                for (var i = 0; i < dirs.length; i++) //(PVB COM) number of recognized files in the TOC
                    if (dirs[i].start == s) { //
                        dirs[i].correlated = true;
                        _correlated++;
                        return dirs[i];
                    }
                return null;
            }

            // now we have chains of files, recover those missing dir entries
            var i = 0;
            files.forEach(f => {
                if (!match(f.sector)) {
                    var name = "FILE_" + hex(i) + ".DAT"; //error correction i instead of i++
                    var name83 = "FILE_" + hex(i++) + " DAT";

                    // Reconstruct stopmed dirs
                    if (this.dir_sector == 361) {
                        var nom = this.one_dir(f.num);
                        if (nom.flags & 0x40) {
                            name83 = nom.name83;
                            name = nom.name;
                        }
                    }

                    if (f.used) {
                        console.log(name + " also used by " + f.used.name);
                    } else { //(PVB MOD) add numidf
                        var dir = { numidf: "--", sectors: [], valid: true, start: f.sector, total: f.total, name: name, name83: name83, flags: 0x42, recovered: true };
                        var offset = 0;
                        do {
                            dir.sectors[f.sector] = { sector: f.sector, slen: f.len, snext: f.next, fbloc: offset++ };
                            if (f.next == 0)
                                break;
                            f = sectors[f.next];
                        } while (f);
                        dirs.push(dir);
                    }
                }
            });
        }

        read_file(f) { //read_file() is called in load_data() and returns an array of byte data of the read file
            //(PVB MOD) simplification of read_file(), it is not the place to check sector chaining, we assume reading only a valid file
            if (this.sparta)
                return this.sparta.read_file(f.start);
            var data = [];
            //var count = f.total; //for DOS2X, count is the total sector number of the file
            //var sector = f.start; //initialize to the first sector
            var d = this.d;
            //previously // f.errors = 0; // see sector chaining in one_dir()
            //(PVB ADD) read the DOS 3 files; fsize is already compute in one_dir()
            if (this.dosType == 3) {
                f.sectors.forEach(s => {
                    var src = this.read_sector(s.sector)
                    for (var i = 0; i < src.length; i++)
                        data.push(src[i]);
                });
                data.splice(f.fsize); //clipped the size of the file to the f.fsize
                //if (f.fsize != data.length) console.log("read_file(): error of DOS 3 file size");
            }
            //(PVB END OF ADD)
            else {
                f.sectors.forEach(s => {
                    var src = this.read_sector(s.sector)
                    for (var i = 0; i < s.slen; i++)
                        data.push(src[i]);
                });
                f.fsize = data.length; //(PVB ADD) fsize 
            }

            return new Uint8Array(data);
        }
        //(PVB ADD) the identify_dos() function
        //(PVB TODO) optimize code to avoid repeating the same code & add other DOS support/// WIP ///
        identify_dos() {//identify_dos() is called by the constructor
            //let's assume that return value is -1 if no DOS found, 0 for Sparta, 1 for DOS1, 2 for DOS2.0, 2.5 dor DOS2.5, 3 for DOS3, 
            //4 for DOS4/DOSXL, 5 for DOSXE, 6 for MYDOS compatible with DOS2x, 7 for MYDOS with flag 03 (not compatible with DOS2x)
            if (this.sparta)
                return 0;
            //default
            var idos = -1;
            this.totalBloc = 0;
            this.freeBloc = 0;
            this.vtoc2_sect = 0;
            this.vtoc1_sect = 360;
            this.dir_sector = 361;
            this.file_start = 4;
     
            var vtocSect = this.read_sector(360); //read TOC at sector 360
            var t = le16(vtocSect, 1); //read total bloc
            var s = le16(vtocSect, 3); //read remainning free bloc
            var sc = this.sector_count;
            var str = "";

            function checkZeroIn(vtoc, s, e){ //checkZeroIn() called to check that part of TOC contains $00 (e is not included)
                var t = 0;
                for (var i = s; i < e; i++) {
                    t += vtoc[i];
                }
                return t; //return t = zero if zero
            }
            //check MyDOS...
            //VTOC must start with $02, $03 or higher byte, contain $00 at offset $37, and has a total-of-sector value
            if (t == 0x2C4 && vtocSect[0] == 2 && vtocSect[0x37] == 0) { //VTOC flag must be 02 for MyDOS compatible with DOS2x
                if (sc == 1040) str += " >720-sector MyDOS disk on a 1040-sector disk";
                idos = 6; //Mydos 720 sectors / 128B or 256B > "Single" or "Double"
            }
            else if (t == 0x403 && vtocSect[0] >= 3 && vtocSect[0x37] == 0) { //VTOC flag >= 03 is for 1040 sector or above, single density
                if (vtocSect[0] == 3 && sc == 720) str += " >1040-sector MyDOS disk clipped into a 720-sector disk";
                this.vtoc2_sect = 359; //at the minimum
                idos = 7; //Mydos >= 1040 sectors // 128B > "Enhanced" and more
            }
            else if (t == 0x594 && vtocSect[0] >= 3 && vtocSect[0x37] == 0) {
                if (sc <= 1040 && vtocSect[0] == 3) str += " >1440-sector MyDOS disk clipped into a smaller sector disk";
                if (vtocSect[0] > 3) this.vtoc2_sect = 359;
                idos = 7; //Mydos >= 1440 sectors // 256B > Double Side / Double Density
            }
            if (idos >= 6) { //MyDos
                if (this.d[16] != 0x4D) str += " >'M' byte signature is missing in the MyDos boot sector"; //info
                this.totalBloc = t;
                this.freeBloc = s;
                if (str) this.dirErrorStr = str;
                return idos;
            }
            //check DOS 2x...
            //VTOC must start with $01 or $02 byte, contain $00 at offset $37, and has a total-of-sector value
            if ((vtocSect[0] == 0x01) && t == 0x2C5 && vtocSect[0x37] == 0) {
                if (sc > 720) str += " >720-sector DOS1 disk on a 1040-sector disk";
                this.file_start = 2;
                idos = 1; //DOS 1
            }
            else if ((vtocSect[0] == 0x02) && t == 0x2C3 && vtocSect[0x37] == 0) {
                if (sc == 1040) str += " >720-sector DOS2x disk on a 1040-sector disk";
                idos = 2; //DOS2.0S or DOS2.0D
            }
            else if (vtocSect[0] == 0x02 && t == 0x03F2 && vtocSect[0x37] == 0) {
                if (sc == 720) {
                    str = " >1040-sector DOS2.5 disk clipped into a 720-sector disk";
                    str += " >VTOC2 is missing, free blocs value is wrong";
                    this.freeBloc = s;
                }
                else if (sc = 1040) {
                    if (is_zero(this.d, this.sector_offset(1024), this.sector_size))
                        str += " >1040-sector disk VTOC2 erased, end of disk may be corrupted";
                    this.freeBloc = s + le16(this.d, (this.sector_offset(1024) + 0x7A));
                }
                this.vtoc2_sect = 1024;
                idos = 2.5; //DOS 2.5 for enhanced
            }
            if (idos > 0) {
                this.totalBloc = t;
                this.freeBloc = s;
                if (checkZeroIn(vtocSect, 101, 128)) str += " >Error in DOS TOC that must end with $00 value bytes"; //info
                if (str) this.dirErrorStr = str;
                return idos;
            }
            //check DOS 3...
            //Directory must start with 14x $00 value bytes, contain $A5 signature, and has the total-of-bloc byte
            this.vtoc1_sect = 24;
            this.vtoc2_sect = 0;
            this.dir_sector = 16;
            var vdir = this.read_sector(16);
            t = vdir[0x0E];
            if (!checkZeroIn(vdir, 0, 14) && (vdir[0x0F] == 0xA5) && (t == 0x57 || t == 0x7F)) {
                if (t == 0x57 && sc == 1040)
                    str += " >720-sector DOS3 disk on a 1040-sector disk";
                if (t == 0x7F && sc == 720)
                    str += " >1040-sector DOS3 disk clipped into a 720-sector disk";
                this.totalBloc = t;
                vtocSect = this.read_sector(24);
                this.freeBloc = vtocSect.filter(arrayElement => arrayElement == 0xFE).length;
                if (str) this.dirErrorStr = str;
                this.file_start = 25;
                idos = 3;
                return idos; //DOS 3
            }
            //(PVB TODO) handle DOS XE and others //WIP ...
            this.dirErrorStr = " >No DOS disk system identified in the disk image file.";
            this.vtoc1_sect = 0;
            this.dir_sector = 0;
            return idos; //no DOS found
        }
        //(PVB END OF ADD)
    }

    //===================================================================================================
    // arc files

    function dearc_3(srcd, srclen, dstlen)    // RLE - after altirra
    {
        var dst = 0;
        var src = 0;
        var dstd = new Uint8Array(dstlen);

        let last = 0;
        while (dstlen) {
            let c = srcd[src++];
            if (c == 0x90) {
                if (!srclen--)
                    return null;
                let d = srcd[src++];
                if (d == 0) {
                    prevoutput = last;
                    if (!dstlen--)
                        return null;
                    dstd[dst++] = 0x90;
                } else {
                    let count = d - 1;
                    if (dstlen < count)
                        return null;
                    dstlen -= count;
                    while (count--)
                        dstd[dst++] = last;
                }
            } else {
                last = c;
                if (!dstlen--)
                    return null;
                dstd[dst++] = c;
            }
        }
        return dstd;
    }

    function dearc_8(srcd, srclen, dstlen)    // after altirra
    {
        var dst = 0;
        var src = 0;
        var n = 256;
        var last = 0;
        var byte2 = false;
        var bits = 9;
        var accum = 0;
        var accumbits = 0;
        var lastCode = 0;
        var codesRead = 0;
        var dstd = new Uint8Array(dstlen);

        var prev_link = new Int16Array(4096);
        var first_char = new Uint8Array(4096);
        var last_char = new Uint8Array(4096);
        var tmp = new Uint8Array(4096);
        for (var i = 0; i < 256; i++) {
            prev_link[i] = -1;
            first_char[i] = last_char[i] = i;
        }

        if (srcd[src++] != 0xC) // longest code length?
            return null;

        while (dstlen) {
            let code = 0;
            for (let i = 0; i < bits; ++i) {
                if (!accumbits) {
                    if (!srclen--)
                        return null;
                    accum = srcd[src++];
                    accumbits = 8;
                }

                if (accum & 1)
                    code += (1 << bits);

                accum >>= 1;
                --accumbits;
                code >>= 1;
            }

            ++codesRead;
            if (code > n)
                return null;

            if (code == 256) {
                let align = ((-codesRead & 7) * bits) >> 3;
                if (srclen < align)
                    return null;
                srclen -= align;
                src += align;

                // reset code table
                n = 256;
                bits = 9;
                lastCode = 0;
                accumbits = 0;
                accum = 0;
                codesRead = 0;
                continue;
            }

            if (n < 4096) {
                first_char[n] = first_char[lastCode];
                if (code == n)
                    last_char[n] = first_char[n];
                else
                    last_char[n] = first_char[code];
                prev_link[n] = lastCode;

                ++n;
                if (n >= (1 << bits) && bits < 12)
                    ++bits;
            }

            var tmpstart = 4096;
            for (var link = code; link >= 0; link = prev_link[link])
                tmp[--tmpstart] = last_char[link];

            while (tmpstart != 4096) {
                let c = tmp[tmpstart++]
                if (byte2) {
                    if (c == 0) {
                        last = 0x90;
                        if (!dstlen--)
                            return null;
                        dstd[dst++] = 0x90;
                    } else {
                        let count = c - 1;
                        if (dstlen < count)
                            return null;
                        dstlen -= count;
                        while (count--)
                            dstd[dst++] = last;
                    }
                    byte2 = false;
                } else {
                    if (c == 0x90)
                        byte2 = true;
                    else {
                        last = c;
                        if (!dstlen--)
                            return false;
                        dstd[dst++] = c;
                    }
                }
            }
            lastCode = code;
        }
        return dstd;
    }

    function arc_extract(id, pos) {
        var file = get_file(id);
        function extract(pos) {
            var f = file.arc[pos];
            var d = file.data.slice(pos, pos + f.compressed_size);
            switch (f.method) {
                case 3: d = dearc_3(d, f.compressed_size, f.original_size); break;
                case 8: d = dearc_8(d, f.compressed_size, f.original_size); break;
            }
            load_one(f.name, get_ext(f.name, d), d, "", "isFile"); //(PVB MOD) add arguments to load_one()
        }
        if (pos == -1)
            file.arc.forEach(a => extract(a.pos));
        else
            extract(pos);
        refresh_containers();
    }

    function show_arc(f) {
        var d = f.data;
        var files = [];
        var txt = [];
        var sel = [];
        var i;

        var _methods = [
            "End of archive marker",
            "unpacked (obsolete) - ARC 1.0 ?",
            "unpacked - ARC 3.1",
            "packed (RLE encoding)",
            "squeezed (after packing)",
            "crunched (obsolete) - ARC 4.0",
            "crunched (after packing) (obsolete) - ARC 4.1",
            "crunched (after packing, using faster hash algorithm) - ARC 4.6",
            "crunched (after packing, using dynamic LZW variations) - ARC 5.0",
            "Squashed c/o Phil Katz (no packing) (var. on crunching)"];

        var i = 0;
        f.arc = [];
        var count = 0;
        while (i < d.length) {
            if (d[i + 0] != 0x1A)
                break;
            var method = d[i + 1];
            if (!method)
                break;  // end of archive is 0x1A 0x00

            var name = '';
            for (var j = 0; d[i + 2 + j] && j < 12; j++)
                name += String.fromCharCode(d[i + 2 + j]);

            var file = {
                method: method,
                name: name,
                compressed_size: le32(d, i + 15),
                date: le32(d, i + 19),
                crc: le16(d, i + 23),
                original_size: le32(d, i + 25),
                pos: i + 29
            }
            f.arc[file.pos] = file;
            //(PVB MOD) add the display of html hyperlinks
            sel.push(`; <a href=#${file.name}>${file.name}</a><button style="float:right" type="button" onclick='arc_extract(${f.id},${file.pos})'>Extract</button>`);
            sel.push(`; ${file.original_size} bytes (${file.compressed_size} compressed)`);
            sel.push("");

            txt.push('; --------------------------------------------------------------------------------'); //(PVB MOD) add a separation line)
            txt.push('; <span id="'+ file.name + '">' + file.name + " raw data: </span>");
            txt.push('; ' + _methods[method] + ', ' + file.compressed_size + ' -> ' + file.original_size);
            txt.push('; <a href="#backtoarc">(back)</a>');
            txt.push(''); 
            txt.push(hex_dump(d, i + 29, file.compressed_size, 4));
            txt.push('');

            i += 29 + file.compressed_size;
            count++;
        }
        sel.unshift(`; <span id="backtoarc">${f.name} archive contains ${count} files: </span><button type="button" style="float:right" onclick='arc_extract(${f.id},-1)'>Extract All</button>\n\n`);
        sel.push("");

        render_file(f);
        _h("#show", sel.join("\n") + txt.join("\n"));
    }
    
    //===================================================================================================
    //(PVB ADD) ROM Image management and ROM dump display
    function show_rom(f) {
        var r = f.rom;
        var d = r.romData; //ROM with the CART header
        var bankMap = r.romMap;
        var sc = d.length - 16;
        var nb = []; //temp Array
        var txt = []; //string of text to display
        var romBank = []; //restructured banks of the rom
        var aname = []; //bytes in the A5200 ROM for the name and date, that will be transformed into string
        var str = ""; //tmp
        var i = 16;  //memory pointer
        var n = 0  //number of banks with same characteristic that are switched
        var k = 0; //number of bank * 2
        var l = 0; //bank counter
        _bShowA5200Equates = r.romMachine == "5200" ? true : false;
        r.rom_flag = 0xFF; //set default
        r.rom_init = 0; //set default
        while (n < bankMap.length) { //for every map
            var m = bankMap[n+2]; // number of bank
            for (var j = 0; j < m; j++) { //for each identical bank
                nb[k] = bankMap[n] * 0x100; //len of memory
                nb[k+1] = bankMap[n+1] * 0x100; //start address
                nb[k+2] = nb[k+1] + nb[k] - 1; //end address
                romBank.push({start: nb[k+1], end: nb[k+2], len: nb[k], offset: i}); 
                if (((r.romType == "21" || r.romType == "59" || r.romType == "53") && (nb[k+2] == 0x9FFF)) //Right Slot Cartridge or Low bank 8 KB Cartridge
                        || (nb[k+2] == 0xBFFF)) { //Normal Slot Cartridge
                    r.rom_flag = d[r.romData.length - 3]; //CARTFG => Cartridge ROM, normaly $04; For A5200: char date or $FF (see below)
                    r.rom_init = le16(d, r.romData.length - 2);  //CARTAD => initialization of start vector, same for A5200
                    if (r.romMachine == "5200") { //check if it is an A5200 Cartridge
                        //for the A5200 CART: $BFE8-$BFFB are the 20 char of title name; $BFFC-$BFFD for the (c) date
                        //see https://www.atarimax.com/freenet/freenet_material/5.8-BitComputersSupportArea/7.TechnicalResourceCenter/showarticle.php?51
                        aname = d.slice(r.romData.length - 24, r.romData.length - 2);
                        r.rom_coldstart = 0; // no CARTCS for A5200 cartridges
                    }
                    else {
                        r.rom_coldstart = le16(d, r.romData.length - 6); //CARTCS => cold start for 800/XL/XE Cartridges
                    }
                }
                if (nb[k+2] == 0xFFFF) r.rom_init = 0xFC00; // for the 2K A5200 ROM
                l++; //increment bank coiunter
                i += nb[k]; //adjust the memory pointer
                k += 3; //number of bank * 2 
            }
            n+=3;
        }
        r.romBankMap  = romBank;
        //r.romBankList = nb; //(PVB TODO) check if this is relevant to save the romBankList nb into the ROM array r
 
        if (!bankMap || bankMap.length == 0)
            txt.push(`; <b>ROM Image is ${r.romKBSize}KB ($${sc.toString(16).toUpperCase()} bytes) in total - No memory Mapping available - Please test above</b>`);
        else {
            txt.push(`; <b>ROM Image is ${r.romKBSize}KB ($${sc.toString(16).toUpperCase()} bytes) in total in ${l} banks of memory</b>`);
            if (r.romMachine == "5200") {
                str = "Atari 5200 ROM ";
                txt.push(`; ${str}<b>Initialisation Start Vector is $${hex(r.rom_init,4)}</b>`);
                //(PVB COM) Extracting A5200 rom name and date...
                let j = aname.length;
                while (j--) { //convert the char display
                    if (aname[j] > 0x7F) //(PVB TODO / experiment => check how the char above $7F are displayed)
                        aname[j] = 0;
                    if (aname[j] < 0x3F)
                        aname[j] += 0x20;
                    else 
                        aname[j] -= 0x20;
                }
                if (r.rom_flag != 0xFF) {
                    aname = toAscii(aname, 0, aname.length); //(PVB) for A5200 rom displayed name and date
                    txt.push(`; ${str}displayed name at OS boot is "` + aname.substring(0, 20) + ` (c) ATARI 19` + aname.substring(20, 22) + `"`);
                }
                else
                    txt.push(`; ${str}has no displayed name at OS boot, CARTFG = 0xFF`);
            }
            else {
                str = "Atari 800/XL/XE ROM ";
                txt.push(`; ${str}<b>Initialisation Vector CARTAD is $${hex(r.rom_init,4)}</b>`);
                txt.push(`; ${str}<b>Cold Start Vector CARTCS is $${hex(r.rom_coldstart,4)}</b>`);
                txt.push(`; ${str}<b>Cartridge Flag CARTFG is $${hex(r.rom_flag,2)}</b>`);
            }
        }
        l = 0;
        txt.push('\n; <b>ROM Bank Map:</b>');
        for (var j = 0; j < nb.length; j+=3) {
            txt.push(`; <a id="BKTOBANK${l}" href="#FWTOBANK${l}">Bank nbr ${l}</a>; size ${(nb[j]/1024)}KB; at memory $${hex(nb[j+1],4)}:${hex(nb[j+2],4)}`);
            l++;
        };
        l = 0;
        r.romBankMap.forEach(b => {
            txt.push(`\n` + _hr);
            str = `<span id="FWTOBANK`+ l + `"><strong>; HEX DUMP of Bank nbr ` + l + `; size: ` + b.len + ` ($` + b.len.toString(16).toUpperCase() + `) bytes = ` + (b.len/1024) + `KB`;
            str += `</strong> <a href="#BKTOBANK` + l + `">(back)</a></span><em class="bankcode" onclick="show_bank(` + l + `)">Toggle Disassembly/HexDump</em>`;
            txt.push(str);
            txt.push(`; Bank set to memory $` + hex(b.start,4) + ` : $` + hex(b.end,4));
            str = `;`;
            if (l > 0)
                str += ` <a href="#FWTOBANK` + (l-1) + `">(previous)</a> `;
            if (l < r.romBankMap.length - 1 )
                str += ` <a href="#FWTOBANK` + (l+1) + `">(next)</a> `;
            txt.push(str + "\n" + _hr);
            txt.push(`<div id="BANK_${l}" style="display:block">` + `\n` + hex_dump(d, b.offset, b.len, (b.start + l)) + `</div>`);
            l++;
            });

        render_file(f);
        _h("#show", txt.join("\n"));
    }
    //(PVB END OF ADD)

    //===================================================================================================
    // dump atr raw data

    //(PVB MOD) improvement of the show_atr() function //WIP//
    //handle DOS3, add ATR disk characteristics, mod display of boot sector, add DOS directory, mod display of sectors & blocs...
    function show_atr(f, rawmode) {
        //(PVB COM) show the ATR is_disk : 'ATR', ATX, PRO & XFD
        //rawmode is true with DSK file where the sectors are just listed
        var atr = f.atr;
        var d = atr.d; //d includes the 16 bytes of the ATR header !!
        var txt = [];
        var sparta = atr.sparta; //(PVB MOD) declaration here

        // just the raw sectors
        //(PVB COM) if rawmode => atr.sector_size is used for the size if sector, d is the data memory buffer to display,
        // the dump text is put in the txt variable, and display on the right after render_file (top) et #show (bottom with txt)
        if (rawmode) {
            var n = 0;
            for (; ;) {
                var size = n < 3 ? 128 : atr.sector_size;
                var offset = atr.sector_offset(n + 1);
                if (offset >= (atr.size + 16))
                    break;
                var zero = is_zero(d, offset, size);
                // (PVB MOD) add the hexa number sector, and count sectors from 1 and not zero (there is no sector zero for the atari SIO)
                var sect = n + 1;
                txt.push("; Sector " + hex(sect, 3) + " (" + sect + ")" + (zero ? " (" + size + " zeros)" : ""));
                //(previously) txt.push("; Sector " + n + (zero ? " (" + size + " zeros)":""));
                if (!zero) // (PVB COM) if the sector is not empty then we display the dump
                    txt.push(hex_dump(d, offset, size, 4));
                txt.push("");
                n++;
            }
            render_file(f);
            _h("#show", txt.join("\n"));
            return;
        }
        function pad_hex(h) { // pad_hex(n) is used to pad the value of the boot_record entries
            //(PVB COM) remplace the hex(n) with hex(n,4) if n is greater than 0xFF
            return h > 0xFF ? hex(h, 4) : '  ' + hex(h);
        }
        //(PVB ADD) pad_dec() function
        function pad_dec(x, n) { // pad_dec(n) is used to pad the value general
            x = "" + x; //convert x number into a string 
            return x.padStart(n, ' ');
        }
        //(PVB ADD) pad_dir(s, n) function
        function pad_dir(s, n){ //function pad_dir(s, n) is used to pad the display of the Directory (add space char after string)
            while (s.length < n)
                s = s + ' ';
            return s;
        }
        //(PVB COM) no rawmode => display the atari disk : boot flags & disassembly, directory, VTOC, sectors dump, etc...
        // source https://www.atariarchives.org/mapping/appendix17.php : DOS 2.5 loads its boot sector at address $700
        var _br = {  //$700 = standard DOS BOOT address
            BFLG: d[16],         //700: Boot flag; always equals 0.
            BRCNT: d[17],        //701: Number of sectors in the disk boot, -usually $03
            BLDADDR: le16(d, 18),//702: Boot load address; where DOS is loaded into memory; -usually $700 for DOS disk
            BINTAD: le16(d, 20), //704: DOS initialization address; -usually $1540
            BCONT: le16(d, 23),  //707: $4C jmp address for DOS2x, that is "$706  4C 14 07 ; JMP $0714"
            // (PVB COM) end of normal boot sector. Next is the DOS2x continuing structure:
            SABYTE: d[25],       //709: Maximum number of concurrently open files -usually $03
            DRVBYT: d[26],       //70A: Drive allocation byte; one bit per drive -usually $03
            SAFBFW: d[27],       //70B: -usually $00
            SASA: le16(d, 28),   //70C: Buffer allocation address for drives and files -usually $1A7C
            DFSFLG: d[30],       //70E: Reads zero if there is no DOS.SYS on disk, nonzero if present -usually $01
            DFLINK: le16(d, 31), //70F: Points to first sector of the DOS.SYS file (LSB first) -usually sector $04
            BLDISP: d[33],       //711: Number of displacement bytes to sector link bytes (last sector three bytes) = $7D (125)
            DFLADDR: le16(d, 34),//712: Address of the FMS (D:) handler table; -usually $7CB for DOS2x
            // $714 XBCONT  boot program continues at usually $714 as indicated in BCONT
        };
        if (d[22] != 0x4C) //(PVB ADD) if no jump $4C then br.CONT does not exist
            _br.BCONT = 0;

        /*(PVB COM) TODO => Check utility of available()
        function available(n) {
            return d[vtoc + 10 + (n >> 3)] & (0x80 >> (n & 3));
        }*/
        // Check validity of TOC => code is now /has been move in identity_dos() function in ATR class
        
        //(PVB ADD) check and identify the sector size of disk
        var density = "";
        var formatStrError = ""; //(PVB ADD)
        var ts = atr.sector_count; //(PVB ADD)
        if (ts <= 720) {
            // 720 sectors => Density 128 B/sect, ATARI 810 drive => for DOS1 & DOS2.0S, compatible all DOS;
            //             => Density 256 B/sect, ATARI 815 drive => for DOS2.0D, compatible with OSS DOS XL, DOS XE, Mydos, Sparta
            density = atr.sector_size == 128 ? "Single Density" : "Double Density";
        }
        else if (ts > 720 && ts <= 1040) {
            // 1040 sectors => Density 128 B/sect, ATARI 1050 drive => for DOS3 and DOS2.5, compatible all DOS except DOS1 & DOS2.0S
            density = "1050 Enhanced Density (Medium Density)";
        }
        else if (ts > 1040 && ts <= 1440) {
            // 2x720 sectors => Density 256 B/sect, ATARI XF551 drive => for DOSXE, compatible with MyDos (?), Sparta
            density = "Double Sided / Double Density";
            //(PVB TODO) Support DOS XE... /////////////////////////// WIP //
            //if (!atr.dosType != 6) //(PVB TODO) 6 was for MyDos => update if condition is for DOS XE
            //    formatStrError += "; Disk is a 1440 sectors DOS disk that can also be a DOS XE disk - not supported yet";
        }
        else console.log("show_atr() file " + atr.name + " has a wrong unknown sector_count: " + sc);
        
        txt.push(`; <b>Image has ${ts} ($${ts.toString(16).toUpperCase()}) sectors of ${atr.sector_size} bytes - ` + density + "</b>"); //(PVB MOD)
        //(PVB ADD)
        if (formatStrError) txt.push(formatStrError);
        if (atr.dosType > 0) {
            var t1 = "disk has been identified";
            var t2 = "1 bloc is 1 sector";
            switch (atr.dosType) {
                case 1: 
                case 2:
                case 2.5:
                    txt.push(`; DOS${atr.dosType} ${t1}, ${t2}`);
                    break;
                case 3: txt.push(`; DOS3 ${t1}, 1 bloc is 8 sectors`); break;
                case 6: txt.push(`; MyDOS ${t1} (compatible with DOS2), ${t2}`); break;
                case 7: txt.push(`; MyDOS ${t1} (not DOS2 compatible), ${t2}`); break;
            }
            if (atr.dirErrorStr) txt.push(`; WARNING${atr.dirErrorStr}`);
            if (atr.freeBloc || atr.totalBloc) {
                t1 = "; DOS disk has " + atr.freeBloc + " ($" + atr.freeBloc.toString(16).toUpperCase() + ") free blocs,";
                t1 += " among a total of " + atr.totalBloc + " ($" + atr.totalBloc.toString(16).toUpperCase() + ") blocs";
                txt.push(t1);
            }
            if (atr.vtoc1_sect) txt.push("; Jump to <a id='BOOT' href='#VTOC'>VTOC</a>");
            if (atr.vtoc2_sect) txt.push("; Jump to <a id='BOOT' href='#VTOC2'>VTOC2</a>");
            if (atr.dir_sector) txt.push("; Jump to <a href='#DIR'>Directory</a>");

        }
        else if (atr.dosType < 0)
            txt.push(`; WARNING${atr.dirErrorStr}`);
        
        txt.push("");
        //(PVB EN OF ADD)

        // Display boot sectors, disassemble them
        txt.push(";<b> Boot sector record:</b>"); //(PVB) update text
        var k = Object.keys(_br);
        //(PVB MOD & ADD)
        var bi = '', bic = '';
        for (var i = 0; i < (sparta ? 5 : k.length); i++) {
            txt.push("; " + bi + pad_hex(_br[k[i]]) + " " + k[i] + bic);
            //(PVB ADD) display more information about boot
            if (i == 3 && !sparta) {//(PVB COM) 3rd value => check the jump
                if (d[22] == 0x4C) //(PVB COM) test of the JUMP $4C to BCOUNT
                    txt.push("; Boot execution start with a JUMP to BCONT=$" + hex(_br[k[4]],4));
                else {
                    txt.push("; Boot execution start at BLDADDR+6=$" + hex(_br[k[2]]+6,4));
                    bi ="<i>"; //(PVB COM) set text in italic because it is not mandatory for a non DOS disk
                    bic ="</i>";
                }
                if (atr.dosType < 1 || atr.dosType == 3) break;
                txt.push("; " + bi + "<b>Additional DOS boot info:</b>" + bic);
            } //(PVB END OF ADD)
        }
        if (sparta) {
            txt.push("");
            txt.push("; <b>SpartaDOS</b>");
            var br = sparta.boot;
            var k = Object.keys(br);
            for (var i = 0; i < k.length; i++) {
                if (k[i] == 'volume_name')
                    txt.push(`;      ${k[i]} '${br[k[i]]}'`);
                else
                    txt.push("; " + pad_hex(br[k[i]]) + " " + k[i]);
            }
        }
        txt.push(";");

        //(PVB ADD) Prepare data for the Disk Sector Dump and display the file directory list
        // Scan files/sectors
        // TODO: Broken links, deleted files
        //(PVB MOD) cancel the use of get_dir() & add the restructured feature
        //previously //var dirs = atr.get_dir();
        var dirs = [];
        var blocsectors = []; //array for display file and its bloc / sector in the sector listing
        //(PVB ADD) display the directory of DOS files
        txt.push("");
        if (f.dosdir && f.dosdir.length)
            txt.push(`; <i>"${atr.name}"</i> has a directory with following DOS files:`);
        else
            txt.push(`; <i>"${atr.name}"</i> has no identified DOS files\n`);
        
        var strList = "";
        if (!atr.restructured && f.dosdir.length) {
            txt.push("; <b>Directory on disk " + (atr.isDos3 ? "(1 bloc = 8 sectors)" : "(1 bloc = 1 sector)") + ":</b>");
            txt.push("; Entry Flag Name          StartSector NbrBlocs    FileSize in bytes");
            //        ; #1    $80  12345678.123  $000(0000)  $000(0000)  $12345(123456)
            dirs = f.dosdir;
            //previously// dirs.forEach(dir => dir.sectors.forEach(s => { sectors[s.sector] = { dir: dir, sector: s } }));
            //(PVB END OF ADD)
            //(PVB MOD)
            dirs.forEach(fe => { //for each file entry from the dos directory
                fe.sectors.forEach(sect => {
                    blocsectors[sect.sector] = { dirName: fe.name, dirTotal: fe.total , dirOffset: sect.fbloc, dirSector: sect}
                });
                strList += ("; " + pad_dir(("#"+ fe.numidf),6) + "$"+ pad_dir(hex(fe.flags,2),4) + pad_dir(fe.name, 13));
                strList += (" $"+ hex(fe.start,3) + pad_dir((" (" + fe.start + ")"), 7)); //start sector
                strList += (" $"+ hex(fe.total,3) + pad_dir((" (" + fe.total + ")"), 7)); //total blocks
                strList += (" $"+ hex(fe.fsize,5) + pad_dir((" (" + fe.fsize + ")"), 9)); //file size
                if (fe.err) strList += fe.err;
                if (!fe.fsize || !fe.sectors.length) strList += " >empty entry"; //2 cases from which to be sure to identify an empty file, whatever dos
                strList += (fe.numidf == "--" ? " >may be recovered ?\n" : "\n");
            });
            txt.push(strList + ";");
            txt.push("");
        }
        else {
            console.log("show_atr() ATR has no DIR");
        }

        //(PVB COM) Display the disassembly of boot sectors
        var size = atr.sector_offset(_br.BRCNT + 1);    // 0 based for data to load
        var boot = d.slice(16, size); //(PVB COM) copy boot sector data, minus 16 first bytes (ATR header)
        //(PVB MOD & ADD)
        var entries = [_br.BINTAD];
        //(PVB COM) check boot sector validity
        //cont = is the address after the JMP, minus the boot load address (usualy $700)
        //if cont is negative, we keep cont for boot loading address; otherwise cont is the address after the JUMP
        //org = _br.BLDADDR = boot load address ; entry = cont
        if(_br.BCONT && (_br.BCONT -_br.BLDADDR) > 9)
            entries.push(_br.BCONT);

        txt.push(xex_dump(_br.BRCNT, boot, 0, boot.length, "BOOT", _br.BLDADDR, entries));
        txt.push('\n' + _hr);
        txt.push('; <b>Disk Boot sector hexdump</b>');
        txt.push(_hr + '\n');

        //(PVB COM) Display the sector of the ATR disk image file
        var n = 0; //(PVB COM) n is the sector counter
        var ns = 1;
        var bb = 0;
        for (; ;) { //(PVB COM) endless loop, stop when offset index is greater than the ATR size
            var size = n < 3 ? 128 : atr.sector_size;
            var offset = atr.sector_offset(n + 1);
            if (offset >= (atr.size + 16))
                break; //(PVB COM) ens of loop, last sector has been reached !
            
            var zero = is_zero(d, offset, size);

            switch (++n) {
                //case 360: txt.push("; <span id='VTOC'>VTOC Volume Table of Contents <a href='#BOOT'>(back)</a></span>"); break;
                case atr.vtoc1_sect:
                    txt.push("; <span id='VTOC'>VTOC Volume Table of Contents <a href='#BOOT'>(back)</a></span>"); break;
                case atr.dir_sector: txt.push("; <span id='DIR'>Directory <a href='#BOOT'>(back)</a></span>"); break;
                //case 1024: txt.push("; <span id='VTOC2'>VTOC2 Volume Table of Contents 2<a href='#BOOT'>(back)</a></span>"); break;
                case atr.vtoc2_sect:
                    txt.push("; <span id='VTOC2'>VTOC2 Volume Table of Contents 2<a href='#BOOT'>(back)</a></span>"); break;
            }
            var bsn = blocsectors[n]; // .sectors correspond au chainage des secteurs d'un fichier DOS valide
            var sstr = "";
            //var sdt = hex(dir.total,0);
            if (bsn) { //the sector belongs to a file
                //var sect = s.sector.offset + 1;
                var sb = bsn.dirOffset + 1; //dirOffset = number of the sector/bloc in the file
                sstr += " [" + bsn.dirName + (atr.dosType == 3 ? " - Bloc $" : " - Sector $") + hex(sb, 3) + "(" + sb + ") of $";
                sstr += hex(bsn.dirTotal, 3) + "(" + bsn.dirTotal + ")]"; 
                //sstr += " ($" + sect.toString(16).toUpperCase() + "/$" + s.dir.total.toString(16).toUpperCase() + ")]";
                if (atr.dosType == 3) {
                    bb = ((n - 0x19) >> 3) + 1;
                    if (ns == 9 && bsn.dirName) ns = 1;
                    sstr = sstr + " <i>[DOS3 bloc #" + bb + "/sect." + ns++ +"]</i>";
                }
            }
            //previously // var sstr = s ? ` (${s.dir.name} ${(s.sector.offset+1)} of ${s.dir.total})` : '';
            //previously // txt.push("; Sector " + n + (zero ? " (" + size + " zeros)":"") + sstr);
            //(PVB MOD) display sectors with counting from 1 and not 0
            txt.push('; Sector $' + hex(n, 3) + ' (' + n + ');' + (zero ? ' (' + size + ' zeros)' : '') + sstr);
            if (!zero)
                txt.push(hex_dump(d, offset, size, 4));
            txt.push('');
            if (n == _br.BRCNT) { // for the last sector of the boot
                txt.push(';<i>End of Disk Boot sector hexdump \><a href="#top">Back to top</a></i>\n');
                txt.push(_hr);
                txt.push('; <b>Disk sector hexdump</b>');
                txt.push(_hr);
                txt.push('');
            }
        }
        txt.push(';<i>End of Disk sector hexdump \><a href="#top">Back to top</a></i>');

        render_file(f);
        _h("#show", txt.join("\n"));
    }

    //(PVB ADD) function show_extract(f) //WIP// to limits the extract possibility according to ext
    function show_extract(f) {
        var sSize;
        if (f.type == "isTxtImg") return; //no extract
        if (f.type == "isDisk") {
            var atr = f.atr;
            var d = atr.d.slice(16, atr.d.length); // data without the ATR 16-bytes header
            sSize = atr.sector_size;
        }
        else { //assume it is "isFile" here
            var d = f.data;
            sSize = 0;
        }
        var txt = [];
        console.log("show_extract() ===>...render_file (f)..."); //(PVB CONSOLE HINT)
        if (f.launch_extract){
            if (f.type == "isDisk") {
                var ss = _extracted_disk.start_sect; 
                var es = _extracted_disk.end_sect;
                var so = _extracted_disk.start_sect_off;
                var ad = _extracted_disk.start_add;
                var sta = (ss < 4) ? (so + (ss - 1) * 128) : (384 + so + (ss - 4) * atr.sector_size);
                var sto = (es < 4) ? (es * 128 - 1) : (384 + (es - 3) * atr.sector_size - 1);
                if (sta < sto && sto <= d.length) { //(PVB COM) protection in case of extract_disass() has done wrong
                    var de = d.slice(sta, sto + 1);
                    render_file(f);
                    _h("#show", xex_dump("Disk extracted data", de, 0, de.length, "EXTRACT", ad));
                }
                else
                    alert("show_extract() ==> error");  //(PVB COM) display an error in case of () has done wrong
            }
            else {
                var so = _extracted_file.start_offset; 
                var eo = _extracted_file.end_offset;
                var ad = _extracted_file.start_add;
                if (so <= eo && eo < d.length) { //(PVB COM) protection in case of extract_disass() has done wrong
                    var de = d.slice(so, eo + 1);
                    render_file(f);
                    _h("#show", xex_dump("File extracted data", de, 0, de.length, "EXTRACT", ad));
                }
                else
                    alert("show_extract() ==> error");  //(PVB COM) display an error in case of () has done wrong
            }
        }
        else {
            render_file(f);
            _h("#show", hex_dump(d, 0, d.length, sSize));
        }
        return;
    }
    //(PVB END OF ADD)

    //(PVB MOD) improvement of the show(id) function
    function show(id) { //(PVB COM) show(id) is call on click event on file canva container to display the file on page right
        //id is the number of file in the container files, last available value is in the global variable _id
        try {
            var f = get_file(id);
            //(PVB MOD) use of get_type() that is already in f.type instead of e = _exts[f.ext];
            console.log("show(id) =>id: " + id + ", Name: '" + f.name + "', file type: " + f.type); //(PVB CONSOLE HINT)
            if (f.type == "spacer") { //in case of "spacer" set the click to the next id that must be the ATR disk
                f = get_file(++id);
                console.log("show(id) =>get next id: " + id + ", Name: '" + f.name + "', file type: " + f.type); //(PVB CONSOLE HINT)
            }
            if (f.data.length == 0){
                alert("Nothing to show ! The selected file  " + id + ", Name: '" + f.name + "', file type: " + f.type + " is empty !"); //(PVB ADD) (PVB CONSOLE HINT)
                return;
            }
            //if (e && e.is_disk)
            //    f.isDisk = true;
            _shown = f; //(PVB COM) save the current selected file into the _shown global variable
            if (_shown.extractrequest) {
                show_extract(f);
                return;
            }
            if (f.ext == "bas") {
                show_bas(f);
                return;
            }
            if (f.ext == "m65") {
                show_m65(f);
                return;
            }
            if (f.ext == "fnt" || f.ext == "set") {
                show_fnt(f);
                return;
            }
            if (f.ext == "arc") {
                show_arc(f);
                return;
            }
            //(PVB ADD) ROM Dump
            //if (e && e.is_romdump){
            if (f.type == "isRomdump"){
                show_rom(f);
                return;
            }
            //if (e && e.is_disk) {
            if (f.type == "isDisk") { //for the atari disk like XFD, ATR...
                show_atr(f, f.ext == "dsk"); //(PVB COM) Rawmode in show_atr() if ext == "dsk"
                return;
            }
            //other files

            var e = f.ext == "???" ? _exts["dat"] : _exts[f.ext]; //(PVB ADD) mandatory : if extension is unknown (???), then force .dat

            if (e && e.is_img) {
                show_img(f);
                return;
            }
            if (e && e.is_txt) {
                show_txt(f);
                return;
            }
            console.log("show(id) =>...render_file (f)..."); //(PVB CONSOLE HINT)
            render_file(f); //(PVB COM) display title and selection list on page top right

            if (e && e.is_code) { //(PVB COM) when it si "is_code" (and not a ROM or an Atari disk) => disassemble it !
                console.log("show(id) => xex_dump() of '" + f.name + "'");//(PVB CONSOLE HINT)
                //display of disassembly code in the <pre id="show"
                _h("#show", xex_dump(f.name, f.data, 0, f.data.length, (e.has_header ? "HEAD" : ""))); //(PVB COM) Shall have an header
                return;
            }
            //(PVB COM) here we have a special file like "???" or "DAT"
            console.log("show(id) => HEX_dump() of '" + f.name + "' with extension:" + e.ext);//(PVB CONSOLE HINT)
            _h("#show", hex_dump(f.data, 0, f.data.length)); //(PVB COM) default hex_dump() as for a DAT file
        }
        catch (err) {
            console.log(err);
            show_as("dat");
        }
    }

    function show_as(e) {
        if (_shown) {   //(PVB COM) _shown is the 'file' shown on right page
            if (!_shown.original_ext)
                _shown.original_ext = _shown.ext;
            _shown.ext = e;
            refresh();    // select one
        }
    }

    function toggle_hex() {//toggle_hex() is used to force display of the file hex dump
        if (!_shown) return;
        if (_shown.ext == "dat")
            show_as(_shown.original_ext);
        else
            show_as("dat");
    }

    //(PVB ADD)
    function toggle_extract() {
        if (!_shown) return;
        if (_shown.type == "isTxtImg") return;
        if (_shown.extractrequest){
            _shown.extractrequest = 0;    
            refresh();
        }
        else {
            _shown.extractrequest = 1;
            refresh();
        }    
    }
    //(PVB END OF ADD)

    function refresh() {
        show(_shown.id);
    }

    function close_container(id) { //close_container(id) is called when user click on the cross to close file on page left
        for (var i = 0; i < _containers.length; i++) {
            if (_containers[i].id == id) {
                _containers.splice(i, 1);
                break;
            }
        }
        render_state(_containers);
    }

    //(PVB MOD) improvement of load_one(): handle ROM file, display of size in KB or B
    function load_one(name, ext, a, imgTag, t) { //(PVB COM) load_one() is called by load_data() when the OS/Windows Image file is not a disk with several DOS files
        //(PVB ADD) handling the ROM case with the ROM constructor
        var r;
        console.log("load_one() loads " + name + " that is a '" + t + "' into the container"); //(PVB HINT)
        if (t == "isRomdump") {
            r = new ROM(a, name);
        }
        //(PVB ADD) handling the computation of the image size in KB or B
        var strSize = '';
        if (a.length < 1024) {
            strSize = a.length + "B ";
        }
        else {
            n = (a.length & 0x3FF) ? (a.length >> 10) + 1  : a.length >> 10 ;
            strSize = n + "KB";
        }
        //(PVB enf of ADD)
        //(PVB MOD) //Previously // var f = { name: name, ext: ext, data: a, id: _id++, total: ((a.length + 127) >> 7, img: img };
        var f = { name: name, ext: ext, type: t, data: a, id: _id++, total: strSize, imgTag: imgTag };
        //(PVB ADD)
        if (r && t == "isRomdump")
            f.rom = r;
        //(PVB enf of ADD)
        var i = name.lastIndexOf(".");
        var ext83 = ext;
        if (i != -1) {
            ext83 = name.substr(i + 1);
            name = name.substr(0, i);
        }
        if (i > 8 || ext83.length > 3){ //(PVB MOD)
            f.name83 = name.substr(0, 5); //(PVB MOD)
            f.name83 += "..."; //(PVB MOD)
        }
        else{ //(PVB MOD)
            f.name83 = name.substr(0, 8);
            while (f.name83.length < 8)
                f.name83 += ' ';
        }
        f.name83 += ext83.toUpperCase().substr(ext83.length - 3, 3);
        _containers.unshift({ name: f.name, ext: ext, type: "container", data: a, files: [f], id: _container_id++ }); //(PVB MOD) single file into container
        return f;  //(PVB COM) the return of "f" is required with flush_images() function via the load_data() that calls the load_one()
    }

    //(PVB MOD) improvement of load_data()
    function load_data(name, a, imgTag) { //(PVB COM) load_data() is called by load() and flush_images() to load the OS/Windows Image file into memory
        //(PVB COM) name = full filaname of the OS/Windows file like "Foo.XFD"; a =  data of the OS/Windows file;
        // imgTag = the image type/mime when an OS/Windows loads an image, used when there is no file extension
        var ext = get_ext(name, a, imgTag); //(PVB COM) get the filename extension
        //(PVB MOD) the new function get_type() to remplace "var e = _exts[ext]; "
        var t = get_type(ext);
        //(PVB COM) if not an "isDisk", there is no DOS files in a directory to retreive, so it is a single file to open with load_one()
        if (t != "isDisk") { //(PVB COM) //previously // if (!e || !e.is_disk)
            return load_one(name, ext, a, imgTag, t);
        }
        console.log("load_data() loads the 'isDisk' into an ATR file..."); //(PVB HINT)
        //(PVB MOD) improvement of the files array
        var atr = new ATR(a, name);
        var files = []; //"files" array is the list of files to be displayed in the blue directory on page left by render_state(m)
        if (!atr.restructured) { //(PVB ADD) if "restructured" no need to seek for a directory if it is an restructured ATR disk
            var dirs = atr.get_dir();
            dirs.forEach(f => {
                //f.dosType = atr.dosType; //tagged files f with atr dosType
                if (f.valid && f.sectors.length) { //if not valid, or no sectors (empty file) the file shall not be displayed
                    var file = { name: f.name, name83: f.name83, id: _id++, start: f.start, total: f.total, flags: f.flags, recovered: f.recovered, is_dir: f.is_dir};
                    //file.isDos3 = atr.isDos3; //(PVB ADD) set the DOS type found into the ATR disk in the DOS file (important for the read_file() process)
                    file.data = atr.read_file(f);
                    //(PVB COM) initialisation of the file size in the directory: "dirs.fsize" is done in read_file()
                    /* chaining check in one_dir make the error check, f.errors does not exists anymore
                    //if (f.errors) { 
                    //    console.log("Load_data() for ATR : Error reading DOS file " + f.name);
                    //    console.log(f);
                    }*/
                    file.dosType = atr.dosType; //copy dosType in the file
                    file.ext = get_ext(file.name, file.data); //actual ext from get_ext() in the file (and not from filename ext)
                    file.type = get_type (file.ext);
                    //file.type = "isFile"; //(PVB ADD) the "isFile" type for identifying retreived DOS files on an ATR disk
                    files.push(file);
                }
            });
            console.log("load_data() ATR file " + name + " has a DOS directory with " + files.length + " valid DOS files"); //(PVB HINT)
        }
        else {
            console.log("load_data() file " + name + " ATR has been restructured, no DOS directory applicable"); //(PVB HINT)
        }
        //(PVB COM) files = table of valid ATARI DOS files found into the ATR disk; so files.length is the number of files
        if (files.length) {
            //(PVB COM) if files where found, add a spacer (empty line) under the directory list as a file, that will be displayed in blue on left
            //(PVB MOD) the "spacer" type: name83 is empty, ext is empty. 
            //previously// files.push({ name83: "", name: name, ext: "", data: [], id: _id++ });
            files.push({ name83: "", name: "", ext: "", type: "spacer", data: [], id: _id++});
        }
        //(PVB MOD) add the name of the ATR disk file as the last file in the list
        //.name 83 : is used to display the number of sector on ATR disk, .name is the name of the ATR File (foO.XFD)
        //.type is set to the type of file, which is a "isDisk", .data : is set to the data of the ATR disk
        //.atr and .dosdir are added to save the atr construction data, and the valid DOS directory found
        files.push({ name83: (atr.sector_count + "-sector disk"), name: name, ext: ext, type: "isDisk", data: a, id: _id++, atr: atr, dosdir: dirs });
        _containers.unshift({ name: name, length: a.length, data: a, ext: ext, type: "container", files: files, id: _container_id++ }); //(PVB MOD) files into container
        console.log("load_data() has loaded " + name + " (and its DOS files) into the container"); //(PVB HINT)
    }

    //===================================================================================================
    // https://www.atarimagazines.com/software/software.html

    var _images = [];

    function flush_images() {
        _images.forEach(f => {
            var b = '';
            for (var i = 0; i < f.data.length; i++)
                b += String.fromCharCode(f.data[i]);
            var url = `data:${f.file.type};base64,${btoa(b)}`;

            var img = document.createElement('img');
            img.src = url;
            img.hidden = true;
            img.onload = (evt) => {
                load_data(f.file.name, f.data, img).edit_img = 1;
                refresh_containers();
                document.body.removeChild(img);
            }
            document.body.appendChild(img);
        });
        _images = [];
    }

    function refresh_containers() { //(PVB COM) refresh_containers() is used to select the first file on the list on page left to be shown on the right!
        render_state(_containers);
        if (_containers.length)
            show(_containers[0].files[0].id);    // select on 
    }

    // #153382 - BG 0x94

    function open() {
        _q("#fe").click();
    }
    
    function load() { // (PVB COM) load() is the HTML Javascript main function
        drop_init(_q("#toc"),
            (file, ab) => { //(PVB COM) file = OS/windows file; name = name of the OS/windows file, and properties
                //ab = ArrayBuffer for the file data (byteLenght = size of the file)
                if (file.type.indexOf("image") != -1) //check file MIME type, if is is an image
                    _images.push({ file: file, data: new Uint8Array(ab) }); //if so, file is push in _images
                else //it is not an OS/Windows image file
                    load_data(file.name, new Uint8Array(ab)) //file data is loaded by the load_data() function
            },
            () => {
                flush_images();
                refresh_containers();
            }
        );
        _fcanvas = get_font(_font);

        document.body.onkeyup = function (e) {
        }

        document.onselectionchange = selection_change; //(PVB COM) watch where is the mouse pointer, and if text is selected by the carret

        document.body.onkeydown = function (e) {
            if (e.ctrlKey && e.shiftKey) {
                switch (e.key) {
                    case 'o':
                    case 'O':
                        open();
                        break;  // open a file....
                    case 'h':
                    case 'H':
                        toggle_hex();
                        break;  // toggle hex display
                    case 'k':
                    case 'K':
                        toggle_kb();
                        break;  // toggle keyboard
                }
            }
        };
        render_state(_containers);
    }

    function toggle(eid) {
        var e = _q(eid);
        e.style.display = e.style.display == "none" ? "block" : "none";
    }

    //(PVB ADD) show_bank(id) function is called by show_rom(f)
    //Note : the button [Toggle Disassembly/HexDump] set in show_rom(f) calls the show_bank(id) function to toggle disassembly / hex dump
    function show_bank(id) {
        var r = _shown.rom;
        var eid ="#FWTOBANK" + id;
        var s = _q(eid);
        var str = s.innerHTML;
        var eid ="#BANK_" + id;
        if (str.lastIndexOf("HEX DUMP") > 0)
        {
            s.innerHTML = str.replace("HEX DUMP", "DISASSEMBLY");
            var entries = [r.rom_init, r.rom_coldstart];
            _h(eid, xex_dump("ROM Cartridge", r.romData, r.romBankMap[id].offset, r.romBankMap[id].len, "ROM_" + hex(id,2), r.romBankMap[id].start, entries));
        }
        else
        {
            s.innerHTML = str.replace("DISASSEMBLY", "HEX DUMP");
            _h(eid, "\n" + hex_dump(r.romData, r.romBankMap[id].offset, r.romBankMap[id].len, (r.romBankMap[id].start + id)));
        }
    }
    //(PVB END OF ADD)

    //(PVB MOD) improvement of function ext_option() add the enabling/disabling list fields when required
    function ext_option(f) { //(PVB COM) ext_option(f) function is called by render_file(f) for the selection list of ext types 
        //(PVB ADD) The enable table of extension for the selection list of ext types
        const _entable = {
            "isArc" :     [0,0,0,0,0,1,1, 0, 0,0,0,0,0,0,0,0,0,0, 0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0, 0,0,0,0,0,0,0,0,0],
            "isDisk" :    [1,1,1,1,1,1,0, 0, 0,0,0,0,0,0,0,0,0,0, 0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0, 0,0,0,0,0,0,0,0,0],
            "isRaw" :     [1,1,1,1,1,1,1, 0, 1,1,1,1,1,1,1,1,1,1, 0, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 0, 1,1,1,1,1,1,1,1,1],
            "isFile" :    [0,0,0,0,0,1,0, 0, 1,1,1,1,1,1,1,1,1,1, 0, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 0, 1,1,1,1,1,0,0,0,0],
            "isTxtImg" :  [0,0,0,0,0,1,0, 0, 1,1,1,1,1,1,1,1,1,1, 0, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 0, 1,1,1,1,1,0,0,0,0],
            "isRomdump" : [0,0,0,0,0,1,0, 0, 0,0,0,0,0,0,0,0,0,0, 0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0, 0,0,0,0,0,1,1,1,1]
        };
        var s = `<div style='display:inline-block'><label>Ext Type :<select onchange="show_as(this.value)">`;
        //(PVB MOD) Add display of extension in the list
        //previously// Object.keys(_exts).forEach(ext => s += `<option ${ext[0] == '-' ? "disabled" : ""} value='${ext}' ${ext == f.ext ? 'selected' : ''}>${_exts[ext].name} ${ext[0] == '-' ? "" : " (" + ext + ")"}</option>`);
        var i = 0;
        Object.keys(_exts).forEach(ext => s += `<option ${_entable[f.type][i++] ? "" : "disabled"} value='${ext}' ${ext == f.ext ? 'selected' : ''}>${_exts[ext].name} ${ext[0] == '-' ? "" : " (" + ext + ")"}</option>`);
        s += `</select></label></div>`;
        return s;
    }

    //(PVB ADD) rom_option(f) function is called by render_file(f) for the selection list of ROM types
    function rom_option(f) {
        var s = `<label>Rom Type Selection: <select id="rommapid" onchange="apply_rommap(${f.id})">`;
        var k = f.rom.romKBSize;
        var t = f.rom.romTypeTxt;
        Object.keys(_romtypes).forEach(r =>
            s += `<option ${((r[5] == '#') || (_romtypes[r].size != k)) ? "disabled" : ""} value='${r}' ${(r == t) ? "selected" : ""}>
                ${r + ": " + _romtypes[r].name + " [" + _romtypes[r].machine + "]"}</option>`);
        s += `</select></label>`;
        return s;
    }
    //(PVB END OF ADD)

    function finfo(f) { //(PVB COM) finfo(f) function is called by render_state(m)
        var t = _exts[f.ext] ? _exts[f.ext].name : "'" + f.ext + "' file";
        return `<b>${f.name}</b><div style="font-size:small">${t} (${f.data.length} bytes)</div>`;
    }

    function redraw_palette() {
        _h(".palette", palette(_palette));
    }

    function pick_click(c, i) {
        _palette[c] = i;
        _reload_palette = 0;    // make sure our changes take
        refresh();
        redraw_palette();
        _reload_palette = 1;
    }

    var atari2css = (i) => '#' + hex(atari_palette_rgb[i], 6);
    function palette(colors) {
        function atari256(c) {
            var s = [];
            for (var i = 0; i < 256; i++)
                s.push(`<div class='acolor' title='${hex(i)}' onclick='pick_click(${c},${i})' style='background:${atari2css(i)}'></div>`);
            return s.join("");
        }
        var s = [];
        for (var c = 0; c < colors.length; c++) {
            s.push(
                `<div class='dropdown'>
                <div class='acolor' title='${hex(colors[c])}' style='background:${atari2css(colors[c])}'>
                    <div class='dropdown-content'>${atari256(c)}</div>
                </div>
            </div>`
            );
        }
        return s.join("");
    }

    function pick_mono(cr) {
        _mono_cr = cr;
        _radios["scheme"].value = 0;    // mono
        refresh();
    }

    function refresh_image_controls(f) {
        function monochrome() {
            var s = '';
            for (var i = 0; i < 16; i++) {
                var c = (i << 4) | 8;
                s += `<div class='acolor' title='${hex(c)}' onclick='pick_mono(${c >> 4})' style='background:${atari2css(c)}'></div>`;
            }
            return s;
        }
        _h("#image_controls", `
    <div class='exts' style="padding:8px">
        <div><b>dither</b><span class='radio'>${radio_init('dither', ['atkinson', 'floyd-steinberg', 'noise', 'ordered', 'none'])}</span><div><br />
        <div><b>scheme</b><span class='radio'>${radio_init('scheme', ['monochrome', 'r:g', 'random', 'kmeans', 'octree', 'median'])}</span><div><br />
        <div><b>monochrome</b><span style='padding-left:12px'>${monochrome()}<span><div><br />
        <div><b>distance</b><span class='radio'>${radio_init('distance', ['rgb', 'yiq', 'y'])}</span><div><br />
    </div>`);
    }

    function render_state(m) { //render_state(m) is mainly called by the main load() function, for containers 'm' display on page left, after loaded an OS/Windows file
        //(PVB COM) rendering = display the content at the left side of the HTML page (#menu_container) + init the right side if no file loaded
        var h;
        if (m.length == 0) {
            h = `<div style="text-align:center;color:#AAA"><h2>Drag Files Here</h2><h2>or</h2></div>`;
            _h("#tabs", "");
            _shown = null; //reset the _shown global variable
        } else //(PVB COM) display the file name, the type, and the size on the left, above the file list (this is the container)
            h = m.map(container =>
                `<div>
            <span class='close-icon' onclick="close_container(${container.id})"></span>
            <div class='infof'>${finfo(container)}</div>
            <ul id="menu">
            ${container.files.map(file =>
                    `<li onclick="show(${file.id})">
                    <div><canvas id="canvas${file.id}"></canvas></div>
                </li>`
                ).join("")}
            </ul>
        </div>`
            ).join("");
        _h("#menu_container", h);

        //(PVB MOD) info(f) function improvement, DOS 3 support
        function info(f) {//info(f) is called by render_state(m), to display file characteristics on top left above file display
        //(PVB COM) f = DOS file from the Atari DOS file table
        //in case of single file, function load_one() initializes f.total with the KB or B size, like "17KB" for exemple
        //in case of mutiple files, load_data()->get_dir() initializes each file with DOS-number-of-blocs in f.total 
            var sLine = '';
            //(PVB COM) sLine format is "1234567890123456789012"
            //(PVB COM)             for ".*<FILENAMEext>..XXX.."
            var nFile = f.name83; // DOS filename (or number of sector for disk size if the container file is the "isDisk")
            var isDos3 = f.dosType == 3;
            //(PVB MOD)
            if (f.total) { //if the variable total exists and not equal to zero, display f.total in KB, B or in Secteurs size
                sLine += f.total; //(PVB COM) we start the string line from the end where the size in KB or B is displayed
                if (!isNaN(f.total)) { //padding of the DOS file size on 3 digit numbers with 0 at beginning...
                    while (sLine.length < 3)
                        sLine = '0' + sLine; //add 0 at the beginning
                    sLine += "  "; //add 2 spaces at the end
                    sLine = " " + sLine; //add 1 space at the beginning
                }
                else {  //(PVB MOD) padding the file size in B or KB to 6 total char, with space at the beginning
                    while (sLine.length < 6)
                        sLine= " " + sLine; //add space at the beginning
                }
            }
            else { //(PVB COM) there is no f.total: it is the spacer line or the total number of sector of disk to display
                //note : if f.total is 0, it means an empty file and this file is not listed in the "files" array to be displayed (see load_data())
                sLine = "   " + nFile; //nFile is empty, or nFile is the total sector on the disk
                while (sLine.length < 22) // we pad it at 22 chars
                    sLine = sLine + ' '; // padding with space
                return sLine;   // and directly display it
            }
            //(PVB MOD) nFile = f.names83, contains the DOS filename, we pad it on 11 chars
            while (nFile.length < 11)
                nFile += ' ';
            //(PVB MOD) Add the DOS flag management (based on DOS2.5)
            var locked = ((!isDos3 && (f.flags & 0x20)) || (isDos3 && (f.flags & 0x02))) ? "*" : " "; // '*filen.ame' for locked DOS file (non erasable)
            //(PVB MOD) Add the DOS "Opened File" from 1st bit and display it as in DOS2.5 with <> chars, like "<filename>"
            if (f.flags == 0x80) {
                return " " + " " + "[" + nFile + "] " + sLine; // '[filen.ame]' for erased DOS file
            }
            else if (f.flags & 0x01) {
                return " " + locked + "<" + nFile + "> " + sLine; // '<filen.ame>' indicates an open DOS file for DOS2, or a file stored above sector 720 for DOS2.5
            }
            else {
                return " " + locked + " " + nFile + "  " + sLine; // normal DOS file
            }
        }
        //(PVB END OF MOD)

        m.forEach(container => {
            container.files.forEach(file => draw_line(`#canvas${file.id}`, info(file), file.recovered, file.is_dir));
        });

        // show supported file types and extensions 
        if (m.length == 0) {
            var s = `<div class='exts'>`;
            Object.keys(_exts).forEach(ext => s += ext[0] == '-' ?
                `<div><b></b><strong>${_exts[ext].name}</strong><div>` :
                `<div><b>${ext}</b>${_exts[ext].name}<div>`
            );
            s += `</div>`;
            _h('#tabs', s);
        }
    }

    
    //(PVB ADD) render_extract(f, isDisk) function is for rendering extract menu only, called by render_file(f) function
    function render_extract(f, isDisk) {
        var str = `pattern='[0-9a-fA-F]{1,4}' placeholder='0...FFFF' title='Address in valid hex code 0...FFFF'`;
        var addmenu = `
    <div class='extract'>
        <form id='hexmenu' onsubmit='return extract_disass(${isDisk ? f.atr.sector_size : ("0," + f.data.length)});'>
        <fieldset><legend><b>Extract data from ${isDisk ? "disk" : "file"} and disassemble Menu: </b></legend><div style='display:flex;flex-direction:row;justify-content:space-between;align-items:flex-start;'>`;
        if (isDisk)
            addmenu += `<div>
            <label for='start_sect'>Start sector: </label>
                <input type='number' id='start_sect' name='start_sect' value='${_extracted_disk.start_sect}' min='1' max='${f.atr.sector_count}'>
            <label for='end_sect'> =&gt to end sector: </label>
                <input type='number' id='end_sect' name='start_sect' value='${_extracted_disk.end_sect}' min='1' max='${f.atr.sector_count}'>
                <span> <em>(in dec) </em></span><br />
            <label for='start_sect_off'>Offset Byte in start sector: </label>
                <input type='number' id='start_sect_off' name='start_sect_off' value='${_extracted_disk.start_sect_off}' min='0' max='${f.atr.sector_size - 1}'>
                <span> <em>(in dec) </em></span>
            </div>`; 
        else //this is not a file with Sector but data
            addmenu += `<div>
            <label for='start_offset'>Start Offset at (hexa): $</label>
                <input size='6' type='text' id='start_offset' name='start_offset' ${str}
                value='${_extracted_file.start_offset.toString(16).toUpperCase()}'><span> <em>(Min $0) </em></span><br />
            <label for='end_offset'>End Offset at (hexa): $</label>
                <input size='6' type='text' id='end_offset' name='end_offset' ${str} 
                value='${_extracted_file.end_offset.toString(16).toUpperCase()}'><span> <em>(Max $${hex(f.data.length-1, 6)}) </em></Span><br />
            </div>`;
        addmenu += `
            <div><input class='buttonstyled' type='button' value='ReShow full\nHex Dump' onclick='extract_reset()'></div> 
            </div>   
            <div><label for='start_add'>Disassembly start at (hexa): $</label>
                <input size='4' type='text' id='start_add' name='start_add' ${str}
                    value='${isDisk ? _extracted_disk.start_add.toString(16).toUpperCase() : _extracted_file.start_add.toString(16).toUpperCase()}'>
                    <span> <em>(Valid are from $0 to max $FFF9)</em></Span>
            </div>
            <div style='display:flex;flex-direction: row;justify-content: space-between;align-items: center;'>
                <input class='buttonstyled' type='submit' value='EXTRACT & DISASSEMBLE'>
                <div id='extractinfo' class='extractinfo' style='color:#F00'></div>
            </div>
            </fieldset></form>
    </div>`;
        return addmenu;
    }
    //(PVB END OF ADD)

    //(PVB ADD) showDisOption() function is for rendering disassembly option menu only, called by render_file(f) function
    function showDisOption() {//showDisOption() is called by render_file() to display option in case of disassembly listing
        var dof = [
            ["_bShowATRFont", _bShowATRChar, "A", "Listing display with Atari Font"],
            ["_bShowLinks", _bShowDisLinks, "L", "Show destination address in hyper links"],
            ["_bShowBRK", _bShowDisBRK, "B", "Accept to disassemble up to 2 BRK instructions"],
            ["_bShowBank", _bShowROMBank, "K", "Show address with Rom bank number B00..FF"],
            ["_bShowFlags", _bShowDisFlags, "F", "Show instruction flags (info for dev)"]
        ];
        var tmpstr = `<div class='doblock'><form id='disoptionform'><fieldset><legend><b>Display & Disassembly options:</b></legend>`;
        for (var i = 0; i < dof.length; i++) {
            tmpstr += `<div class='docbgrp'><input type='checkbox' id='${dof[i][0]}' ${dof[i][1] ? "checked" : ""} onchange='toggle_bShow("${dof[i][2]}")' /> <label for='${dof[i][0]}'>${dof[i][3]}</div>`;
        }
        tmpstr += `</fieldset></form>
            <div class='dobgrp'><input class='buttonstyled' type='button' value='Save listing as .txt' onclick='save_disassembly(0)' />
            <input class='buttonstyled' type='button' value='Save listing as .html (without html style)'  ${_bShowATRChar ? "disabled" : ""} onclick='save_disassembly(1)' />
            <input class='buttonstyled' type='button' value='Save listing as .html (Atari font included)' onclick='save_disassembly(2)' /></div>
            </div>`;
        _h("#disoption", tmpstr);
        var preFontStyle = document.getElementById("show");
        if (_bShowATRChar) {
            preFontStyle.style.cssText += 'color:#005;background-color:#EEE;font-size:8px;font-family:"Atari"';
        }
    }
    //(PVB END OF ADD)

    //(PVB MOD & ADD) add improvement for the addition of Extract, disassembly and ROM menus
    function render_file(f) { //render_file(f) is called by functions like show_rom(), show_atr ()
        //(PVB COM) rendering = display the content at the right side of the HTML page (#tabs)
        // on top : Class .info
        // on bottom : DIV #file
        var isCode = _exts[f.ext] ? _exts[f.ext].is_code : false;
        var isTxt = _exts[f.ext] ? _exts[f.ext].is_txt : false;
        var isImg = _exts[f.ext] ? _exts[f.ext].is_img : false;
        isImg = isImg || f.ext == 'fnt';
        var pre = !isTxt && !isImg;

        var isRomdump = f.type == "isRomdump";
        var isDisk = f.type == "isDisk";

        var controls = `<div class='radio'>`;
        var buttons = '';
        var addmenu = ''; //(PVB ADD)
        var tmptxt = ''; //(PVB ADD)
        var hexsizetxt = "($" + f.data.length.toString(16).toUpperCase() + ") bytes"; //(PVB ADD)

        if (isTxt) {
            controls += `
                ${f.ext == 'bas' ? check_init('indent', 'Indent') : ""}
                ${f.ext == 'fnt' ? check_init('multicolor', 'Multicolor') : ""}
                ${radio_init('layout', ['38', '40', '80', 'Wide'])}`;
            buttons += `<button type="button" onclick="save(1)">Save As LST</button>`;
        }
        if ((f.ext == 'fnt') || (isImg && is_palettable(f.ext))) {
            controls += `<div class='palette' style='display:inline-block'>${palette(_palette)}</div>`;
        }
        //(PVB ADD) Rom Management Menu
        if (isRomdump) {
            if (f.rom.oldRomType === undefined) //First iteration - no orignal CART type saved
            {
                if (f.rom.romType === 0) {
                    tmptxt = `<strong>Info:</strong> ROM image file has no CARTridge identification header: <strong>` + f.rom.romName; 
                    tmptxt += `</strong><br />You can choose a relevant mapping type from the list (which displays the best possible matches) and download the new CART file.`;
                }
                else {
                    tmptxt = `<strong>Info: "` + f.rom.romName + `"</strong> type has been identified in the ROM image file CARTridge header.`;
                    tmptxt += `<br />No need to change its mapping type from the list, but you can try.`;
                }
            }
            else { //Second iteration - there is an original CART type saved
                if (f.rom.oldRomType > 0)
                    tmptxt = `<strong>Reminder:</strong> Original ROM image file CARTridge type was: <strong>"` + f.rom.oldRomName + `"</strong>`;
                else
                    tmptxt = `<strong>Reminder:</strong> ROM image file has no CARTridge header.<br />You can choose a relevant mapping type from the list, and download the new CART file.`;
            }
            addmenu = `
            <div class='rommap'>
                <div id='rominfoid' class='rominfoid'>${tmptxt}</div>
                <fieldset>
                <legend><b>ROM Memory Bank mapping type selection (75 first types):</b> <a href='https://github.com/atari800/atari800/blob/master/DOC/cart.txt' target='_blank'>(see information link here)</a>
                </legend>
                <div style='display:inline-block;overflow:auto;'>${rom_option(f)}</div>
                <div style='padding-top:10px;'><i>Please note that Emustation/ emulators may not support last rom types above 60 - so try it !</i></div>
                </fielset>
            </div>`;
            tmpromsize = f.data.length >> 10;
            hexsizetxt += " = " + tmpromsize + "KB ROM";
        }
        //(PVB end of ADD)
        //(PVB ADD) ROM or CART saving buttons
        if (f.extractrequest){ //(PVB COM) render the Extract Menu
            addmenu += render_extract(f, isDisk);
        }
        if (isRomdump) { //(PVB COM) Special button to save new CART header in a ".car" file...
            if (f.rom.isCart) //...if it is a CART 
                buttons += ` <button type='button' onclick='save_wo_header()'>Download raw ROM</button>`;
            buttons += ` <button type='button' onclick='save_as_cart()' ${((!f.rom.isCart && f.rom.romType) || (f.rom.isCart && f.rom.oldRomType)) ? '' : 'disabled'}>`;
            buttons += `Download new CART</button>`;
        }
        else {
            buttons += `<button type='button' onclick='save(0)'>Download original file</button>`; 
            //(PVB ADD) Add a Save Buttons for saving XFD/ATX/PRO/DSK into ATR, and ATR/ATX/PRO/DSK into XFD
            //(PVB COM) We know that we have in memory a disk file always converted in ATR
            if (isDisk && f.ext !="atr") { 
                //so we can save it into ATR if it was an XFD for instance
                buttons += `<button type='button' onclick='save_as_dsk("ATR")'>Download ATR file</button>`; 
            }
            if (isDisk && f.ext !="xfd") {
                //so we can save it into XFD if we remove ATR 16-bytes header
                buttons += `<button type='button' onclick='save_as_dsk("XFD")'>Download XFD file</button>`; 
            }
        }
        //(PVB end of ADD)

        controls += `</div>`;

        _h("#tabs",
            `<div class='info'>
            <div style='overflow: auto'>
                <b>${f.name}</b><div style='display:inline-block;float:right'>${buttons}</div>
            </div>
            <div style='font-size:small'> ${ext_option(f)} ${f.data.length} ${hexsizetxt}
                <div style='display:inline-block;float:right'>${controls}</div>
            </div>
        </div>
        ${addmenu}
        <div id='file'>
            <div>
                ${pre ? `<pre id='disoption'></pre><pre id='show'></pre>` : ''}
                ${isImg ? `<canvas id='show'></canvas>` : ''}
                ${isTxt ? `<div contenteditable='true' spellcheck='false' class='atari' id='atari_text'></div>` : ''}
            </div>
            <div id='image_controls'></div>
        </div>`
        );
        if (f.edit_img)
            refresh_image_controls(f);
        if (pre && (isCode || isDisk))
            showDisOption();
        if (isImg) {
            //(PVB TODO) here ! search menu if search activated.
        }
    }

    var _keyboard;
    function render_kb(vis) {
        var kb = _q(".keyboard");
        if (!_keyboard) {
            var s = `<div>`;
            for (var y = 0; y < 16; y++) {
                s += '<div>';
                for (var x = 0; x < 16; x++)
                    s += '<span title="$' + hex(y*16+x) + '">' + String.fromCharCode(x + y * 16 + 0xE000) + '</span>'; //(PVB ADD) the title = display the hexa code
                s += '</div>';
            }
            kb.innerHTML = s;
            kb.onclick = e => keyboard(e.target.innerText);
            _keyboard = kb;
        }

        //vis = vis && _q("#atari_text");
        kb.style.display = vis ? "block" : "none";
        keyboard();
    }

    function toggle_kb() {
        render_kb(_q(".keyboard").style.display != "block");
    }

    function set_tool(name, v) {
        set_class(_q("#" + name), "dimmed", !v);
    }

    //(PVB MOD) Add the E for Extract and S for Search menus
    function floater(evt) {
        var t = evt.target.innerText;
        if (t == String.fromCharCode(0xE000))
            toggle_kb();
        else if (t == "I")
            invert_selection();
        else if (t == "D")
            disassemble_selection();
        else if (t == "O")
            open();
        else if (t == "H")
            toggle_hex();
        //(PVB ADD) the 'E' menu for Extract Menu
        else if (t == "E") 
            toggle_extract();
        //(PVB ADD) the 'S' menu for Search Menu
        else if (t == "S")
            //(PVB TODO) //WIP// Add a Search menu in the file to retreive img, font...
            alert("you clicked on the S Search Menu, this feature is not implemented yet, sorry !"); //(PVB HINT)
        //(PVB end of ADD)
    }

    //(PVB ADD) function get_hex(val) purpose is to convert the input text into the corresponding hex number
    function get_hex(val) {
        if (!val)
            val = 0;
        val = "0x" + val;
        return Number(val);
    }
    //(PVB end of ADD)

    //(PVB ADD) function extract_disass(sectSize, maxSize) is called by HTML event when clicking on "Extract & Disassemble" button
    function extract_disass(sectSize, maxSize) {
        var ad = get_hex(document.getElementById("start_add").value);
        var txtArea = document.getElementById("extractinfo");
        var txt = "";
        if (ad < 0 || ad > 0xFFF9)
            txt += " ! Error: check Disassembly Start field (no code after $FFF9)!";
        if (sectSize) { //(PVB COM) for the "disk" extract menu
            var ss = document.getElementById("start_sect").valueAsNumber;
            var so = document.getElementById("start_sect_off").valueAsNumber;
            var es = document.getElementById("end_sect").valueAsNumber;
            if (ss > es)
                txt += " ! Error: check Start and End Sector!";
            if (sectSize > 128 && ss < es && ss < 4 && so > 127)
                txt += " ! Error: check Offset (0..127 for 3 first sectors)!";
            if (ss < es && ss > 3 && so > (sectSize - 1))
                txt += " ! Error: check Offset (too big)!"; 
            if ((ss == es && ss < 4 && so > 125) || (ss == es && ss > 3 && so > (sectSize - 3)))
                txt += " ! Error: check Offset (min 3 bytes for 1 sector disass.)!";
            if (txt !== "") {
                txtArea.innerText = txt;
                console.log("extract_disass===>Wrong number ! start_add:" + ad + ", start_sect:" + ss + ", end_sect:" + es + ", start_sect_off:" + so);
                return false;
            }     
            _extracted_disk = {start_sect: ss, start_sect_off: so, end_sect: es, start_add: ad };
        }
        else { //(PVB COM) for the "file" extract menu
            var so = get_hex(document.getElementById("start_offset").value);
            var eo = get_hex(document.getElementById("end_offset").value);
            if (so >= maxSize || eo >= maxSize || so > eo || so < 0 || eo < 0)
                txt += " ! Error: check Start and End Offset!";
            if (txt !== "") {
                txtArea.innerText = txt;
                console.log("extract_disass===>Wrong number ! start_add:" + ad + ", start_offset:" + so + ", end_offset:" + eo);
                return false;
            }     
            _extracted_file = {start_offset: so, end_offset: eo, start_add: ad };
        }
        if (_shown) {
            _shown.launch_extract = true;
            console.log("extract_disass===>_shown:"); //(PVB CONSOLE HINT)
            console.log(_shown); //(PVB CONSOLE HINT)
        }        
        refresh();
        return false;
    }
    //(PVB end of ADD)

    //(PVB ADD) extract_reset() function is called by HTML event when clicking on "ReShow Full Hex Dump"
    function extract_reset() {
        if (_shown.launch_extract) {
            _shown.launch_extract = false;
            refresh();
        }
        return;
    }
    //(PVB end of ADD)

    //(PVB ADD) apply_rommap(id) function is called by HTML event when changing the "ROM Memory Bank mapping type selection"
    function apply_rommap(id) {
        var selectRomType = document.getElementById("rommapid").value; //return the selected choice from the list like "Type_03"
        var f = get_file(id);
        var rf = f.rom;
        console.log("apply_rommap()===> value ..."); //(PVB CONSOLE HINT)
        /* (PVB COM) note : impossible de changer le texte d'information dans la présente fonction - comme par exemple avec :
        txtArea = document.getElementById("rominfoid") et txtArea.innerText = 'REMINDER : Original CART type was ' + rf.romTypeTxt +` (` + rf.romName + `)`;
        à cause de l'appel à refresh() obligatoire pour afficher le nouveau type choisi,
        => il faut donc changer le texte d'information dans le render_file().*/
        if (rf.oldRomType === undefined) { //on vient de faire une demande de changer le type
            rf.oldRomType = rf.romType; // sauvegarde de la valeur CART
            rf.oldRomName = rf.romTypeTxt + ": " + rf.romName; // sauvegarde du type + nom original
        }
        rf.romTypeTxt = selectRomType;
        rf.romType = Number(selectRomType.slice(5));
        if (!isNaN(rf.romType)) {//protection of convertion
            rf.romData[7] = rf.romType;
        }
        rf.romName = _romtypes[selectRomType].name;
        rf.romMachine = _romtypes[selectRomType].machine;
        rf.romMap = _romtypes[selectRomType].memmap;
        console.log("oldRomType = " + rf.oldRomType); //(PVB CONSOLE HINT)
        console.log("selectRomType = " + selectRomType); //(PVB CONSOLE HINT)
        /* this is a code for bank re-ordering.... used for Bounty Bob A5200 ROM
        if (rf.romType == 77) {
            var tmpData = new Uint8Array(rf.romData.length);
            for (var i=0; i < 16; i++)
                tmpData[i] = rf.romData[i];
            for (var i=0; i < 0x2000; i++)
                tmpData[i + 0x8010] = rf.romData[0x10 + i];
            for (var i=0; i < 0x8000; i++)
                tmpData[i + 0x10] = rf.romData[0x2010 + i];
            tmpData[7] = 7;
            rf.tmpData = tmpData;
        }*/
        refresh(f);
        return;
    }
    //(PVB end of ADD)
   
    function draggable(el, name) {
        //(PVB COM) name est par exemple "Donkey Kong.rom disassembly"; el = div.floated.disassembly
        var x0, y0;
        el.querySelector('.draggable').innerText = name;
        el.onmousedown = (e) => {
            e.preventDefault();
            x0 = e.clientX;
            y0 = e.clientY;
            document.onmouseup = () => {
                document.onmouseup = null;
                document.onmousemove = null;
            }
            document.onmousemove = (e) => {
                e.preventDefault();
                var x = x0 - e.clientX;
                var y = y0 - e.clientY;
                x0 = e.clientX;
                y0 = e.clientY;
                el.style.left = (el.offsetLeft - x) + "px";
                el.style.top = (el.offsetTop - y) + "px";
            }
        }
    }

</script>

<body>
    <div class="floater atari keyboard"></div>
    <div class="floater disassembly" hidden>
        <span class='close-icon' onclick='this.parentElement.hidden = true'></span>
        <div class='draggable'>
        </div>
        <pre id='disassembly'></pre>
    </div>
    <div class="floater atari tools" onclick='floater(event)' id="tools">
        <span title='ATASCII Keyboard'>&#xE000</span><br />
        <span title='Open File'>O</span><br />
        <span title='Toggle Hex View'>H</span><br />
        <span id="I" class='dimmed' title='Invert Char Selection'>I</span><br />
        <span id="D" class='dimmed' title='Disassemble Char Selection'>D</span><br />
        <span title='Toggle Extract & Disassemble View'>E</span><br />
        <span title='Toggle Search Data View'>S</span><br />
    </div>
    <header>
        <h2>Atari 8-bit Rom Image File Explorer</h2>
        <br />
    </header>
    <div style="display:flex;flex-direction:row">

        <nav style="min-width:352px; max-width:352px; margin-right:8px;" id="toc">
            <div id="menu_container"></div>
            <p style="text-align:center;color:#999;font-weight:300">
                <span class='open' onclick='_q("#fe").click()'>Open</span><br />
                <a href="https://github.com/pvbestinfoo/Atari-8-bit-Rom-File-Explorer">https://github.com/pvbestinfoo/Atari-8-bit-Rom-File-Explorer</a><br />
                <i>Based upon the work of :<br />
                <a href="https://github.com/rossumur/esp_8_bit">https://github.com/rossumur/esp_8_bit</a></i><br /><br />
                <i><b>Ctrl+O</b> opens File Dialog</i><br />
                <i><b>Ctrl+H</b> toggles Hex View</i><br />
                <i><b>Shift+Click</b> opens Keyboard in Editor</i><br />
            </p>
            <input type="file" id="fe" multiple style="display:none" aria-label="Drag files here">
        </nav>

        <main style="border:solid 1px #CCC">
            <div id="tabs"></div>
        </main>
    </div>
    <script>load()</script>
</body>

</html>